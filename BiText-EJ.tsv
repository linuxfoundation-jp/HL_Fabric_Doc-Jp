Glossary	Glossary (用語集)
Terminology is important, so that all Hyperledger Fabric users and developers agree on what we mean by each specific term.	すべてのHyperledger Fabricユーザーと開発者が、それぞれの特定の用語が何を意味するかについて合意できるためには、用語集が重要です。
What is a smart contract for example.	例えば、スマートコントラクトとは何でしょうか。
The documentation will reference the glossary as needed, but feel free to read the entire thing in one sitting if you like; it's pretty enlightening!	本ドキュメントは必要に応じてこの用語集を参照しますが、もしよろしければ全体に目を通してみてください。とても勉強になるでしょう。
Anchor Peer	Anchor Peer (アンカーピア)
Used by gossip to make sure peers in different organizations know about each other.	アンカーピアは、異なる組織に属するピアが互いを知るためにゴシッププロトコルによって利用されます。
When a configuration block that contains an update to the anchor peers is committed, peers reach out to the anchor peers and learn from them about all of the peers known to the anchor peer(s).	アンカーピアの更新を含むコンフィギュレーションブロックがコミットされたとき、各ピアは新しいアンカーピアにアクセスし、アンカーピアが認識している全てのピアについて学習します。
Once at least one peer from each organization has contacted an anchor peer, the anchor peer learns about every peer in the channel.	各組織から少なくとも1つ以上のピアがアンカーピアにコンタクトを取ると、そのアンカーピアはそのチャネル内の全てのピアについて学習します。
Since gossip communication is constant, and because peers always ask to be told about the existence of any peer they don't know about, a common view of membership can be established for a channel.	ゴシップのコミュニケーションは定常的に行われ、ピアは常に自分が知らないピアの存在を通知するよう要求しているため、あるチャネルの所属メンバーについて共通認識を確立できます。
For example, let's assume we have three organizations --- ``A``, ``B``, ``C`` --- in the channel and a single anchor peer --- ``peer0.orgC`` --- defined for organization ``C``.	たとえば、あるチャネルに ``A`` と ``B`` と ``C`` の3つの組織があり、組織 ``C`` のアンカーピアとして ``peer0.orgC`` が定義されているとします。
When ``peer1.orgA`` (from organization ``A``) contacts ``peer0.orgC``, it will tell ``peer0.orgC`` about ``peer0.orgA``.	組織 ``A`` に属する ``peer1.orgA`` が ``peer0.orgC`` にコンタクトを取った時、``peer0.orgC`` に ``peer0.orgA`` に関して教えるでしょう。
And when at a later time ``peer1.orgB`` contacts ``peer0.orgC``, the latter would tell the former about ``peer0.orgB``.	そして、その後 ``peer1.orgB`` が ``peer0.orgC`` にコンタクトを取った時、``peer0.orgC`` が ``peer1.orgB`` に ``peer0.orgA`` について知らせます。
From that point forward, organizations ``A`` and ``B`` would start exchanging membership information directly without any assistance from ``peer0.orgC``.	これ以降、組織 ``A`` と ``B`` はメンバーシップ情報を ``peer0.orgC`` を介さず直接交換するようになります。
As communication across organizations depends on gossip in order to work, there must be at least one anchor peer defined in the channel configuration.	組織間の通信はゴシップに依存しているため、チャネル設定には少なくとも1つのアンカーピアが定義されている必要があります。
It is strongly recommended that every organization provides its own set of anchor peers for high availability and redundancy.	高可用性と冗長性のために、すべての組織がアンカーピアのセットを提供することを強くお勧めします。
ACL	ACL (アクセス制御リスト)
An ACL, or Access Control List, associates access to specific peer resources (such as system chaincode APIs or event services) to a Policy_(which specifies how many and what types of organizations or roles are required).	ACL (アクセス制御リスト) は、特定のピアのリソース (例えばシステムチェーンコードの API やイベントサービス) へのアクセスを、:ref:`ポリシー <Policy>` (どのタイプの組織あるいはロールがいくつ必要か指定するもの) に関連付けるものです。
The ACL is part of a channel's configuration.	ACLはチャネルの設定の一部です。
It is therefore persisted in the channel's configuration blocks, and can be updated using the standard configuration update mechanism.	そのため、チャネルのコンフィギュレーションブロックに保存され、更新は通常のチャネルのコンフィギュレーションブロックの更新メカニズムを通して行います。
An ACL is formatted as a list of key-value pairs, where the key identifies the resource whose access we wish to control, and the value identifies the channel policy (group) that is allowed to access it.	ACLはキーと値のペアのリストとしてフォーマットされ、そこではキーがアクセス制御したいリソースを特定し、値はそのリソースへのアクセスが許可されたグループを指定するチャネルポリシーを特定します。
For example ``lscc/GetDeploymentSpec: /Channel/Application/Readers`` defines that the access to the life cycle chaincode ``GetDeploymentSpec`` API (the resource) is accessible by identities which satisfy the ``/Channel/Application/Readers`` policy.	たとえば ``lscc/GetDeploymentSpec: /Channel/Application/Readers`` はライフサイクルチェーンコードの API ``GetDeploymentSpec`` が、ポリシー ``/Channel/Application/Readers`` を満たす主体からアクセス可能であることを定義します。
A set of default ACLs is provided in the ``configtx.yaml`` file which is used by configtxgen to build channel configurations.	デフォルトのACL設定はファイル ``configtx.yaml`` により与えられ、このファイルは configtxgen がチャネル設定をビルドするために使用されます。
The defaults can be set in the top level "Application" section of ``configtx.yaml`` or overridden on a per profile basis in the "Profiles" section.	このデフォルト設定は、``configtx.yaml`` の "Application" セクションのトップレベルで指定するか、"Profile" セクションでプロファイルごとに上書きして指定できます。
Block	Block (ブロック)
Block B1 is linked to block B0. Block B2 is linked to block B1.	ブロック B1 はブロック B0 にリンクされ、ブロック B2 はブロック B1 にリンクされています。
A block contains an ordered set of transactions. It is cryptographically linked to the preceding block, and in turn it is linked to be subsequent blocks.	ブロックは順序付けられたトランザクションのセットを含んでいます。ブロックは暗号論的に前のブロックにリンクされ、そのブロック自身も後続のブロックによってリンクされる。
The first block in such a chain of blocks is called the genesis block.	一連のブロックチェーンの最初のブロックはジェネシスブロック (genesis block)と呼ばれます。
Blocks are created by the ordering service, and then validated and committed by peers.	ブロックはオーダリングサービスによって生成され、ピアによって検証およびコミットされます。
Chain	Chain (チェーン)
Blockchain B contains blocks 0, 1, 2.	ブロックチェーン B にはブロック 0, 1, 2 を含みます。
The ledger's chain is a transaction log structured as hash-linked blocks of transactions.	台帳のチェーンはトランザクションのログで、複数のトランザクションをまとめたブロックをハッシュチェーンでリンクした構造をしています。
Peers receive blocks of transactions from the ordering service, mark the block's transactions as valid or invalid based on endorsement policies and concurrency violations, and append the block to the hash chain on the peer's file system.	ピアはオーダリングサービスからブロックを受け取ると、エンドースメントポリシーと同時実行違反の有無に基づき各トランザクションが正当かどうかをマークした上で、ピアのファイルシステム上のハッシュチェーンに追加します。
Chaincode	Chaincode (チェーンコード)
See Smart-Contract.	詳細についてはスマートコントラクトを参照。
Channel	Channel (チャネル)
Channel C connects application A1, peer P2 and ordering service O1.	チャネル C はアプリケーション A1、ピア P2、およびオーダリングサービス O1 に接続しています。
A channel is a private blockchain overlay which allows for data isolation and confidentiality.	チャネルとは、データの分離と機密性を実現するためにプライベートブロックチェーンのオーバーレイです。
A channel-specific ledger is shared across the peers in the channel, and transacting parties must be authenticated to a channel in order to interact with it.	チャネル固有の台帳はそのチャネルに属するピアの間で共有され、トランザクションを実行する関係者はチャネルとやりとりするためにチャネルに対して認証される必要があります。
Channels are defined by a Configuration-Block.	チャネルはコンフィギュレーションブロックで定義されています。
Commit	Commit (コミット)
Each Peer_ on a channel validates ordered blocks of transactions and then commits (writes/appends) the blocks to its replica of the channel Ledger_.	あるチャネル上の各ピア (Peer_) は、順序付けられたトランザクションのブロックを検証し、そのブロックをそのチャネルの台帳 (Ledger_) の複製にコミットします。
Peers also mark each transaction in each block as valid or invalid.	ピアは各ブロック内の各トランザクションに対して正当かどうかをマークします。
Concurrency Control Version Check	Concurrency Control Version Check (同時処理制御バージョンチェック)
Concurrency Control Version Check is a method of keeping ledger state in sync across peers on a channel.	同時処理制御バージョンチェックは、チャネル上のピア間で台帳の状態を同期させる方法です。
Peers execute transactions in parallel, and before committing to the ledger, peers check whether the state read at the time the transaction was executed has been modified.	ピアはトランザクションを並列に実行し、台帳にコミットする前に、トランザクションが実行されたときに読み込まれた状態が変更されているかどうかを確認します。
If the data read for the transaction has changed between execution time and commit time, then a Concurrency Control Version Check violation has occurred, and the transaction is marked as invalid on the ledger and values are not updated in the state database.	そのトランザクションのために読み込まれたデータが実行時とコミット時の間で変更された場合、同時実行制御バージョンチェックの違反が発生し、トランザクションは台帳上で無効とマークされ、ステートデータベース中の値は更新されません。
Configuration Block	Configuration Block (コンフィギュレーションブロック)
Contains the configuration data defining members and policies for a system chain (ordering service) or channel.	コンフィギュレーションブロックはシステムチェーン (オーダリングサービス) あるいはチャネルのメンバーやポリシーを定義する設定データを含んでいます。
Any configuration modifications to a channel or overall network (e.g. a member leaving or joining) will result in a new configuration block being appended to the appropriate chain.	チャネルまたはネットワーク全体に対する設定の変更 (たとえばメンバーの削除、追加など) があると、新しいコンフィギュレーションブロックが適切なチェーンに追加されることになります。
This block will contain the contents of the genesis block, plus the delta.	このブロックには、ジェネシスブロックの内容と、そこからの差分の情報が含まれています。
Consensus	Consensus (合意形成)
A broader term overarching the entire transactional flow, which serves to generate an agreement on the order and to confirm the correctness of the set of transactions constituting a block.	トランザクションフロー全体を包括するより広い用語で、トランザクションの実行順序に関する合意を生成して、ブロックを構成するトランザクションセットの正確さを確認するために行われるプロセスを指しています。
Consenter set	Consenter set (同意者セット)
In a Raft ordering service, these are the ordering nodes actively participating in the consensus mechanism on a channel.	同意者セットは、Raftオーダリングサービスにおいて、チャネル上の合意形成機構に参加しているアクティブなオーダリングノードを指しています。
If other ordering nodes exist on the system channel, but are not a part of a channel, they are not part of that channel's consenter set.	システムチャネルに存在していても、あるチャネルの一部でないオーダリングノードは、そのチャネルにおいては同意者セットの一員ではありません。
Consortium	Consortium (コンソーシアム)
A consortium is a collection of non-orderer organizations on the blockchain network.	コンソーシアムは、ブロックチェーンネットワーク上のorderer組織を除く組織の集合です。
These are the organizations that form and join channels and that own peers.	これらは、チャネルを形成するとともにチャネルに参加しており、ピアを所有する組織です。
While a blockchain network can have multiple consortia, most blockchain networks have a single consortium.	一つのブロックチェーンネットワークは複数のコンソーシアムを持つことができますが、ほとんどのブロックチェーンネットワークは単一のコンソーシアムを持っています。
At channel creation time, all organizations added to the channel must be part of a consortium.	チャネルの作成時に、チャネルに追加されるすべての組織は一つのコンソーシアムの一員である必要があります。
However, an organization that is not defined in a consortium may be added to an existing channel.	ただし、コンソーシアム内で定義されていない組織も、既存のチャネルに追加することができます。
Chaincode definition	Chaincode definition (チェーンコード定義)
A chaincode definition is used by organizations to agree on the parameters of a chaincode before it can be used on a channel.	チェーンコード定義は、チェーンコードがあるチャネル上で利用可能になる前にチェーンコードのパラメータについて組織間で合意するために使用されます。
Each channel member that wants to use the chaincode to endorse transactions or query the ledger needs to approve a chaincode definition for their organization.	そのチェーンコードを使ってトランザクションの承認、あるいは台帳のクエリを行いたいチャネルの各メンバーは、その組織に対するチェーンコード定義を承認する必要があります。
Once enough channel members have approved a chaincode definition to meet the Lifecycle Endorsement policy (which is set to a majority of organizations in the channel by default), the chaincode definition can be committed to the channel.	チャネルのメンバーからチェーンコード定義の承認が十分な数得られ、ライフサイクルエンドースメントポリシー (デフォルトではチャネルに属する組織の過半数) を満たすと、チェーンコード定義をチャネルにコミットできます。
After the definition is committed, the first invoke of the chaincode (or, if requested, the execution of the Init function) will start the chaincode on the channel.	チェーンコード定義がコミットされた後は、チェーンコードの最初の呼び出し時 (あるいは要求された場合は Init 関数の実行時) にチャネル上のチェーンコードが開始します。
Dynamic Membership	Dynamic Membership (動的メンバーシップ)
Hyperledger Fabric supports the addition/removal of members, peers, and ordering service nodes, without compromising the operationality of the overall network.	Hyperledger Fabricは、ネットワーク全体の運用性を損なうことなく、メンバー、ピア、およびオーダリングサービスノードの追加・削除をサポートします。
Dynamic membership is critical when business relationships adjust and entities need to be added/removed for various reasons.	動的メンバーシップは、ビジネス関係を調整し、さまざまな理由でエンティティを追加または削除する必要がある場合に重要です。
Endorsement	Endorsement (エンドースメント)
Refers to the process where specific peer nodes execute a chaincode transaction and return a proposal response to the client application.	エンドースメントは、特定のピアノードがチェーンコードトランザクションを実行し、提案応答をクライアントアプリケーションに返すプロセスを指します。
The proposal response includes the chaincode execution response message, results (read set and write set), and events, as well as a signature to serve as proof of the peer's chaincode execution.	提案応答には、チェーンコード実行応答メッセージ、結果 (読み込みセットおよび書き込みセット)、イベント、およびピアのチェーンコード実行の証明となる署名が含まれます。
Chaincode applications have corresponding endorsement policies, in which the endorsing peers are specified.	チェーンコードアプリケーションには対応するエンドースメントポリシーがあり、そこではエンドースできるピアが指定されています。
Endorsement policy	Endorsement policy (エンドースメントポリシー)
Defines the peer nodes on a channel that must execute transactions attached to a specific chaincode application, and the required combination of responses (endorsements).	エンドースメントポリシーは特定のチェーンコードアプリケーションに紐付けられたトランザクションを実行しなければならないチャネル上のピアノードと、必要な提案応答 (エンドースメント) の組み合わせを定義します。
A policy could require that a transaction be endorsed by a minimum number of endorsing peers, a minimum percentage of endorsing peers, or by all endorsing peers that are assigned to a specific chaincode application.	ポリシーは、あるチェーンコードをエンドースできるピアの中から、ピアの数、ピアの割合、あるいは全てのピアといった形で、トランザクションに対して必要となるエンドースメントを定義することができます。
Policies can be curated based on the application and the desired level of resilience against misbehavior (deliberate or not) by the endorsing peers.	ポリシーはアプリケーションと、エンドーシングピアの不正行為 (意図的であるかに関わない) に対する望ましいレベルの回復力に基づいて決められます。
A transaction that is submitted must satisfy the endorsement policy before being marked as valid by committing peers.	送信されたトランザクションは、コミットピアにより正当とマークされる前に、エンドースメントポリシーを満たさなければなりません。
Follower	Follower (フォロワ)
In a leader based consensus protocol, such as Raft, these are the nodes which replicate log entries produced by the leader.	Raftのようなリーダーベースの合意プロトコルにおいて、フォロワはリーダーによって生成されたログエントリを複製するノードのことを意味します。
In Raft, the followers also receive "heartbeat" messages from the leader.	Raftでは、フォロワはリーダーから「ハートビート」メッセージも受け取ります。
In the event that the leader stops sending those message for a configurable amount of time, the followers will initiate a leader election and one of them will be elected leader.	リーダーが設定可能な期間これらのメッセージを送信しなかった場合、フォロワはリーダー選出を開始し、フォロワの中の一つがリーダーとして選出されます。
Genesis Block	Genesis Block (ジェネシスブロック)
The configuration block that initializes the ordering service, or serves as the first block on a chain.	ジェネシスブロックはオーダリングサービスを初期化する、またはチェーンの最初のブロックとして機能するコンフィギュレーションブロックのことを意味します。
Gossip Protocol	Gossip Protocol (ゴシッププロトコル)
The gossip data dissemination protocol performs three functions:	ゴシッププロトコル (データ配布プロトコル) は以下の3つの機能を実行します。
1) manages peer discovery and channel membership;	1. ピアディスカバリとチャネルメンバーシップを管理する
2) disseminates ledger data across all peers on the channel;	2. チャネル上のすべてのピアに台帳データを配布する
3) syncs ledger state across all peers on the channel.	3. チャネル上のすべてのピアの状態を同期させる
Refer to the Gossip topic for more details.	ゴシップの詳細についてはGossipを参照してください。
Hyperledger Fabric CA is the default Certificate Authority component, which issues PKI-based certificates to network member organizations and their users.	Hyperledger Fabric CAは、PKIベースの証明書をネットワークメンバー組織とそのユーザーに対して発行するデフォルトの認証局コンポーネントです。
The CA issues one root certificate (rootCert) to each member and one enrollment certificate (ECert) to each authorized user.	CAは、各メンバーに対して一つのルート証明書 (rootCert) を発行し、許可された各ユーザーに対して一つの登録証明書 (ECert) を発行します。
A method to initialize a chaincode application.	Initはチェーンコードアプリケーションを初期化するメソッドです。
All chaincodes need to have an an Init function.	すべてのチェーンコードはInit関数が必要です。
By default, this function is never executed.	デフォルトでは、この関数は実行されません。
However you can use the chaincode definition to request the execution of the Init function in order to initialize the chaincode.	しかし、チェーンコード定義を使用すると、チェーンコードを初期化するためにInit関数の実行を要求できます。
The process of placing a chaincode on a peer's file system.	Installはピアのファイルシステムにチェーンコードを配置する処理です。
The process of starting and initializing a chaincode application on a specific channel.	Instantiateは特定のチャネルでチェーンコードアプリケーションを開始および初期化する処理です。
After instantiation, peers that have the chaincode installed can accept chaincode invocations.	インスタンス化の後、チェーンコードがインストールされているピアはチェーンコードの関数呼び出し (Invoke) を受け入れることができます。
NOTE: *This method i.e. Instantiate was used in the 1.4.x and older versions of the chaincode lifecycle.	注: *この処理 (Instantiate) は、1.4.x以前のバージョンのチェーンコードライフサイクルにおいて使用されていました。
For the current procedure used to start a chaincode on a channel with the new Fabric chaincode lifecycle introduced as part of Fabric v2.0, see Chaincode-definition_.*	Fabric v2.0に導入された新しいFabricチェーンコードライフサイクルを用いたチャネルでチェーンコードを開始する手順については、* :ref:`チェーンコード定義<Chaincode-definition>` *を参照してください。*
Used to call chaincode functions.	Invokeは、チェーンコード関数を呼び出すために使用します。
A client application invokes chaincode by sending a transaction proposal to a peer.	クライアントアプリケーションは、ピアにトランザクション提案を送信することによってチェーンコードを呼び出します。
The peer will execute the chaincode and return an endorsed proposal response to the client application.	ピアはチェーンコードを実行し、エンドースされた提案応答をクライアントアプリケーションに返します。
The client application will gather enough proposal responses to satisfy an endorsement policy, and will then submit the transaction results for ordering, validation, and commit.	クライアントアプリケーションは、エンドースメントポリシーを満たすために十分な提案応答を収集した後、順序付け、検証、およびコミットのためにトランザクション結果を送信します。
The client application may choose not to submit the transaction results.	クライアントアプリケーションは、トランザクション結果を送信しないという選択もできます。
For example if the invoke only queried the ledger, the client application typically would not submit the read-only transaction, unless there is desire to log the read on the ledger for audit purpose.	たとえば、Invokeが台帳のクエリのみ行う場合、監査目的で台帳に読み込みを記録したいということがないならば、クライアントアプリケーションは通常、読み込み専用トランザクションを発行しません。
The invoke includes a channel identifier, the chaincode function to invoke, and an array of arguments.	Invokeの呼び出しには、チャネル識別子、呼び出すチェーンコード関数名、および引数の配列が渡されます。
Leader	Leader (リーダー)
In a leader based consensus protocol, like Raft, the leader is responsible for ingesting new log entries, replicating them to follower ordering nodes, and managing when an entry is considered committed.	Raftのようなリーダーベースの合意プロトコルにおいて、リーダーは新しいログエントリの取り込み、それらのフォロワのオーダリングノードへの複製、およびエントリがコミットされたと見なされるタイミングの管理、の責任を担っています。
This is not a special type of orderer.	リーダーはordererの特別な タイプ を表すものではありません。
It is only a role that an orderer may have at certain times, and then not others, as circumstances determine.	リーダーはあるordererが環境によって決まる特定の期間だけ担っている役割です。
Leading Peer	Leading Peer (リーダーピア)
Each Organization_ can own multiple peers on each channel that they subscribe to.	各 :ref:`組織<organization>` は、加入している各チャネルに対して複数のピアを所有できます。
One or more of these peers should serve as the leading peer for the channel, in order to communicate with the network ordering service on behalf of the organization.	これらのピアのうち1つ以上は、組織を代表してネットワークオーダリングサービスと通信するために、チャネルのリーダーピアとして動作する必要があります。
The ordering service delivers blocks to the leading peer(s) on a channel, who then distribute them to other peers within the same organization.	オーダリングサービスは、チャネル上のリーダーピアにブロックを配信し、リーダーピアは同じ組織内の他のピアにブロックを配信します
Ledger	Ledger (台帳)
A ledger consists of two distinct, though related, parts -- a "blockchain" and the "state database", also known as "world state".	台帳は、2つの (関連はあるものの) 異なる部分で構成されています。「ブロックチェーン」と「ステートデータベース」 (「ワールドステート」とも呼ばれます) です。
Unlike other ledgers, blockchains are immutable -- that is, once a block has been added to the chain, it cannot be changed.	他の台帳とは異なり、ブロックチェーンは イミュータブル です。つまり、一度ブロックがチェーンに追加されたら、そのブロックは変更できません。
In contrast, the "world state" is a database containing the current value of the set of key-value pairs that have been added, modified or deleted by the set of validated and committed transactions in the blockchain.	対照的に、「ワールドステート」はキーと値のペアのセットの現在の値を含むデータベースで、ブロックチェーン内の検証済みトランザクションとコミット済みトランザクションのセットによって追加、変更、または削除されたものです。
It's helpful to think of there being one logical ledger for each channel in the network.	ネットワーク内の各チャネルに対して一つの 論理的な 台帳があると考えるとわかりやすいでしょう。
In reality, each peer in a channel maintains its own copy of the ledger -- which is kept consistent with every other peer's copy through a process called consensus.	実際は、チャネル上の各ピアが台帳のコピーを維持しており、各コピーは 合意形成 と呼ばれるプロセスを経て一貫性が保たれています。
The term Distributed Ledger Technology (DLT) is often associated with this kind of ledger -- one that is logically singular, but has many identical copies distributed across a set of network nodes (peers and the ordering service).	分散台帳技術 (Distributed Ledger Technology: DLT) という言葉は、論理的には単一ですが、そのコピーをネットワークノード(ピアやオーダリングサービス)に分散させているような台帳によく関連付けられます。
Log entry	Log entry (ログエントリ)
The primary unit of work in a Raft ordering service, log entries are distributed from the leader orderer to the followers.	ログエントリはRaftオーダリングサービスの作業の基本単位で、リーダーのordererからフォロワに配布されます。
The full sequence of such entries known as the "log".	そのようなログエントリの完全なシーケンスのことを「ログ」と呼びます。
The log is considered to be consistent if all members agree on the entries and their order.	ログは、すべてのメンバーがエントリとその順序について同意する場合、一貫していると見なされます。
Member 	Member (メンバー)
See Organization_.	:ref:`組織<Organization>` を参照してください。
Membership Service Provider	Membership Service Provider (メンバーシップサービスプロバイダ)
An MSP, 'ORG.MSP'	ORG.MSPというMSP
The Membership Service Provider (MSP) refers to an abstract component of the system that provides credentials to clients, and peers for them to participate in a Hyperledger Fabric network.	Membership Service Provider (MSP; メンバーシップサービスプロバイダ)は、クライアントやピアに資格情報を提供してHyperledger Fabricのネットワークに参加できるようにするためのシステムの抽象コンポーネントを指しています。
Clients use these credentials to authenticate their transactions, and peers use these credentials to authenticate transaction processing results (endorsements).	クライアントはこれらの資格情報を使用してトランザクションを認証し、ピアはこれらの資格情報を使用してトランザクションの処理結果 (エンドースメント) を認証します。
While strongly connected to the transaction processing components of the systems, this interface aims to have membership services components defined, in such a way that alternate implementations of this can be smoothly plugged in without modifying the core of transaction processing components of the system.	このインターフェースは、システムのトランザクション処理コンポーネントに強く結び付けられている一方で、メンバーシップサービスのコンポーネントを、異なる実装のものをスムーズに (システムのトランザクション処理コンポーネントのコアを変更することなく) プラグインできるよう定義する狙いがあります。
Membership Services	Membership Services (メンバーシップサービス)
Membership Services authenticates, authorizes, and manages identities on a permissioned blockchain network.	メンバーシップサービスは、許可型ブロックチェーンネットワーク上のアイデンティティを認証、認可、管理します。
The membership services code that runs in peers and orderers both authenticates and authorizes blockchain operations.	メンバーシップサービスのコードはピアおよびorderer上で実行され、ブロックチェーン操作の認証と認可の両方を行います。
It is a PKI-based implementation of the Membership Services Provider (MSP) abstraction.	メンバーシップサービスはMSPをPKIベースで実装したものです。
Ordering Service	Ordering Service (オーダリングサービス)
Also known as orderer.	オーダリングサービスは orderer とも呼ばれ、
A defined collective of nodes that orders transactions into a block and then distributes blocks to connected peers for validation and commit.	トランザクションの順序を決めてブロックを作り、接続しているピアに検証とコミット処理のためにブロックを配布する役割を持ったノードの集合と定義されています。
The ordering service exists independent of the peer processes and orders transactions on a first-come-first-serve basis for all channels on the network.	オーダリングサービスはピアのプロセスから独立して存在し、ネットワーク上のすべてのチャネルに対してトランザクションを先着順に並べます。
It is designed to support pluggable implementations beyond the out-of-the-box Kafka and Raft varieties.	オーダリングサービスは、KafkaやRaftのような外部コンポーネントの違いを超えてプラグイン可能な実装をサポートするように設計されています。
It is a common binding for the overall network; it contains the cryptographic identity material tied to each Member_.	これは、ネットワーク全体に対して共通のバインディングです。つまり各 :ref:`メンバー<Member>` に紐付けられた暗号学的な識別情報を含んでいます。
Organization	Organization (組織)
An organization, 'ORG'	組織 'ORG'
Also known as "members", organizations are invited to join the blockchain network by a blockchain network provider.	組織は「メンバー」とも呼ばれ、ブロックチェーンネットワークプロバイダからブロックチェーンネットワークに招待されて参加します。
An organization is joined to a network by adding its Membership Service Provider (MSP_) to the network.	組織はメンバーシップサービス・プロバイダ (MSP_) をネットワークに追加することで参加します。
The MSP defines how other members of the network may verify that signatures (such as those over transactions) were generated by a valid identity, issued by that organization.	MSPは、その組織によって発行された有効なアイデンティティによって署名 (トランザクションに対する署名、など) が生成されたことを、ネットワークの他のメンバーがどのように検証するかを定義します。
The particular access rights of identities within an MSP are governed by policies which are also agreed upon when the organization is joined to the network.	MSP内のアイデンティティの特定のアクセス権は、組織がネットワークに参加したときに合意されたポリシーによって管理されます。
An organization can be as large as a multi-national corporation or as small as an individual.	組織は、多国籍企業のように大きいものでも、個人ほどの小さいものでも構いません。
The transaction endpoint of an organization is a Peer_.	組織のトランザクションのエンドポイントはピア (Peer_) です。
A collection of organizations form a Consortium_.	組織の集合はコンソーシアム (Consortium_) を形成します。
While all of the organizations on a network are members, not every organization will be part of a consortium.	ネットワーク上のすべての組織はメンバーですが、すべての組織がコンソーシアムに参加しているわけではありません。
Peer	Peer (ピア)
A peer, 'P'	ピア 'P'
A network entity that maintains a ledger and runs chaincode containers in order to perform read/write operations to the ledger.	ピアは台帳を維持するネットワークエンティティであり、台帳への読み書き操作を行うためにチェーンコードのコンテナを実行します。
Peers are owned and maintained by members.	ピアはメンバーによって所有および維持されます。
Policy	Policy (ポリシー)
Policies are expressions composed of properties of digital identities, for example: ``OR('Org1.peer', 'Org2.peer')``.	ポリシーは、デジタルアイデンティティのプロパティで構成される式です。たとえば ``OR('Org1.peer', 'Org2.peer')`` のようなものです.
They are used to restrict access to resources on a blockchain network.	これはブロックチェーンネットワーク上のリソースへのアクセスを制限するために使用されます。
For instance, they dictate who can read from or write to a channel, or who can use a specific chaincode API via an ACL_.	たとえば、チャネルに対して誰が読み込めるか・書き込めるかを指定したり、 :ref:`ACL<glossary_ACL>` を用いて誰が特定のチェーンコードAPIを利用できるかを指定したりできます。
Policies may be defined in ``configtx.yaml`` prior to bootstrapping an ordering service or creating a channel, or they can be specified when instantiating chaincode on a channel.	ポリシーはオーダリングサービスを起動する前、あるいはチャネルを作成する前に ``configtx.yaml`` 内で定義してもよいですし、あるいはチャネル上でチェーンコードをインスタンス化する際に指定することもできます。
A default set of policies ship in the sample ``configtx.yaml`` which will be appropriate for most networks.	デフォルト設定はサンプルの ``configtx.yaml`` に記述されていて、大半のネットワークではその設定が適しているでしょう。
Private Data	Private Data (プライベートデータ)
Confidential data that is stored in a private database on each authorized peer, logically separate from the channel ledger data.	プライベートデータは各ピアのプライベートデータベースに保存される機密データを意味します。プライベートデータベースは各ローカルピアにのみアクセスが許可されており、チャネルの台帳データとは論理的に分離されています。
Access to this data is restricted to one or more organizations on a channel via a private data collection definition.	プライベートデータへのアクセスは、プライベートデータコレクションの定義に基づきチャネル上の1つ以上の組織に制限されます。
Unauthorized organizations will have a hash of the private data on the channel ledger as evidence of the transaction data.	権限を持たない組織は、トランザクションデータの証拠としてチャネルの台帳上にプライベートデータのハッシュ値を保存するでしょう。
Also, for further privacy, hashes of the private data go through the Ordering-Service_, not the private data itself, so this keeps private data confidential from Orderer.	また、より高度な秘匿性のために、プライベートデータのハッシュはオーダリングサービス (Ordering-Service_) を経由しますが、プライベートデータそのものは経由しないようにしています。これによりordererからもデータの機密性が守られます。
Private Data Collection	Private Data Collection (プライベートデータコレクション、または単にコレクション)
Used to manage confidential data that two or more organizations on a channel want to keep private from other organizations on that channel.	プライベートデータコレクションは、チャネル上の2つ以上の組織が、それ以外の組織から秘匿したいデータを管理するために使用されます。
The collection definition describes a subset of organizations on a channel entitled to store a set of private data.	コレクション定義は、プライベートデータを保存する権限が与えられたチャネル上の組織のサブセットを記述します。
which by extension implies that only these organizations can transact with the private data.	これは、突き詰めると、これらの組織のみが当該プライベートデータを用いたトランザクションを実行できることを意味します。
Proposal	Proposal (提案)
A request for endorsement that is aimed at specific peers on a channel.	提案はチャネル上の特定のピアに対して送信されるエンドース処理の要求を意味します。
Each proposal is either an Init or an Invoke (read/write) request.	各提案は、InitまたはInvoke (読み込み/書き込み) の要求です。
A query is a chaincode invocation which reads the ledger current state but does not write to the ledger.	Queryは、台帳の現在の状態を読み込むが、台帳には書き込まれないチェーンコード呼出しです。
The chaincode function may query certain keys on the ledger, or may query for a set of keys on the ledger.	このチェーンコード関数は、台帳の特定のキーを問い合せることも、キーのセットを指定して問い合せることもできます。
Since queries do not change ledger state, the client application will typically not submit these read-only transactions for ordering, validation, and commit.	Queryによって台帳の状態が変更されることはないため、クライアントアプリケーションは通常、順序付け、検証およびコミットのために読み込み専用のトランザクションを発行しません。
Although not typical, the client application can choose to submit the read-only transaction for ordering, validation, and commit, for example if the client wants auditable proof on the ledger chain that it had knowledge of specific ledger state at a certain point in time.	一般的ではありませんが、クライアントアプリケーションは、たとえば、クライアントが特定の時点で特定の台帳状態を認識していたことを台帳チェーンに監査可能な証拠として残したい場合に、順序付け、検証およびコミットのために読み込み専用トランザクションを発行するように選択することもできます。
Quorum	Quorum (定足数)
This describes the minimum number of members of the cluster that need to affirm a proposal so that transactions can be ordered.	定足数はトランザクションが順序付けされるために必要な、提案をエンドースするメンバー数の最低値を意味します。
For every consenter set, this is a majority of nodes.	全ての同意者セットについて、これはノードの 過半数 を意味します。
In a cluster with five nodes, three must be available for there to be a quorum.	5ノードのクラスタでは、定足数を満たすには3ノードが必要です。
If a quorum of nodes is unavailable for any reason, the cluster becomes unavailable for both read and write operations and no new logs can be committed.	なんらかの理由でノードが定足数を満たさない場合、クラスタは読み込みも書き込みもできず、新しいログをコミットすることができません。
Raft	Raft
New for v1.4.1, Raft is a crash fault tolerant (CFT) ordering service implementation based on the `etcd library <https://coreos.com/etcd/>`_ of the `Raft protocol <https://raft.github.io/raft.pdf>`_.	v1.4.1の新機能であるRaftはクラッシュ故障耐性 (CTF) を持ったオーダリングサービスの実装で、`Raft プロトコル <https://raft.github.io/raft.pdf>`_ の `etcd ライブラリ <https://coreos.com/etcd/>`_ に基づいています。
Raft follows a "leader and follower" model, where a leader node is elected (per channel) and its decisions are replicated by the followers.	Raftは「リーダー・フォロワ」モデルに従っており、チャネルごとにリーダーノードを選出し、リーダーの決定がフォロワに複製されます。
Raft ordering services should be easier to set up and manage than Kafka-based ordering services, and their design allows organizations to contribute nodes to a distributed ordering service.	Raftオーダリングサービスは、Kafkaベースのオーダリングサービスよりもセットアップや管理が容易で、その設計により組織は分散されたオーダリングサービスにノードを提供できるようになっています。
Software Development Kit (SDK)	Software Development Kit (SDK)
The Hyperledger Fabric client SDK provides a structured environment of libraries for developers to write and test chaincode applications.	Hyperledger FabricのクライアントSDKは、開発者がチェーンコードアプリケーションを作成およびテストするための構造化されたライブラリ環境を提供します。
The SDK is fully configurable and extensible through a standard interface.	SDKは、標準インターフェイスを通じて完全に設定可能であり、拡張可能です。
Components, including cryptographic algorithms for signatures, logging frameworks and state stores, are easily swapped in and out of the SDK.	署名のための暗号アルゴリズム、ログフレームワーク、状態保存のためのコンポーネントは、SDKに簡単に出し入れできます。
The SDK provides APIs for transaction processing, membership services, node traversal and event handling.	SDKは、トランザクション処理、メンバーシップサービス、ノードトラバーサル、およびイベント処理のためのAPIを提供します。
Currently, the two officially supported SDKs are for Node.js and Java, while two more -- Python and Go -- are not yet official but can still be downloaded and tested.	現在、公式にサポートされているSDKはNode.js用とJava用の2つです。さらに2つ (PythonとGo) のSDKはまだ正式版ではありませんが、ダウンロードしてテストすることは可能です。
Smart Contract	Smart Contract (スマートコントラクト)
A smart contract is code -- invoked by a client application external to the blockchain network -- that manages access and modifications to a set of key-value pairs in the :ref:`World-State` via :ref:`Transaction`.	スマートコントラクトは、ブロックチェーンネットワークの外部にあるクライアントアプリケーションによって呼び出され、 :ref:`トランザクション<Transaction>` を通して :ref:`ワールドステート<World-State>` 内のキーバリューペアのセットへのアクセスや更新を管理するコードです。
In Hyperledger Fabric, smart contracts are packaged as chaincode.	Hyperledger Fabricでは、スマートコントラクトはチェーンコードとしてパッケージ化されます。
Chaincode is installed on peers and then defined and used on one or more channels.	チェーンコードはピアにインストールされ、1つまたは複数のチャネルで定義および使用されます。
State Database	State Database (ステートデータベース)
World state data is stored in a state database for efficient reads and queries from chaincode.	ワールドステートのデータは、チェーンコードからの読み込みやクエリに効率よく対処するために、ステートデータベースに格納されます。
Supported databases include levelDB and couchDB.	サポートされているデータベースは、levelDBとcouchDBです。
System Chain	System Chain (システムチェーン)
Contains a configuration block defining the network at a system level.	システムチェーンはシステムレベルでネットワークを定義するコンフィギュレーションブロックを含んでいます。
The system chain lives within the ordering service, and similar to a channel, has an initial configuration containing information such as: MSP information, policies, and configuration details.	システムチェーンはオーダリングサービス内に存在し、チャネルと同様に、次のような情報を含む初期設定を持ちます: MSP情報、ポリシー、および構成の詳細。
Any change to the overall network (e.g. a new org joining or a new ordering node being added) will result in a new configuration block being added to the system chain.	ネットワーク全体に変更があると (たとえば、新しい組織の参加や新しいオーダリングノードの追加など)、システムチェーンに新しいコンフィギュレーションブロックが追加されます。
The system chain can be thought of as the common binding for a channel or group of channels.	システムチェーンは、チャネルまたはチャネルのグループに対する共通のバインディングと考えることができます。
For instance, a collection of financial institutions may form a consortium (represented through the system chain), and then proceed to create channels relative to their aligned and varying business agendas.	たとえば、複数の金融機関が (システムチェーンを通じて代表される) コンソーシアムを形成し、その後、時々刻々変化する提携ビジネスのアジェンダに対するチャネルを作成することができます。
Transaction	Transaction (トランザクション)
A transaction, 'T'	トランザクション 'T'
Transactions are created when a chaincode is invoked from a client application to read or write data from the ledger.	トランザクションは、チェーンコードがクライアントアプリケーションから呼び出され、台帳上のデータに対して読み込みまたは書き込みを行うときに作成されます。
Fabric application clients submit transaction proposals to endorsing peers for execution and endorsement, gather the signed (endorsed) responses from those endorsing peers, and then package the results and endorsements into a transaction that is submitted to the ordering service.	Fabricのアプリケーションクライアントは、トランザクション提案をエンドースピアに送信してトランザクションの実行およびエンドース処理を求め、エンドースピアから署名 (エンドース) された応答を収集し、トランザクション結果とエンドースメントをトランザクションにパッケージ化して、オーダリングサービスに送信します。
The ordering service orders and places transactions in a block that is broadcast to the peers which validate and commit the transactions to the ledger and update world state.	オーダリングサービスは、トランザクションを順序付けしてブロックに配置し、ブロックをピアにブロードキャストします。ピアはブロック内をトランザクションを検証し、正当なトランザクションの結果を台帳にコミットし、ワールドステートを更新します。
World State	World State (ワールドステート)
The World State, 'W'	ワールドステート 'W'
Also known as the “current state”, the world state is a component of the HyperLedger Fabric :ref:`Ledger`.	ワールドステートはHyperledger Fabricの :ref:`台帳<Ledger>` の「現在の状態」を表すコンポーネントです。
The world state represents the latest values for all keys included in the chain transaction log.	ワールドステートはチェーンのトランザクションログに含まれる全てのキーに対する最新の値を表します。
Chaincode executes transaction proposals against world state data	チェーンコードはワールドステートに対してトランザクション提案を処理します。
because the world state provides direct access to the latest value of these keys rather than having to calculate them by traversing the entire transaction log.	なぜなら、ワールドステートにより、トランザクションログ全体を走査して計算しなくとも、各キーに対する最新の値に直接アクセスすることができるためです。
The world state will change every time the value of a key changes	ワールドステートはあるキーの値が変化すると毎回変化します。
for example, when the ownership of a car -- the "key" -- is transferred from one owner to another -- the "value") or when a new key is added (a car is created.	例えば、車の所有者 (キー)がある所有者から別の所有者 (値) に移転したときや、新しいキーが追加されたときなどです。
As a result, the world state is critical to a transaction flow, since the current state of a key-value pair must be known before it can be changed.	その結果、ワールドステートは、キーと値のペアは変更される前にその現在状態を知る必要があるため、トランザクションフローにおいて重要な役割を持ちます。
Peers commit the latest values to the ledger world state for each valid transaction included in a processed block.	ピアは処理したブロックに含まれる正しいトランザクションのそれぞれについて、最新の値を台帳とワールドステートにコミットします。
.. note:: Please make sure you are looking at the documentation that matches the version of the software you are using.	.. note:: 使用しているソフトウェアのバージョンと一致するドキュメントを参照していることを確認してください。
See the version label at the top of the navigation panel on the left.	左側のナビゲーションパネルの上部にあるバージョンラベルを参照してください。
You can change it using selector at the bottom of that navigation panel.	ナビゲーションパネルの下部にあるセレクタを使用して変更できます。
Enterprise grade permissioned distributed ledger platform that offers modularity and versatility for a broad set of industry use cases.	幅広い業界ユースケースに対してモジュール性と汎用性を提供する、エンタープライズクラスの許可型の分散台帳プラットフォームです。
.. note:: If you have questions not addressed by this documentation, or run into issues with any of the tutorials, please visit the :doc:`questions` page for some tips on where to find additional help.	.. note:: このマニュアルで対処されていない質問がある場合、またはチュートリアルのいずれかで問題が発生した場合は、 :doc:`questions` ページにアクセスして、さらに役に立ちそうなヒントを参照してください。
We welcome contributions to Hyperledger in many forms, and there's always plenty to do!	私たちは、Hyperledgerへのさまざまな形での貢献を歓迎しています。
First things first, please review the Hyperledger `Code of Conduct <https://wiki.hyperledger.org/community/hyperledger-project-code-of-conduct>`__ before participating.	まず最初に、Hyperledger `Code of Conduct <https://wiki.hyperledger.org/community/hyperledger-project-code-of-conduct>`__を確認してから参加してください。
It is important that we keep things civil.	私たちは物事を市民的なものに保つことが重要です。
.. note:: If you want to contribute to this documentation, please check out the :doc:`style_guide`.	.. note:: このドキュメントに貢献したい方は、 :doc:`style_guide` をご覧ください。
There are many ways you can contribute to Hyperledger Fabric, both as a user and as a developer.	ユーザーとしても開発者としても、Hyperledger Fabricに貢献できる方法はたくさんあります。
As a user: - `Making Feature/Enhancement Proposals`_ - `Reporting bugs`_ - Help test an upcoming Epic on the `release roadmap <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`_.	ユーザーとして:- `release roadmap <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`_ 上にある近日公開予定のEpicのテストを手伝う。
Contact the Epic assignee via the Jira work item or on `RocketChat <https://chat.hyperledger.org>`_.	Jiraの作業項目か `RocketChat <https://chat.hyperledger.org>`_ でEpicの担当者にコンタクトしてください。
As a writer or information developer: - Update the documentation using your experience of Fabric and this documentation to improve existing topics and create new ones.	ライターまたはインフォメーション・デベロッパーとして:- あなたのFabricの経験とこのドキュメントを使用して、既存のトピックを改善したり、新規トピックを作成するなど、このドキュメントを更新します。
A documentation change is an easy way to get started as a contributor, makes it easier for other users to understand and use Fabric, and grows your open source commit history.	ドキュメントの変更は、コントリビュータとして作業を開始する簡単な方法であり、他のユーザーがFabricを理解して使用するのを容易にし、オープンソースのコミット実績を増やします。
Participate in a language translation to keep the Fabric documentation current in your chosen language.	言語翻訳作業に参加して、選択した言語でFabricドキュメントを最新の状態に保ちます。
The Fabric documentation is available in a number of languages -- English, Chinese, Malayalam and Brazilian Portuguese -- 	Fabricのドキュメントは、英語、中国語、マラヤーラム語、ポルトガル語(ブラジル)など、さまざまな言語で提供されています。
so why not join a team that keeps your favorite documentation up-to-date?	お気に入りのドキュメントを最新の状態に保つチームに参加してみてはいかがでしょうか。
You'll find a friendly community of users, writers and developers to collaborate with.	ユーザー、ライター、および開発者が集まり、共同作業を行うための友好的なコミュニティーがあります。
Start a new language translation if the Fabric documentation isn't available in your language.	使用している言語でFabricのドキュメントがない場合は、新しい言語への翻訳を開始します。
The Chinese, Malayalam and Portuguese Brazilian teams got started this way, and you can too!	中国チーム、マラヤーラムチーム、ポルトガル系ブラジルチームはこの方法でスタートしました。あなたにもできます。
It's more work, as you'll have to form a community of writers, and organize contributions; but it's really fulfilling to see the Fabric documentation available in your chosen language.	ライターのコミュニティを形成したり、貢献をまとめる必要があるため、作業量は多くなりますが、使用している言語でFabricのドキュメントを利用できることは非常に嬉しいことです。
Jump to `Contributing documentation`_ to get started on your journey.	`Contributing documentation`_ にアクセスして、貢献活動を始めてください。
As a developer: - If you only have a little time, consider picking up a `"help-wanted" <https://jira.hyperledger.org/issues/?filter=10147>`_ task, see `Fixing issues and working stories`_.	開発者として:- 時間が少ししかない場合は、`"help-wanted" <https://jira.hyperledger.org/issues/?filter=10147>`_ にあるタスクを選択することを検討するか、もしくは `Fixing issues and working stories`_ を参照してください。
If you can commit to full-time development, either propose a new feature (see `Making Feature/Enhancement Proposals`_) and bring a team to implement it, or join one of the teams working on an existing Epic.	フルタイムで開発を行うことができるのであれば、新しい機能を提案して(`Making Feature/Enhancement Proposals`_ を参照してください)それを実装するチームを作るか、あるいは既にEpicで作業しているチームの1つに参加します。
If you see an Epic that interests you on the `release roadmap <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`_, contact the Epic assignee via the Jira work item or on `RocketChat <https://chat.hyperledger.org/>`__.	`release roadmap <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`_ で興味のあるEpicを見つけたら、Jiraの作業項目か、`RocketChat <https://chat.hyperledger.org/>`__ でEpicの担当者に連絡してください。
In order to participate in the development of the Hyperledger Fabric project, you will need a Linux Foundation account.	Hyperledger Fabricプロジェクトの開発に参加するには、Linux Foundationアカウントが必要です。
Once you have a LF ID you will be able to access all the Hyperledger community tools, including `Jira issue management <https://jira.hyperledger.org>`__, `RocketChat <https://chat.hyperledger.org/>`__, and the `Wiki <https://wiki.hyperledger.org/display/fabric/Hyperledger+Fabric>`__ (for editing, only).	LF IDを取得すると、`Jira issue management <https://jira.hyperledger.org>`__ 、`RocketChat <https://chat.hyperledger.org/>`__ 、`Wiki <https://wiki.hyperledger.org/display/fabric/Hyperledger+Fabric>`__ （編集専用）など、すべてのHyperledgerコミュニティツールにアクセスできるようになります。
Follow the steps below to create a Linux Foundation account if you don't already have one.	Linux Foundationアカウントがない場合は、次の手順に従って作成します。
1. Go to the `Linux Foundation ID website <https://identity.linuxfoundation.org/>`__.	1. `Linux Foundation IDのwebsite <https://identity.linuxfoundation.org/>`__ にアクセスします。
2. Select the option ``I need to create a Linux Foundation ID``, and fill out the form that appears.	2. ``I need to create a Linux Foundation ID`` オプションを選択し、表示されるフォームに入力します。
3. Wait a few minutes, then look for an email message with the subject line: "Validate your Linux Foundation ID email".	3. 数分待ってから、"Validate your Linux Foundation ID email" という件名の電子メールメッセージを探します。
4. Open the received URL to validate your email address.	4. 受信したURLを開いて、電子メールアドレスを検証します。
5. Verify that your browser displays the message ``You have successfully validated your e-mail address``.	5. ブラウザに ``You have successfully validated your e-mail address`` というメッセージが表示されていることを確認します。
6. Access `Jira issue management <https://jira.hyperledger.org>`__, or `RocketChat <https://chat.hyperledger.org/>`__.	6. `Jira issue management <https://jira.hyperledger.org>`__ 、または`RocketChat <https://chat.hyperledger.org/>`__ にアクセスします。
It's a good idea to make your first change a documentation change.	最初の変更をドキュメントの変更にすることをお勧めします。
It's quick and easy to do, ensures that you have a correctly configured machine, (including the required pre-requisite software), and gets you familiar with the contribution process.	これは迅速かつ簡単に行うことができ、適切に構成されたマシン(必要な事前要件ソフトウェアを含む)があることを確認しつつ、貢献のプロセスに慣れることができます。
Use the following topics to help you get started:	以下のトピックを参照してください。
Hyperledger Fabric is managed under an open governance model as described in our `charter <https://www.hyperledger.org/about/charter>`__.	Hyperledger Fabricは、我々の `charter <https://www.hyperledger.org/about/charter>`__ に記述されているように、オープンなガバナンスモデルの下で管理されています。
Projects and sub-projects are lead by a set of maintainers.	プロジェクトとサブプロジェクトは、メンテナのグループによりリードされています。
New sub-projects can designate an initial set of maintainers that will be approved by the top-level project's existing maintainers when the project is first approved.	新規サブプロジェクトは、最初のメンテナグループが指名でき、このメンテナグループはそのプロジェクトが最初に承認されるときに、最上位レベルのプロジェクトの既存のメンテナによって承認されます。
The Fabric project is lead by the project's top level `maintainers <https://github.com/hyperledger/fabric/blob/master/MAINTAINERS.md>`__.	Fabricプロジェクトは、プロジェクトのトップレベルの `maintainers <https://github.com/hyperledger/fabric/blob/master/MAINTAINERS.md>`__ によってリードされています。
The maintainers are responsible for reviewing and merging all patches submitted for review, and they guide the overall technical direction of the project within the guidelines established by the Hyperledger Technical Steering Committee (TSC).	メンテナは、レビューのために提出されたすべてのパッチをレビューしてマージする責任があり、Hyperledger Technical Steering Committee(TSC)によって確立されたガイドラインの範囲内でプロジェクトの全体的な技術的方向性をガイドします。
The project's maintainers will, from time-to-time, consider adding a maintainer, based on the following criteria:.	プロジェクトのメンテナは、以下の基準に基づいて、時々メンテナを追加することを検討します。
Demonstrated track record of PR reviews (both quality and quantity of reviews)	PRレビューの実績（レビューの質と量の両方）
Demonstrated thought leadership in the project	プロジェクトにおける思想的リーダーシップの実証
Demonstrated shepherding of project work and contributors	プロジェクトの作業とコントリビュータの主導・管理の実績
An existing maintainer can submit a pull request to the `maintainers <https://github.com/hyperledger/fabric/blob/master/MAINTAINERS.md>`__ file	既存のメンテナは、プルリクエストを `maintainers <https://github.com/hyperledger/fabric/blob/master/MAINTAINERS.md>`__ fileにサブミットできます。
A nominated Contributor may become a Maintainer by a majority approval of the proposal by the existing Maintainers.	指名されたコントリビューターは、既存のメンテナによる提案の過半数の承認によってメンテナになることができます。
Once approved, the change set is then merged and the individual is added to the maintainers group.	承認されると、変更がマージされ、メンテナグループに追加されます。
Maintainers may be removed by explicit resignation, for prolonged inactivity (e.g. 3 or more months with no review comments), or for some infraction of the `code of conduct <https://wiki.hyperledger.org/community/hyperledger-project-code-of-conduct>`__ or by consistently demonstrating poor judgement.	メンテナは、明示的な辞任、長期間の活動停止(例えば、レビューコメントを更新せずに3ヶ月以上経過する)、`code of conduct <https://wiki.hyperledger.org/community/hyperledger-project-code-of-conduct>`__ の違反、または一貫して不十分な判断を示すことによって、解任されることがあります。
A proposed removal also requires a majority approval.	解任の提案についても、過半数の承認が必要です。
A maintainer removed for inactivity should be restored following a sustained resumption of contributions and reviews (a month or more) demonstrating a renewed commitment to the project.	活動がなかったために解任されたメンテナは、プロジェクトへの新たなコミットメントを示す貢献とレビューの継続的な再開(1ヶ月以上)の後、メンテナに復帰することができます。
The Fabric maintainers have settled on a quarterly (approximately) release cadence (see `releases <https://github.com/hyperledger/fabric#releases>`__).	Fabricのメンテナは、おおよそ四半期ごとのリリース周期を決めています。 (`releases <https://github.com/hyperledger/fabric#releases>`__ を参照してください)
At any given time, there will be a stable LTS (long term support) release branch, as well as the master branch for upcoming new features.	どの時点でも、安定したLTS(長期サポート)リリースブランチと、今後の新機能のマスターブランチがあります。
Follow the discussion on the #fabric-release channel in RocketChat.	RocketChatの#fabric-releaseチャネルのディスカッション内容を確認してください。
First, take time to review `JIRA <https://jira.hyperledger.org/issues/?filter=12524>`__ to be sure that there isn't already an open (or recently closed) proposal for the same function.	最初に `JIRA <https://jira.hyperledger.org/issues/?filter=12524>`__ を見て、同じ機能に対してまだオープンな(あるいは最近クローズされた)提案がないことを確認します。
If there isn't, to make a proposal we recommend that you open a JIRA Epic or Story, whichever seems to best fit the circumstance and link or inline a "one pager" of the proposal that states what the feature would do and, if possible, how it might be implemented.	もしなければ、JIRA EpicかStoryのどちらか、状況に最も適していると思われる方を開いて、その機能が何をするのか、そして可能であればどのように実装されるのかを示す、提案の\"１ページもの資料\"をリンクするかインライン化することをお勧めします。
It would help also to make a case for why the feature should be added, such as identifying specific use case(s) for which the feature is needed and a case for what the benefit would be should the feature be implemented.	また、その機能が必要とされる特定のユースケースや、その機能が実装された場合にどのようなメリットがあるかなど、その機能を追加すべき理由を説明するのにも役立ちます。
Once the JIRA issue is created, and the "one pager" either attached, inlined in the description field, or a link to a publicly accessible document is added to the description, send an introductory email to the fabric@lists.hyperledger.org mailing list linking the JIRA issue, and soliciting feedback.	JIRAのissueが作成され、\"１ページもの資料\"が添付されているか、説明フィールドにインライン化されているか、公開されているドキュメントへのリンクが説明に追加されたら、JIRA issueにリンクしている fabric@lists.hyperledger.org メーリングリストに紹介メールを送り、フィードバックを求めます。
Discussion of the proposed feature should be conducted in the JIRA issue itself, so that we have a consistent pattern within our community as to where to find design discussion.	提案された機能の議論は、JIRAのissueそのものの中で行われるべきであり、それによって私たちは、デザインの議論をどこで見つけるかについて、コミュニティの中で一貫したパターンを持つことができます。
Getting the support of three or more of the Hyperledger Fabric maintainers for the new feature will greatly enhance the probability that the feature's related PRs will be included in a subsequent release.	3人以上のHyperledger Fabricメンテナから新機能のサポートを受けることで、この機能に関連するPRが今後のリリースに含まれる可能性が大きく高まります。
The maintainers hold regular contributors meetings.	メンテナは定期的にコントリビュータミーティングを行います。
The purpose of the contributors meeting is to plan for and review the progress of releases and contributions, and to discuss the technical and operational direction of the project and sub-projects.	コントリビュータミーティングの目的は、リリースとコントリビュータの進捗を計画し、レビューし、プロジェクトとサブプロジェクトの技術的および運用上の方向性を議論することです。
Please see the `wiki <https://wiki.hyperledger.org/display/fabric/Contributor+Meetings>`__ for maintainer meeting details.	メンテナミーティングの詳細については、`wiki <https://wiki.hyperledger.org/display/fabric/Contributor+Meetings>`__ を参照してください。
New feature/enhancement proposals as described above should be presented to a maintainers meeting for consideration, feedback and acceptance.	上記のような新機能/機能拡張の提案は、検討、フィードバック、承認のためにメンテナミーティングに提出されるべきです。
The Fabric release roadmap of epics is maintained in `JIRA <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`__.	EpicのFabricリリースロードマップは `JIRA <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`__ で管理されています。
We use `RocketChat <https://chat.hyperledger.org/>`__ for communication and Google Hangouts™ for screen sharing between developers.	コミュニケーションには `RocketChat <https://chat.hyperledger.org/>`__ を、開発者間の画面共有にはGoogle Hangouts™を使用します。
Our development planning and prioritization is done in `JIRA <https://jira.hyperledger.org>`__, and we take longer running discussions/decisions to the `mailing list <https://lists.hyperledger.org/mailman/listinfo/hyperledger-fabric>`__.	私たちの開発計画と優先順位付けは `JIRA <https://jira.hyperledger.org>`__ で行われ、 `mailing list <https://lists.hyperledger.org/mailman/listinfo/hyperledger-fabric>`__ に対して、より長い時間をかけて議論や決定を行います。
Before we begin, if you haven't already done so, you may wish to check that you have all the :doc:`prerequisites <prereqs>` installed on the platform(s) on which you'll be developing blockchain applications and/or operating Hyperledger Fabric.	最初に、まだ行っていない場合は、ブロックチェーンアプリケーションの開発やHyperledger Fabricのオペレーションを行うプラットフォームに:doc:`prerequisites <prereqs>` が全てインストールされていることを確認してください。
If you are looking for something to work on, or need some expert assistance in debugging a problem or working out a fix to an issue, our `community <https://www.hyperledger.org/community>`__ is always eager to help.	何か取り組むものを探していたり、問題をデバッグしたり問題の修正をしたりするのに専門家の助けが必要なとき、私たちの`community <https://www.hyperledger.org/community>`__ はいつでも助けたいと思っています。
We hang out on `Chat <https://chat.hyperledger.org/channel/fabric/>`__, IRC (#hyperledger on freenode.net) and the `mailing lists <https://lists.hyperledger.org/>`__.	私たちは、 `Chat <https://chat.hyperledger.org/channel/fabric/>`__ 、IRC（freenode.netの#hyperledger）、および `mailing lists <https://lists.hyperledger.org/>`__ に参加しています。
Most of us don't bite :grin: and will be glad to help.	ほとんどの人は噛みついたりせず喜んで助けます。
The only silly question is the one you don't ask.	ばかげた質問などありません。
Questions are in fact a great way to help improve the project as they highlight where our documentation could be clearer.	実際、質問は、私たちのドキュメントがより明確になる可能性がある場所を強調するので、プロジェクトを改善するのに役立ちます。
If you are a user and you have found a bug, please submit an issue using `JIRA <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`__.	あなたがユーザーで、バグを見つけたら、 `JIRA <https://jira.hyperledger.org/secure/Dashboard.jspa?selectPageId=10104>`__ を使って問題を報告してください。
Before you create a new JIRA issue, please try to search the existing items to be sure no one else has previously reported it.	新しいJIRA issueを作成する前に、既存のアイテムを検索して、他の誰もそれを報告していないことを確認してください。
If it has been previously reported, then you might add a comment that you also are interested in seeing the defect fixed.	以前に報告されたことがある場合は、不具合の修正を確認したいというコメントを追加できます。
.. note:: If the defect is security-related, please follow the Hyperledger   `security bug reporting process <https://wiki.hyperledger.org/display/HYP/Defect+Response>`__.	.. note:: 不具合がセキュリティ関連の場合は、       `security bug reporting process <https://wiki.hyperledger.org/display/HYP/Defect+Response>`__ に従ってください。
If it has not been previously reported, you may either submit a PR with a well documented commit message describing the defect and the fix, or you may create a new JIRA.	これまでに報告されていない場合は、不具合と修正を記述した文書化されたコミットメッセージとともにPRを提出するか、新しいJIRAを作成することができます。
Please try to provide sufficient information for someone else to reproduce the issue.	他のユーザーが問題を再現できるだけの十分な情報を提供してください。
One of the project's maintainers should respond to your issue within 24 hours.	プロジェクトのメンテナが24時間以内にあなたの問題に対応します。
If not, please bump the issue with a comment and request that it be reviewed.	そうでない場合は、問題にコメントを付けてレビューを依頼してください。
You can also post to the relevant Hyperledger Fabric channel in `Hyperledger Chat <https://chat.hyperledger.org>`__.	`Hyperledger Chat <https://chat.hyperledger.org>`__ では、関連するHyperledger Fabricチャネルに投稿することもできます。
For example, a doc bug should be broadcast to ``#fabric-documentation``, a database bug to ``#fabric-ledger``, and so on...	例えば、ドキュメントのバグは ``#fabric-documentation`` に、データベースのバグは ``#fabric-ledger`` にブロードキャストされるべきです。
If you just submitted a JIRA for a bug you've discovered, and would like to provide a fix, we would welcome that gladly!	バグの発見をJIRAで報告して、修正を提供したいのであれば、喜んで歓迎します。
Please assign the JIRA issue to yourself, then submit a pull request (PR).	JIRAのissueを自分に割り当て、プルリクエスト(PR)を提出してください
Please refer to :doc:`github/github` for a detailed workflow.	詳細なワークフローについては、 :doc:`github/github` を参照してください。
Review the `issues list <https://jira.hyperledger.org/issues/?filter=10580>`__ and find something that interests you.	`issues list <https://jira.hyperledger.org/issues/?filter=10580>`__ を見て、興味のあるものを見つけてください。
You could also check the `"help-wanted" <https://jira.hyperledger.org/issues/?filter=10147>`__ list.	`"help-wanted" <https://jira.hyperledger.org/issues/?filter=10147>`__ も確認してください。
It is wise to start with something relatively straight forward and achievable, and that no one is already assigned.	比較的単純で達成可能なもので、誰もアサインされていないものから始めるのが賢明です。
If no one is assigned, then assign the issue to yourself.	誰もアサインされていない場合は、issueに自分をアサインします。
Please be considerate and rescind the assignment if you cannot finish in a reasonable time, or add a comment saying that you are still actively working the issue if you need a little more time.	適切な時間内に終了できない場合は、慎重に検討し、割り当てを取り消してください。また、もう少し時間が必要な場合は、まだ問題に取り組んでいるというコメントを追加してください。
Another way to contribute and learn about Hyperledger Fabric is to help the maintainers with the review of the PRs that are open.	Hyperledger Fabricに貢献し、Hyperledger Fabricについて学ぶためのもう1つの方法は、オープンなPRのレビューを行うことで、メンテナを支援することです。
Indeed maintainers have the difficult role of having to review all the PRs that are being submitted and evaluate whether they should be merged or not.	実際、メンテナには、提出されるすべてのPRをレビューし、それらをマージすべきかどうかを評価するという難しい役割があります。
You can review the code and/or documentation changes, test the changes, and tell the submitters and maintainers what you think.	コードやドキュメントの変更をレビューしたり、変更をテストしたり、サブミッタやメンテナに自分の考えを伝えることができます。
Once your review and/or test is complete just reply to the PR with your findings, by adding comments and/or voting.	レビューおよび/またはテストが完了したら、コメントおよび/または投票を追加して、結果をPRに返信するだけです。
A comment saying something like "I tried it on system X and it works" or possibly "I got an error on system X: xxx " will help the maintainers in their evaluation.	「システムXで試してみましたが、動作しました」または「システムXでエラーが発生しました:xxx」などのコメントは、メンテナの評価に役立ちます。
As a result, maintainers will be able to process PRs faster and everybody will gain from it.	その結果、メンテナンス担当者はPRをより迅速に処理できるようになり、誰もがそれから利益を得ることができます。
Just browse through `the open PRs on GitHub <https://github.com/hyperledger/fabric/pulls>`__ to get started.	まずは `the open PRs on GitHub <https://github.com/hyperledger/fabric/pulls>`__ を参照してください。
As the Fabric project has grown, so too has the backlog of open PRs.	Fabricプロジェクトが成長するにつれて、オープンPRのバックログも増加しています。
One problem that nearly all projects face is effectively managing that backlog and Fabric is no exception.	ほとんどのプロジェクトが直面している問題の1つは、バックログを効果的に管理することで、Fabricも例外ではありません。
In an effort to keep the backlog of Fabric and related project PRs manageable, we are introducing an aging policy which will be enforced by bots.	Fabricと関連プロジェクトのPRのバックログを管理可能にするために、ボットによって実施されるエージングポリシーを導入しています。
This is consistent with how other large projects manage their PR backlog.	これは、他の大規模プロジェクトがPRバックログを管理する方法と同様です。
The Fabric project maintainers will automatically monitor all PR activity for delinquency.	Fabricプロジェクトのメンテナは、延滞に関するすべてのPR活動を自動的に監視します。
If a PR has not been updated in 2 weeks, a reminder comment will be added requesting that the PR either be updated to address any outstanding comments or abandoned if it is to be withdrawn.	PRが2週間更新されていない場合は、PRを更新して未解決のコメントに対処するか、またはPRが撤回されるべき場合は破棄するかのいずれかを求める注意喚起コメントが追加されます。
If a delinquent PR goes another 2 weeks without an update, it will be automatically abandoned.	延滞PRが更新されずにさらに2週間経過すると、自動的に破棄されます。
If a PR has aged more than 2 months since it was originally submitted, even if it has activity, it will be flagged for maintainer review.	PRが最初に送信されてから2か月以上経過している場合は、アクティビティがあっても、メンテナレビュー用にフラグが付けられます。
If a submitted PR has passed all validation but has not been reviewed in 72 hours (3 days), it will be flagged to the #fabric-pr-review channel daily until it receives a review comment(s).	提出されたPRがすべての検証に合格したが、72時間(3日間)の間にレビューされなかった場合、レビューコメントを受け取るまで、毎日#fabric-pr-reviewチャネルに通知されます。
This policy applies to all official Fabric projects (fabric, fabric-ca, fabric-samples, fabric-test, fabric-sdk-node, fabric-sdk-java, fabric-gateway-java, fabric-chaincode-node, fabric-chaincode-java, fabric-chaincode-evm, fabric-baseimage, and fabric-amcl).	このポリシーは、すべての公式Fabricプロジェクト(fabric、fabric-ca、fabric-samples、fabric-test、fabric-sdk-node、fabric-sdk-java、fabric-gateway-java、fabric-chaincode-node、fabric-chaincode-java、fabric-chaincode-evm、fabric-baseimage、およびfabric-amcl)に適用されます。
Next, try :doc:`building the project <dev-setup/build>` in your local development environment to ensure that everything is set up correctly.	次に、ローカルの開発環境で :doc:`building the project <dev-setup/build>` を行って、すべてが正しくセットアップされていることを確認します。
One change at a time.	一度に1つの変更にとどめてください。
Not five, not three, not ten.	3つ、5つ、あるいは10の変更をしないでください。
One and only one.	１つ、たった一つだけの変更にしてください。
Why? Because it limits the blast area of the change.	それにより、変更箇所を制限できるからです。
If we have a regression, it is much easier to identify the culprit commit than if we have some composite change that impacts more of the code.	リグレッションがあった場合、コードの大部分に影響を与える複合的な変更がある場合よりも、原因となるコミットを特定する方がはるかに容易です。
Include a link to the JIRA story for the change.	変更にJIRAストーリーへのリンクを含めてください。
Why? Because a) we want to track our velocity to better judge what we think we can deliver and when and b) because we can justify the change more effectively.	なぜなら、a)何をいつ提供できるかをより適切に判断するために、開発速度を追跡したいからです。また、b)より効果的に変更が適切であるか判断できるからです。
In many cases, there should be some discussion around a proposed change and we want to link back to that from the change itself.	多くの場合、提案された変更に関して何らかの話し合いが必要であり、話し合いからその変更にリンクしたいと考えています。
Include unit and integration tests (or changes to existing tests) with every change.	変更ごとに、単体テストと統合テスト(または既存のテストの変更)を含めてください。
This does not mean just happy path testing, either.	これは、単にハッピーパステストだけではありません。
It also means negative testing of any defensive code that it correctly catches input errors.	入力エラーを正しくキャッチするために、防御的プログラミングに対してネガティブテストすることも意味します。
When you write code, you are responsible to test it and provide the tests that demonstrate that your change does what it claims.	コードを作成するときには、コードをテストし、変更が要求どおりに行われていることを示すテストを提示する必要があります。
Why? Because without this we have no clue whether our current code base actually works.	これがなければ、現在のコードが実際に機能するかどうか見当がつきません。
Unit tests should have NO external dependencies.	単体テストには外部依存性を持たせないでください。
You should be able to run unit tests in place with ``go test`` or equivalent for the language.	``go test`` やその言語と同等のものを使って、単体テストを実行できます。
Any test that requires some external dependency (e.g. needs to be scripted to run another component) needs appropriate mocking.	何らかの外部依存性を必要とするテスト(例えば、別のコンポーネントを実行するためにスクリプト化する必要がある)には、適切なモックの作成が必要です。
Anything else is not unit testing, it is integration testing by definition.	それ以外はユニット・テストではなく、定義によれば統合テストです。
Why? Because many open source developers do Test Driven Development.	なぜなら、多くのオープンソース開発者がテスト駆動開発を行っているからです。
They place a watch on the directory that invokes the tests automagically as the code is changed.	コードが変更されると、自動的にテストを呼び出すウォッチをディレクトリに置きます。
This is far more efficient than having to run a whole build between code changes.	これは、コードを変更するたびにビルド全体を実行するよりもはるかに効率的です。
See `this definition <http://artofunittesting.com/definition-of-a-unit-test/>`__ of unit testing for a good set of criteria to keep in mind for writing effective unit tests.	効果的な単体テストを作成するために留意すべき適切な基準については、 `この単体テストの定義 <http://artofunittesting.com/definition-of-a-unit-test/>`__ を参照してください。
Minimize the lines of code per PR.	PRごとのコード行を最小限に抑えてください。
Why?	なぜか？
Maintainers have day jobs, too.	メンテナには本業もあります。
If you send a 1,000 or 2,000 LOC change, how long do you think it takes to review all of that code? Keep your changes to < 200-300 LOC, if possible.	1,000または2,000のLOCの変更を行った場合、すべてのコードを確認するのにどのくらいの時間がかかると思いますか。
If you have a larger change, decompose it into multiple independent changes.	可能な場合は、変更内容を200〜300LOC以下に抑えてください。大きな変更がある場合は、それを複数の変更に分割してください。
If you are adding a bunch of new functions to fulfill the requirements of a new capability, add them separately with their tests, and then write the code that uses them to deliver the capability.	新しい機能の要件を満たすために多くの新しい関数を追加する場合は、それらの関数をテストするとともに個別に追加してから、それらの関数を使用して機能を提供するコードを記述します。
Of course, there are always exceptions.	もちろん、例外はあります。
If you add a small change and then add 300 LOC of tests, you will be forgiven;-) 	例えば、小さな変更を加えてから300LOCのテストを加えた場合などは許可されます;-)。
If you need to make a change that has broad impact or a bunch of generated code (protobufs, etc.).	他に、例えば、広範な影響を与える変更や、大量の生成コード(プロトコルバッファーなど)が必要な場合などです。
Again, there can be exceptions.	ここでも例外があります。
.. note:: Large pull requests, e.g. those with more than 300 LOC are more than likely not going to receive an approval, and you'll be asked to refactor the change to conform with this guidance.	.. note:: 例えば、LOCが300を超えるような大規模なプルリクエストは、承認を得られない可能性が高く、このガイダンスに従って変更をリファクタリングするよう求められるでしょう。
Write a meaningful commit message.	意味のあるコミットメッセージを作成してください。
Include a meaningful 55 (or less) character title, followed by a blank line, followed by a more comprehensive description of the change.	意味のある55文字(またはそれ以下)のタイトル、空白行、変更のより包括的な説明を含めてください。
Each change MUST include the JIRA identifier corresponding to the change (e.g. [FAB-1234]).	各変更には、変更に対応するJIRA識別子(例えば[FAB-1234])を必ず含めなければなりません。
This can be in the title but should also be in the body of the commit message.	これはタイトルに含めることができますが、コミットメッセージの本文にも含めなければいけません。
.. note:: Example commit message: 	.. note:: コミットメッセージの例：
Finally, be responsive.	最後に、反応は素早く行ってください。
Don't let a pull request fester with review comments such that it gets to a point that it requires a rebase.	リベースが必要になるほどまで、レビューコメントのついたプルリクエストを放置してはなりません。
It only further delays getting it merged and adds more work for you - to remediate the merge conflicts.	そのリクエストがマージされるのがさらに遅れるだけで、マージの競合を修正するための作業が増えます。
**Note:** Each source file must include a license header for the Apache Software License 2.0.	**注意:** 各ソースファイルには、Apache Software License 2.0のライセンスヘッダーを含める必要があります。
See the template of the `license header <https://github.com/hyperledger/fabric/blob/master/docs/source/dev-setup/headers.txt>`__.	`license header <https://github.com/hyperledger/fabric/blob/master/docs/source/dev-setup/headers.txt>`__ のテンプレートを参照してください。
We have tried to make it as easy as possible to make contributions.	できるだけ貢献しやすいように努めています。
This applies to how we handle the legal aspects of contribution.	これは、私たちが貢献の法的側面をどのように扱うかに当てはまります。
We use the same approach—the `Developer's Certificate of Origin 1.1 (DCO) <https://github.com/hyperledger/fabric/blob/master/docs/source/DCO1.1.txt>`__—that the Linux® Kernel `community <https://elinux.org/Developer_Certificate_Of_Origin>`__ uses to manage code contributions.	Linux®、Linux®Kernel `community <https://elinux.org/Developer_Certificate_Of_Origin>`__ がコードの貢献を管理するために使用しているのと同じ方法 つまり `Developer's Certificate of Origin 1.1(DCO) <https://github.com/hyperledger/fabric/blob/master/docs/source/DCO1.1. txt>`__ を使用します。
We simply ask that when submitting a patch for review, the developer must include a sign-off statement in the commit message.	パッチをレビューのために提出する場合、開発者はコミットメッセージにsign-offステートメントを含める必要があります。
Here is an example Signed-off-by line, which indicates that the submitter accepts the DCO: 	次に、送信者がDCOを受け入れることを示すSigned-off-by行の例を示します。
You can include this automatically when you commit a change to your local git repository using ``git commit -s``.	ローカルのgitリポジトリに変更をコミットする際に ``git commit -s`` を使うことで、これを自動的に含めることができます。
Style guide for contributors	コントリビュータのためのスタイルガイド
**Audience**: documentation writers and editors	**対象読者**: ドキュメントの作成者と編集者
While this style guide will also refer to best practices using ReStructured Text (also known as RST), in general we advise writing documentation in Markdown, as it's a more universally accepted documentation standard.	このスタイルガイドでは、reStructuredText (RSTとも呼ばれます) を使用したベストプラクティスも参照しますが、一般的には、広く受け入れられているドキュメント標準であるMarkdownでドキュメントを書くことをお勧めします。
Both formats are usable, however, and if you decide to write a topic in RST (or are editing an RST topic), be sure to refer to this style guide.	ただし、どちらの形式も使用可能です。RSTでトピックを作成することにした場合 (またはRSTで書かれたトピックを編集する場合) は、必ずこのスタイルガイドを参照してください。
When in doubt, use the docs themselves for guidance on how to format things.	疑問がある場合は、フォーマットに関する手引きとしてドキュメントそのものを使用する
[For RST formatting](http://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html).	[RSTフォーマット](http://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html)
[For Markdown formatting](http://hyperledger-fabric.readthedocs.io/en/release-1.4/peers/peers.html).	[Markdownフォーマット](http://hyperledger-fabric.readthedocs.io/en/release-1.4/peers/peers.html)
If you just want to look at how things are formatted, you can navigate to the Fabric repo to look at the raw file by clicking on `Edit on Github` link in the upper right hand corner of the page.	フォーマットの方法を確認したいだけなら、ページ右上隅の `Edit on GitHub` リンクをクリックしてFabricリポジトリに移動し、
Then click the `Raw` tab.	次に `Raw` タブをクリックします。
This will show you the formatting of the doc.	これにより、ドキュメントのフォーマットが表示されます。
Do not attempt to edit the file on Github.	GitHub上でファイルを編集しないでください。 
If you want to make a change, clone the repo and follow the instructions in [Contributing](./CONTRIBUTING.html) for creating pull requests.	もし、ファイルに変更を加えたい場合には、リポジトリをクローンし、そして [Contributing](./CONTRIBUTING.html) のプルリクエストの作成方法に従ってください。
Word choices	言葉の選び方
Avoid the use of the words "whitelist", "blacklist", "master", or "slave".	「ホワイトリスト (whitelist) 」「ブラックリスト (blacklist) 」「マスター (master) 」「スレーブ (slave) 」などの単語の使用は避ける
Unless the use of these words is absolutely necessary (for example, when quoting a section of code that uses them), do not use these words.	これらの単語の使用が絶対に必要でない限り (例えば、これらの単語を使用しているコードのセクションを引用する場合)、これらの単語を使用しないでください。
Either be more explicit (for example, describing what "whitelisting" actually does) or find alternate words such as "allowlist" or "blocklist".	その単語をより明確にする (例えば、「ホワイトリスト化 (whitelisting) 」が実際に何をするものなのかを説明する) か、「許可リスト (allowlist) 」や「ブロックリスト (blocklist) 」のような代替語を見つけるかしてください。
Tutorials should have a list of steps at the top.	チュートリアルでは、ページのトップにステップのリストが必要
A list of steps (with links to the corresponding sections) at the beginning of a tutorial helps users find particular steps they're interested in.	チュートリアルの冒頭にステップのリスト (対応するセクションへのリンク付き) があると、ユーザーは興味のある特定のステップを見つけるのに役立ちます。
For an example, check out [Use private data in Fabric](./private-data/private-data.html).	例えば、 [Use private data in Fabric](./private-data/private-data.html) を確認してください。
Fabric, "Hyperledger Fabric" or "HLF"?	「Fabric」、「Hyperledger Fabric」それとも「HLF」？
The first usage should be “Hyperledger Fabric” and afterwards only “Fabric”.	最初は「Hyperledger Fabric」と記述し、その後は「Fabric」とのみ記述すべきです。「HLF」は使用しないでください。
Don't use "HLF" or "Hyperledger" by itself.	また、「Hyperledger」は単独では使わないでください。
Chaincode vs. Chaincodes?	Chaincode (単数形) vs. Chaincodes (複数形) ？(英語表記の場合)
One chaincode is a “chaincode”.	1つのチェーンコードを表す場合、単数形の「chaincode」を使用してください。
If you’re talking about several chaincodes, use "chaincodes".	複数のチェーンコードについて話している場合は、複数形の「chaincodes」を使用してください。
Smart contracts?	スマートコントラクト？
Colloquially, smart contracts are considered equivalent to chaincode, though at a technical level, it is more correct to say that a "smart contract" is the business logic inside of a chaincode, which encompasses the larger packaging and implementation.	口語的には、スマートコントラクトはチェーンコードと同等と見なされますが、技術的なレベルでは、「スマートコントラクト」はチェーンコードの内部のビジネスロジックであり、より大きなパッケージと実装を内包していると言ったほうが正しいでしょう。
JSON vs .json?	JSON vs. json ？
Use “JSON”.	「JSON」を使用してください。
The same applies for any file format (for example, YAML).	他のあらゆるファイル形式（例えば、YAML）も同様です。
curl vs cURL.	curl vs cURL
The tool is called “cURL”.	このツールは「cURL」と呼ばれています。
The commands themselves are “curl” commands.	コマンド自体は「curl」コマンドです。
Fabric CA.	Fabric CA
Do not call it "fabric-CA", "fabricCA", or FabricCA.	「fabric-CA」、「fabricCA」、または「FabricCA」とは呼ばないでください。
It is the Fabric CA.	正しくは「Fabric CA」です。
The Fabric CA client binary can, however, be referred to as the `fabric-ca-client`.	ただし、Fabric CAのクライアントバイナリは `fabric-ca-client` と呼ぶことができます。
Raft and RAFT.	Raft と RAFT
Raft is not an acronym.	「Raft」は頭文字をとった略語 (acronym: 頭字語) ではありません。
Do not call it a "RAFT ordering service".	そのため、「RAFTオーダリングサービス」と呼ばないでください。
Referring to the reader.	読者の参照の仕方
It’s perfectly fine to use the “you” or “we”.	「あなた (you) 」や「私たち (we) 」を使うのはまったく問題ありません。
Avoid using "I".	「私 (I) 」の使用は避けてください。
Ampersands (&).	アンパサンド (&)
Not a substitute for the word “and”.	「and」という単語の代わりにはなりません。
Avoid them unless you have a reason to use it (such as in a code snippet that includes it).	それを使用する理由がない限り (例えば、それを含むコードスニペットなど)、使用を避けてください。
Acronyms.	頭字語 (Acronyms: 頭文字をとった略語のこと)
The first usage of an acronym should be spelled out, unless it’s an acronym that’s in such wide usage this is unneeded.	ある頭字語を最初に使う場合には、それが広く使用されていない限り、スペルアウトする必要があります。
For example, “Software Development Kit (SDK)” on first usage.	例えば、最初の使用時には「Software Development Kit (SDK: ソフトウェア開発キット) 」を使用します。
Then use “SDK” afterward.	その後は「SDK」を使用します。
Try to avoid using the same words too often.	同じ単語を頻繁に使用しない
If you can avoid using a word twice in one sentence, please do so.	1つの文で同じ単語を2回使用するのを避けることができるなら、そうしてください。
Not using it more than twice in a single paragraph is better.	1つの段落内でも2回以上使用しないほうがよいでしょう。
Of course sometimes it might not be possible to avoid this –-- a doc about the state database being used is likely to be replete with uses of the word “database” or “ledger”.	もちろん、これを避けることができない場合もあります。--- 使用されているステートデータベースに関するドキュメントは、「データベース」または「台帳」という単語の使用でいっぱいになる可能性があります。
But excessive usage of any particular word has a tendency to have a numbing effect on the reader.	しかし、特定の単語を過剰に使うと、読者を麻痺させてしまう傾向があります。
How should files be named?	ファイル名はどのようにつけるべきか？
By using underscores between words.	単語の区切りにはアンダースコアを使う。
Also, tutorials should be named as such.	また、チュートリアルにはそれがわかる名前を付けるべきです。
For example, `identity_use_case_tutorial.md`.	例えば、 `identity_use_case_tutorial.md` といった具合です。
While not all files use this standard, new files should adhere to it.	すべてのファイルがこの標準を使用しているわけではありませんが、新しいファイルはこの標準に従うべきです。
Formatting and punctuation	フォーマットと句読点
Line lengths.	行の長さ
If you look at the raw versions of the documentation, you will see that many topics conform to a line length of roughly 70 characters.	ドキュメントの生ファイルを見ると、多くのトピックが約70文字 (70 characters) の行長に準拠していることがわかります。
This restriction is no longer necessary, so you are free to make lines as long as you want.	この制限はもはや必要ありませんので、自由に好きなだけ行を長くすることができます。
When to bold?	太字にするタイミング
Not too often.	それほど頻繁ではありません。
The best use of them is either as a summary or as a way of drawing attention to concepts you want to talk about.	それらの最良の使用法は、要約として、または話したい概念に注意を引く方法として、のどちらかです。
“A blockchain network contains a ledger, at least one chaincode, and peers”, especially if you’re going to be talking about those things in that paragraph.	「ブロックチェーンネットワークには台帳、少なくとも1つのチェーンコード、そしてピアが含まれています」というように、特にその段落の中でそれらのことについて話そうとしているのであればなおさらです。
Avoid using them simply to emphasize a single word, as in something like "Blockchain networks must use propery security protocols".	「ブロックチェーンネットワークは適切なセキュリティプロトコルを使用する 必要がある (原文: Blockchain networks must use proper security protocols) 」などのように、1つの単語を強調するためだけに太字を使用することはできません。
When to surround something in back tics `nnn`?	バッククォート `nnn` で囲むタイミング
This is useful to draw attention to words that either don’t make sense in plain English or when referencing parts of the code (especially if you’ve put code snippets in your doc).	これは、プレーンな英語では意味を成さない単語や、コードの一部を参照する際 (特に、コードスニペットをドキュメントに入れている場合) に注意を引くのに便利です。
So for example, when talking about the fabric-samples directory, surround `fabric-samples` with back tics.	例えば、 fabric-samples ディレクトリについて話すときは、`fabric-samples` のようにバッククォートで囲みます。
Same with a code function like `hf.Revoker`.	`hf.Revoker` のようなコード関数も同様です。
It might also make sense to put back tics around words that do make sense in plain English that are part of the code if you're referencing them in a code context.	また、コードのコンテキストで参照している場合には、コードの一部であるプレーンな英語で意味のある単語をバッククォートで囲むのも意味があるかもしれません。
For example, when referencing an `attribute` as part of an Access Control List.	例えば、アクセス制御リストの一部として `attribute` を参照している場合です。
Is it ever appropriate to use a dash?	ダッシュを使用することは適切か？ (英語表記の場合)
Dashes can be incredibly useful but they're not necessarily as technically appropriate as using separate declarative sentences.	ダッシュは非常に便利ですが、個別の宣言文を使用するよりも技術的に適切であるとは限りません。
Let's consider this example sentence:	以下の例文を考えてみましょう。
This leaves us with a trimmed down JSON object --- config.json, located in the fabric-samples folder inside first-network --- which will serve as the baseline for our config update.	これにより、トリミングされたJSONオブジェクトが残ります --- config.json、これはfirst-network内のfabric-samplesフォルダにあります --- 設定更新のベースラインとして機能します
There are a number of ways to present this same information, but in this case the dashes break up the information while keeping it as part of the same thought.	同じ情報を提示するにはいくつかの方法がありますが、この場合ではダッシュを使うことで、同じ考えの一部として情報を保持しつつ、情報を分断しています。
If you use a dash, make sure to use the "em" dash, which is three times longer than a hyphen.	ダッシュを使用する場合は、ハイフンの3倍の長さの「em」ダッシュを必ず使用してください。
These dashes should have a space before and after them.	これらのダッシュの前後にはスペースが必要です。
When to use hyphens?	ハイフンを使うタイミング (英語表記の場合)
Hyphens are mostly commonly used as part of a “compound adjective”.	ハイフンは主に「複合形容詞」の一部としてよく使用されます。
For example, "jet-powered car".	たとえば、「jet-powered car」などです。
Note that the compound adjective must immediately precede the noun being modified.	複合形容詞は、修飾される名詞の直前になければならないことに注意してください。
In other words, "jet powered" does not by itself need a hyphen.	言い換えると、「jet powered」自体はハイフンを必要としません。
When in doubt, use Google, as compound adjectives are tricky and are a popular discussion on grammar discussion boards.	複合形容詞は厄介で、文法の掲示板でもよく議論されているので、疑問がある場合はGoogleで検索して下さい。
How many spaces after a period?	ピリオドの後のスペースは何個？ (英語表記の場合)
One.	1つです。
How should numbers be rendered?	数値はどのように記述するべきか？ (英語表記の場合)
Number zero through nine are spelled out. One, two, three, four, etc.	0から9までの数字は単語で綴っています (one, two, three, four etc.)。
Numbers after 10 are rendered as numbers.	10以降の数字は数字として記述されます。
Exceptions to this would be usages from code.	例外として、コードからの使用があります。
In that case, use whatever’s in the code.	その場合は、コードの中にあるものを何でも使ってください。
And also examples like Org1.	また、Org1のような例もあります。
Don’t write it as OrgOne.	OrgOneとして記述しないでください。
Capitalization rules for doc titles.	ドキュメントタイトルの大文字使用ルール (英語表記の場合)
The standard rules for capitalization in sentences should be followed.	文中の大文字の使用に関する標準ルールに従う必要があります。
In other words, unless a word is the first word in the title or a proper noun, do not capitalize its first letter.	つまり、単語がタイトルまたは固有名詞の最初の単語でない限り、最初の文字を大文字にしないでください。
For example, "Understanding Identities in Fabric" should be "Understanding identities in Fabric".	例えば、「Understanding Identities in Fabric」は「Understanding identities in Fabric」である必要があります。
While not every doc follows this standard yet, it is the standard we're moving to and should be followed for new topics.	すべてのドキュメントがこの標準に準拠しているわけではありませんが、これは私たちが移行しようとしている標準であり、新しいトピックでは従う必要があります。
Headings inside of topics should follow the same standard.	トピック内の見出しも、同じ標準に従う必要があります。
Use the Oxford comma?	オックスフォード・カンマ (Oxford comma) を使用するか? (英語表記の場合)
Yes, it’s better.	はい、それがよりよいです。
The classic example is, “I’d like to thank my parents, Ayn Rand and God”, as compared to: “I’d like to thank my parents, Ayn Rand, and God.”	典型的な例は、「I’d like to thank my parents, Ayn Rand and God.」よりも「I’d like to thank my parents, Ayn Rand, and God.」がよいです。
Captions.	図表のキャプション (Captions)
These should be in italics, and it’s the only real valid use for italics in our docs.	図表のキャプションはイタリック体である必要があり、私たちのドキュメントではイタリック体の唯一の有効な使用法です。
Commands.	コマンド
In general, put each command in its own snippet.	一般的には、それぞれのコマンドをそれぞれのスニペットに入れます。
It reads better, especially when commands are long.	特にコマンドが長い場合は、その方が読みやすいでしょう。
An exception to this rule is when suggesting the export of a number of environment variables.	このルールの例外は、いくつかの環境変数のエクスポートを提案する場合です。
Code snippets.	コードスニペット
In Markdown, if you want to post sample code, use three back tics to set off the snippet.	Markdownでは、サンプルコードを記載する場合は、3連のバッククォートを使用してスニペットを開始します。
For example:	例えば、以下のようになります。
Code goes here.	ここにコードが入ります。
Even more code goes here.	さらに多くのコードがここに入ります。
And still more.	さらに多くのコードが続きます。
In RST, you will need to set off the code snippet using formatting similar to this:	RSTでは、次のようなフォーマットを使用してコードスニペットを開始する必要があります。
Code goes here.	ここにコードが入ります。
You can substitute `bash` for a language like Java or Go, where appropriate.	必要に応じて、JavaやGoなどの言語で `bash` を置き換えることができます。
Enumerated lists in markdown.	Markdown内の番号付きリスト (Enumerated list)
Note that in Markdown, enumerated lists will not work if you separate the numbers with a space.	Markdownでは、リストアイテムを空行で区切った場合、番号付きリストは機能しないことに注意してください。
Markdown sees this as the start of a new list, not a continuation of the old one (every number will be `1.`).	Markdownはこれを古いリストの継続ではなく、新しいリストの始まりと見なします（すべての数字は `1.` になります）。
If you need an enumerated list, you will have to use RST.	番号付きリストが必要な場合は、RSTを使用する必要があります。
Bulleted lists are a good substitute in Markdown, and are the recommended alternative.	箇条書きリスト (Bulleted list) は、Markdownの優れた代替品であり、推奨される代替手段です。
Linking.	リンク
When linking to another doc, use relative links, not direct links.	他のドキュメントにリンクする場合は、直接リンクではなく相対リンクを使用してください。
When naming a link, do not just call it "link".	リンクに名前を付けるときは、単に「link」のように名付けないでください。
Use a more creative and descriptive name.	よりクリエイティブで説明的な名前を使用してください。
For accessibility reasons, the link name should also make it clear that it is a link.	アクセシビリティ上の理由から、リンク名はリンクであることを明確にするべきです。
All docs have to end with a license statement.	すべてのドキュメントの最後にはライセンス文が必要
In RST, it’s this:	RSTでは以下の通りです。
In markdown:	Markdownでは以下の通りです。
How many spaces for indentation?	インデントのためのスペースは何個か？
This will depend on the use case.	これはユースケースに依存します。
Frequently it’s necessary, especially in RST, to indent two spaces, especially in a code block.	多くの場合、特にRSTでは、特にコードブロックで2つのスペースをインデントする必要があります。
In a `..note::` box in RST, you have to indent to the space after the colon after note, like this:	RSTの `.. note ::` ボックスでは、次のように、note の後のコロンの後のスペースをインデントする必要があります。
..note:: Some words and stuff etc etc etc (line continues until the 70 character limit line)	.. note:: いくつかの単語や文章などなど (行は70文字の制限行まで続く)
the line directly below has to start at the same space as the one above.	直下の行は上の行と同じスペースから始めなければならない。
When to use which type of heading.	どのタイプの見出しをいつ使用するか
In RST, use this:	RSTでは、以下を使用します。
Chapter 1 Title	チャプター (Chapter) 1 タイトル
===============	===============================
Section 1.1 Title	セクション (Section) 1.1 タイトル
Subsection 1.1.1 Title	サブセクション (Subsection) 1.1.1 タイトル
~~~~~~~~~~~~~~~~~~~~~~	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Section 1.2 Title	セクション (Section) 1.2 タイトル
Note that the length of what’s under the title has to be the same as the length of the title itself.	タイトルの下にある記号 (=-~) の長さは、タイトル自体の長さと同じでなければならないことに注意してください。
This isn’t a problem in Atom, which gives each character the same width by default (this is called “monospacing”, if you’re ever on Jeopardy! and need that information.	これはデフォルトで各文字に同じ幅を与えているAtomでは問題ではありません (Jeopardyを使用していて、その情報が必要な場合は、これは「モノスペース (monospacing) 」と呼ばれます)。
In markdown, it’s somewhat simpler.	Markdownでは、それはやや単純です。
The Name of the Doc (this will get pulled for the TOC).	ドキュメントの名前 (これは目次 (TOC) のために引っ張られます)
First subsection	1つ目のサブセクション (Subsection)
Second subsection	2つ目のサブセクション (Subsection)
Both file formats don't like when these things are done out of order.	どちらのファイルフォーマットも、これらが順不同で行われることを好みません。
For example, you might want a `####` to be the first thing after your `#` Title.	例えば、`#` タイトルの後に最初に `####` が欲しいかもしれません。
Markdown won’t allow it.	しかし、Markdownはそれを許可しません。
Similarly, RST will default to whatever order you give to the title formats (as they appear in the first sections of your doc).	同様に、RSTはあなたがタイトルフォーマットに与えた順序をデフォルトにします (ドキュメントの最初のセクションに表示されます)。
Relative links should be used whenever possible.	可能な場合は相対リンクを使用する
For RST, the preferred syntax is:	RSTの場合、推奨される構文は次のとおりです。
:doc:`anchor text <relativepath>`	:doc:`アンカーテキスト <相対パス>`
Do not put the .rst suffix at the end of the filepath.	ファイルパスの最後には .rst 接尾語を付けないでください。
For Markdown, the preferred syntax is:	Markdownの場合、推奨される構文は次のとおりです。
[anchor text](<relativepath>)	[アンカーテキスト](<相対パス>)
For other files, such as text or YAML files, use a direct link to the file in	テキストファイルやYAMLファイルなどの他のファイルの場合は、GitHub内ファイルへの直接リンクを使用します。
github for example:	以下に例を示します。
Relative links are unfortunately not working on github when browsing through a RST file.	GitHub上でRSTファイルをブラウジングする場合、残念ながら相対リンクは機能しません。
**Audience**: Writers who would like to create a new Fabric translation.	**対象読者**: 新しくFabricの翻訳を作成したい方
If the Hyperledger Fabric documentation is not available in your chosen language then why not start a new language translation?	Hyperledger Fabricのドキュメントに、あなたのほしい言語がなかったら、ぜひ新しい翻訳を始めてみましょう！
It's relatively easy to get started, and creating a new language translation can be a very satisfying activity for you and other Fabric users.	これは比較的簡単に始められますし、新しく翻訳を始めることは、あなたにとっても他のFabricユーザーにとっても、とても満足いく活動となりうるはずです。
In this topic, we're going to cover:	このトピックでは、以下について説明します。
[An introduction to international language support](#introduction)	[国際言語サポートの紹介](#introduction)
[How to create a new language workgroup](#create-a-new-workgroup)	[新しい言語ワーキンググループの作成](#create-a-new-workgroup)
[How to create a new language translation](#create-a-new-translation) Hyperledger Fabric documentation is being translated into many different languages.	[新しい翻訳の作成](#create-a-new-translation)Hyperledger Fabricのドキュメントは、多くの異なる言語に翻訳されつつあります。
For example:	例えば、
[Chinese](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/zh_CN)	[中国語(簡体字)](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/zh_CN)
[Malayalam](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/ml_IN)	[マラヤーラム語](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/ml_IN)
[Brazilian Portuguese](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/pt_BR)	[ブラジル・ポルトガル語](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/pt_BR)
[Japanese](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/ja_JP)	[日本語](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/ja_JP)
If your chosen language is not available, then the first thing to do is to create a new language workgroup.	もし、あなたの求める言語が存在しない場合には、まず最初に新しい言語ワーキンググループを作成しましょう。
It's much easier to translate, maintain, and manage a language repository if you collaborate with other translators.	他の翻訳者と協力することで、翻訳、メンテナンス、その言語のレポジトリの管理がより簡単になります。
Start this process by adding a new workgroup to the [list of international workgroups](https://wiki.hyperledger.org/display/fabric/International+groups), using one of the existing workgroup pages as an exemplar.	このためには、既存のワーキングループのページを参考にして、まず新しいワーキンググループを[国際ワーキンググループのリスト](https://wiki.hyperledger.org/display/fabric/International+groups)に追加します。
Document how your workgroup will collaborate;	ここには、ワーキンググループがどのように共同作業をしていくかを記述してください。
meetings, chat and mailing lists can all be very effective.	ミーティング、チャット、メーリングリストなどは、すべてとても有用でしょう。
Making these mechanisms clear on your workgroup page can help build a community of translators.	ワーキンググループのページで、これらの共同作業の方法について明確にしておくことは、翻訳者のコミュニティを形成するのに役立つでしょう。
Then use [Rocket chat channels](./advice_for_writers.html#rocket-chat) to let other people know you've started a translation, and invite them to join the workgroup.	そして、[Rocket.Chatのチャネル](./advice_for_writers.html#rocket-chat)を使って、他の皆さんに翻訳を始めたことをお知らせし、ワーキンググループへの参加を募集しましょう。
Follow these instructions to create your own language repository.	--新しい言語のレポジトリを作成するにあたっては、下記の手順を守りましょう。
Our sample instructions will show you how to create a new language translation for Spanish as spoken in Mexico:	ここでは、メキシコで使われているスペイン語への翻訳を例にとって、新しい言語への翻訳を開始する手順を説明します。
1. Fork the [`fabric-docs-i18n` repository](https://github.com/hyperledger/fabric-docs-i18n) to your GitHub account.	1. [`fabric-docs-i18n` レポジトリ](https://github.com/hyperledger/fabric-docs-i18n)を、あなたのGitHubアカウントにフォークします。
1. Clone your repository fork to your local machine:	1. ローカルマシンにフォークしたレポジトリをcloneします。
1. Select the Fabric version you are going to use as a baseline.	1. ベースにするFabricのバージョンを選びます。
We recommend that you start with Fabric 2.2 as this is an LTS release.	Fabric 2.2がLTSリリースなので、まずはこれを使うことをお勧めします。
You can add other releases later.	他のバージョンは後で追加することができます。
1. Create a local feature branch:	1. ローカルにフィーチャーブランチを作成します。
1. Identify the appropriate [two or four letter language code](http://www.localeplanet.com/icu/).	1. 適切な [2文字か4文字の言語コード](http://www.localeplanet.com/icu/) を選択します。
Mexican Spanish has the language code `es_MX`.	メキシコのスペイン語は、`es_MX` です。
1. Update the fabric [`CODEOWNERS`](https://github.com/hyperledger/fabric-docs-i18n/blob/master/CODEOWNERS) file in the root directory.	1. レポジトリのルートにある[`CODEOWNERS`](https://github.com/hyperledger/fabric-docs-i18n/blob/master/CODEOWNERS) ファイルを編集します。
Add the following line:	次の行を追加します。
1. Copy the language files from another language folder,	1. 他の言語フォルダから、ファイルをコピーします。
Alternatively, you could copy the `docs/` folder from the `fabric` repository.	もしくは、`fabric` レポジトリの `docs/` フォルダからコピーしてもかまいません。
1. Customize the `README.md` file for your new language using [this example](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/pt_BR/README.md).	1. 新しい言語用に、[この例](https://github.com/hyperledger/fabric-docs-i18n/tree/master/docs/locale/pt_BR/README.md)を参考に `README.md` を編集します。
1. Commit your changes locally:	1. 変更した内容を、ローカルにコミットします。
1. Push your `newtranslation` local feature branch to the `release-2.2` branch of your forked `fabric-docs-i18n` repository: remote:      https://github.com/YOURGITHUBID/fabric-docs-i18n/pull/new/newtranslation To github.com:ODOWDAIBM/fabric-docs-i18n.git	1. ローカルの `newtranslation` ブランチを、フォークした `fabric-docs-i18n` レポジトリの`release-2.2` ブランチに対してpushします。remote:      https://github.com/(あなたのGitHub ID)/fabric-docs-i18n/pull/new/newtranslationTo github.com:(あなたのGitHub ID)/fabric-docs-i18n.git
1. Connect your repository fork to ReadTheDocs using these [instructions](./docs_guide.html#building-on-github).	1. フォークしたレポジトリとReadTheDocsを [この手順](./docs_guide.html#building-on-github) にしたがって連携させます。
Verify that your documentation builds correctly.	ドキュメントが正しくビルドされることを確認します。
1. Create a pull request (PR) for `newtranslation` on GitHub by visiting:	1. `newtranslation`のプルリクエスト(PR)を、GitHubの下記のURLから作成します。
[`https://github.com/YOURGITHUBID/fabric-docs-i18n/pull/new/newtranslation`](https://github.com/YOURGITHUBID/fabric-docs-i18n/pull/new/newtranslation)	[`https://github.com/(あなたのGitHub ID)/fabric-docs-i18n/pull/new/newtranslation`](https://github.com/YOURGITHUBID/fabric-docs-i18n/pull/new/newtranslation)
Your PR needs to be approved by one of the [documentation maintainers](https://github.com/orgs/hyperledger/teams/fabric-core-doc-maintainers).	PRは、[ドキュメントメンテナ](https://github.com/orgs/hyperledger/teams/fabric-core-doc-maintainers)の誰かによって承認される必要があります。
They will be automatically informed of your PR by email, and you can contact them via Rocket chat.	PRがあると自動的にメンテナにe-mailで通知されますが、Rocket.Chat経由でコンタクトをとってもかまいません。
1. On the [`i18n rocket channel`](https://chat.hyperledger.org/channel/i18n) request the creation of the new group of maintainers for your language, `@hyperledger/fabric-es_MX-doc-maintainers`.	1. [Rocket.Chatの `i18n` チャネル](https://chat.hyperledger.org/channel/i18n) で、新しい言語のメンテナのグループである `@hyperledger/fabric-es_MX-doc-maintainers`の作成を依頼します。
Provide your GitHubID for addition to this group.	グループに登録するため、あなたのGitHub IDも伝えてください。
Once you've been added to this list, you can add others translators from your workgroup.	このリストに追加されると、他の翻訳者をワーキンググループに自分で追加することができるようになります。
Congratulations! A community of translators can now translate your newly-created language in the `fabric-docs-i18n` repository.	おめでとうございます！ これで、新しい言語の翻訳者のコミュニティが、 `fabric-docs-i18n` レポジトリで翻訳を行えるようになります。
Before your new language can be published to the documentation website, you must translate the following topics.	新しい言語が、ドキュメントのWebサイトに掲載されるためには、下記のトピックについて翻訳を行う必要があります。
These topics help users and translators of your new language get started.	その言語の利用者や翻訳者が新たに参加するために、これらのトピックが役立つでしょう。
This is your advert! Thanks to you, users can now see that the documentation is available in their language.	ここがあなたの看板となるでしょう！ あなたのおかげで、利用者は、その言語のドキュメントがあることを知ることができます。
It might not be complete yet, but its clear you and your team are trying to achieve.	完全ではないかもしれませんが、少なくとも、あなたとそのチームが何を達成しようとしているかは明確になります。
Translating tis page will help you recruit other translators.	このトピックを翻訳することで、他の翻訳者を勧誘するのにも役立つでしょう。
This short topic gives a high level overview of Fabric,	この短いトピックは、Fabricのハイレベルの概要について述べています。
and because it's probably one of the first topics a new user will look at, it's important that it's translated.	新しいユーザーは、おそらくこのトピックを最初に見るでしょうから、これが翻訳されているということは重要でしょう。
This topic is vital -- 	このトピックは非常に重要です。
it helps contributors understand **what**, **why** and **how** of contributing to Fabric.	コントリビューターは、Fabricに対する貢献の方法について、 **何** **なぜ** **どうやって**を理解することができるからです。
You need to translate this topic so that others can help you collaborate in your translation.	翻訳で共同作業を行うためにも、このトピックを翻訳する必要があります。
Translating this topic provides the essential reference material that helps other language translators make progress;	このトピックの翻訳は、ほかの翻訳者が作業を進めるうえで必須のリファレンスとなります。
in short, it allows your workgroup to scale.	いいかえると、このトピックの翻訳によって、ワーキンググループをスケールさせることができます。
Once this set of topics have been translated, and you've created a language workgroup, your translation can be published on the documentation website.	これらのトピックの翻訳が終わり、新しい言語のワーキンググループができれば、あなたの翻訳をドキュメントのWebサイトに掲載することができます。
For example, the Chinese language docs are available [here](https://hyperledger-fabric.readthedocs.io/zh_CN/latest/).	例えば、中国語(簡体字)の翻訳は、 [ここ](https://hyperledger-fabric.readthedocs.io/zh_CN/latest/)にあります。
You can now request, via the [`i18n rocket channel`](https://chat.hyperledger.org/channel/i18n), that your translation is included on the documentation website.	[Rocket.Chatの `i18n` チャネル](https://chat.hyperledger.org/channel/i18n) で、あなたの翻訳をWebサイトに追加するように依頼できます。
When translating topics from US English to your international language, it's often helpful to use an online tool to generate a first pass of the translation, which you then correct in a second pass review.	アメリカ英語からあなたの言語に翻訳を行う際に、最初のパスでオンラインツールを利用し、二回目のパスでそれを修正するというのが、便利なことが多いです。
Language workgroups have found the following tools helpful:	各ワーキンググループでは、下記のようなツールを有用だとしています。
Once you have published the mandatory initial set of topics on the documentation website, you are encouraged to translate these topics, in order.	必須のトピックがドキュメントのWebサイトに掲載されたら、下記の順に翻訳を進めるのがよいでしょう。
If you choose to adopt another order, that's fine; you still will find it helpful to agree an order of translation in your workgroup.	他の順番で行うことにしてもかまいませんが、その場合でも、ワーキンググループで、翻訳の順番について合意しておくとよいでしょう。
For solution architects, application architects, systems architects, developers, academics and students alike, this topic provides a comprehensive conceptual understanding of Fabric.	ソリューション・アーキテクト、アプリケーション・アーキテクト、システム・アーキテクト、開発者、研究者、学生など向けに、Fabricのコンセプトを包括的に説明しています。
For developers who want to get hands-on with Fabric, this topic provides key instructions to help install, build a sample network and get hands-on with Fabric.	Fabricのハンズオンが必要な開発者向けに、インストール・サンプルネットワークの構築・Fabricで手を動かすための主要な手順について説明しています。
This topic helps developers write smart contracts and applications; these are the core elements of any solution that uses Fabric.	開発者向けに、Fabricを使ったどんなソリューションでもコア要素となる、スマートコントラクトとアプリケーションの書き方を説明しています。
A set of hands-on tutorials to help developers and administrators try out specific Fabric features and capabilities.	開発者と管理者向けに、Fabricの特定の機能について試すためのハンズオン・チュートリアルを集めたものです。
This topic covers the latest features in Hyperledger Fabric.	Hyperledger Fabricの最新の機能について説明しています。
Finally, we wish you good luck, and thank you for your contribution to Hyperledger Fabric.	最後に、あなたの健闘を祈るとともに、Hyperledger Fabricへの貢献に感謝します。
**Audience**: Writers who would like to contribute to the Fabric documentation.	**対象読者**:Fabricのドキュメンテーションに貢献したい方
This topic gives you general advice on how to contribute to one of the many language translations provided by Fabric.	このトピックではFabricの提供する複数の言語翻訳の1つにどのように貢献するかに関する一般的なアドバイスを提供します。
In this topic, we're going to cover:	このトピックでは、次の内容について説明します：
Before you make a documentation change, you might like to connect with other people working on the Fabric documentation.	ドキュメントを変更する前に、他のFabricのドキュメンテーションの担当者に連絡するといいでしょう。
Your [Linux Foundation account](./contributing.html#getting-a-linux-foundation-account) will give you access to many different resources to help you connect with other contributors to the documentation.	[Linux Foundationアカウント](./contributing.html#getting-a-linux-foundation-account)を使用すると、様々なリソースにアクセスし、他のドキュメンテーションの貢献者とつながることができます。
Once you have a Linux Foundation account, use any or all of the following mechanisms to connect with others.	Linux Foundationアカウントを取得した後、下記の方法で他のユーザーとつながることができます。
Hyperledger Fabric uses [Rocket chat](https://chat.hyperledger.org/home) for interactive discussions on a variety of project topics.	Hyperledger Fabric は様々なプロジェクトのトピックについての双方向の議論をするために、[Rocket chat](https://chat.hyperledger.org/home) を使用します。
You'll find beginners and experts sharing information on the Fabric documentation.	ビギナーとエキスパートが Fabric ドキュメンテーションについて情報を共有しているのが確認できます。
Read the conversation or ask a question on how to get started.	会話を読むか、開始方法について質問してください。
A dedicated channel for general questions on international languages.	国際言語に関する一般的な質問のための専用チャネルです。
Read, discuss and share ideas related to the Japanese translation.	日本語翻訳に関するアイディアについて、確認・議論・共有してください。
A great place to meet people working on documentation is the Documentation workgroup call.	ドキュメンテーションに取り組んでいる人々に会うのに最適な場所は、Documentation workgroup call です。
These are held twice every Friday at a time convenient for both Eastern and Western hemispheres.	これらは、毎週金曜日に東半球と西半球のそれぞれで都合のよい時間に2回開催されます。
The agenda is published in advance, and there are minutes and recordings of each session.	議題は事前に公開されており、各セッションの議事録と記録があります。
Find out more on the [Documentation wiki](https://wiki.hyperledger.org/display/fabric/Documentation+Working+Group).	詳細については、[Documentation wiki](https://wiki.hyperledger.org/display/fabric/Documentation+Working+Group)をご覧ください。
Each of the international languages has a welcoming workgroup that you are encouraged to join.	各国際言語には、参加をお勧めする友好的なワークグループがあります。
View the [list of international workgroups](https://wiki.hyperledger.org/display/fabric/International+groups).	[list of international workgroups](https://wiki.hyperledger.org/display/fabric/International+groups) をご覧ください。
See what your favorite workgroup is doing, and get connected with them.	気になったワークグループが何をしているか確認し、参加してください。
Each workgroup has a list of members and their contact information.	各ワークグループには、メンバーとその連絡先情報のリストがあります。
Hyperledger Fabric has many other collaboration mechanisms such as mailing lists, contributor meetings and maintainer meetings.	Hyperledger Fabricには、メーリングリスト、コントリビューターミーティング、メンテナーミーティングなど、他にも多くのコラボレーション方法があります。
Find out about these and more [here](./contributing.html).	詳細については、[こちら](./contributing.html) をご覧ください。
Good luck getting started and thanks for your contribution.	あなたの貢献に感謝します。
Contributing documentation	ドキュメントに貢献する
**Audience**: Anyone who would like to contribute to the Fabric documentation.	**対象読者**: Fabricドキュメントに貢献したい方.
This short guide describes how the Fabric documentation is structured, built and published, as well as a few conventions that help writers make changes to the Fabric documentation.	この短いガイドでは、Fabricドキュメントの構成、構築、公開方法、およびFabricドキュメントの変更に役立ついくつかの規則について説明します。
In this topic, we're going to cover:	このトピックでは、次の内容について説明します:
[An introduction to the documentation](#introduction)	[はじめに](#introduction)
[Repository folder structure](#repository-folders)	[リポジトリフォルダ構成](#repository-folders)
[International language folder structure](#international-folders)	[国際言語フォルダ構成](#international-folders)
[Making documentation changes](#making-changes)	[ドキュメントを変更する](#making-changes)
[Building the documentation on your local machine](#building-locally)	[ローカルマシン上のドキュメントをビルドする](#building-locally)
[Building the documentation on GitHub with ReadTheDocs](#building-on-github)	[GitHub上のドキュメントをReadTheDocsを利用してビルドする](#building-on-github)
[Getting your change approved](#making-a-pr)	[修正に対して承認をもらう](#making-a-pr)
[Making a change to Commands Reference](#commands-reference-updates)	[コマンドリファレンスを変更する](#commands-reference-updates)
[Adding a new CLI command](#adding-a-new-cli-command)	[新しいCLIコマンドを追加する](#adding-a-new-cli-command)
The Fabric documentation is written in a combination of [Markdown](https://www.markdownguide.org/) and [reStructuredText](http://docutils.sourceforge.net/rst.html) source files.	Fabricドキュメントは、[Markdownソース・ファイル](https://www.markdownguide.org/)と[reStructuredTextソース・ファイル](http://docutils.sourceforge.net/rst.html)を組み合わせて作成されています。
As a new author you can use either format.	新規作成者は、どちらの形式でも使用できます。
We recommend that you use Markdown as an easy and powerful way to get started.	使い勝手が良いMarkdownを使用することをお勧めします。
If you have a background in Python, you may prefer to use rST.	Pythonの経験がある場合は、rSTの方が扱い易いかもしれません。
During the documentation build process, the documentation source files are converted to HTML using [Sphinx](http://www.sphinx-doc.org/en/stable/).	ドキュメントのビルド・プロセスにおいて、ドキュメントのソース・ファイルは[Sphinx](http://www.sphinx-doc.org/en/stable/)を使用してHTMLに変換されます。
The generated HTML files are subsequently published on the [public documentation website](http://hyperledger-fabric.readthedocs.io).	生成されたHTMLファイルは、その後、パブリックのドキュメントサイトに公開されます。
Users can select both different languages and different versions of the Fabric documentation.	ユーザーは、Fabricマニュアルの言語とバージョンの両方を選択できます。
For example:	例:
[Latest version of US English](https://hyperledger-fabric.readthedocs.io/en/latest/)	[最新バージョンの英語（US）ドキュメント](https://hyperledger-fabric.readthedocs.io/en/latest/)
[Latest version of Chinese](https://hyperledger-fabric.readthedocs.io/zh_CN/latest/)	[最新バージョンの中国語ドキュメント](https://hyperledger-fabric.readthedocs.io/zh_CN/latest/)
[Version 2.2 of US English](https://hyperledger-fabric.readthedocs.io/en/release-2.2/)	[バージョン2.2の英語（US）ドキュメント](https://hyperledger-fabric.readthedocs.io/en/release-2.2/)
[Version 1.4 of US English](https://hyperledger-fabric.readthedocs.io/en/release-1.4/)	[バージョン1.4の英語（US）ドキュメント](https://hyperledger-fabric.readthedocs.io/en/release-1.4/)
For historical reasons, the US English source files live in the main [Fabric repository](https://github.com/hyperledger/fabric/), whereas all international language source files live in a single [Fabric i18n repository](https://github.com/hyperledger/fabric-docs-i18n).	歴史的な理由から、英語（US）ドキュメントのソース・ファイルはメインの[Fabricリポジトリ](https://github.com/hyperledger/fabric/)で管理されますが、国際言語向けドキュメントのソース・ファイルはすべて1つの[Fabric i18nリポジトリ](https://github.com/hyperledger/fabric-docs-i18n)で管理されます。
Different versions of the documentation are held within the appropriate GitHub release branch.	ドキュメントの異なるバージョンは、適切なGitHubリリースブランチに保持されています。
Both the US English and international language repositories have essentially the same structure, so let's start by examining the US English source files.	英語（US）ドキュメントのリポジトリと国際言語向けドキュメントのリポジトリは基本的に同じ構成を持つため、まず英語（US）ドキュメントのソースファイルを見ていくところからスタートします。
All files relating to documentation reside within the `fabric/docs/` folder:	ドキュメントに関連するすべてのファイルは、`fabric/docs/`フォルダ内にあります:
The most important folders is `source/` becuase it holds the source language files.	最も重要なフォルダは、ソースとなる言語ファイルが格納されている `source/` フォルダです。
The documentation build process uses the `make` command to convert these source files to HTML, which are stored in the dynamically created `build/html/` folder:	ドキュメントのビルドプロセスでは、`make`コマンドを使用して、このソースファイルをHTMLに変換し、動的に作成される`build/html/`フォルダに格納します:
Spend a little time navigating the [docs folder](https://github.com/hyperledger/fabric/tree/master/docs) in the Hyperledger Fabric repository.	Hyperledger Fabricリポジトリ内の[docsフォルダ](https://github.com/hyperledger/fabric/tree/master/docs)内を見るのに少し時間を割いてみてください。
Click on the following links to see how different source files map to their corresponding published topics.	次のリンクをクリックすると、ソースファイルが対応する公開トピックにどのようにマッピングされているか確認できます。
We'll see how to make changes to these files a little later.	これらのファイルの変更方法については、後ほど説明します。
The international language repository, [`fabric-docs-i18n`](https://github.com/hyperledger/fabric-docs-i18n), follows almost exactly the same structure as the [`fabric`](https://github.com/hyperledger/fabric) repository which holds the US English files.	国際言語リポジトリ[`fabric-docs-i18n`](https://github.com/hyperledger/fabric-docs-i18n)は、英語（US）ファイルを保持する[`fabric`](https://github.com/hyperledger/fabric)リポジトリとほぼ同じ構成に従います。
The difference is that each language is located within its own folder within `docs/locale/`:	違いは、各言語のファイルが`docs/locale/`の個別のフォルダに格納されている点です:
Examining any one of these folders shows a familiar structure:	これらのフォルダのどれを見ても、既に馴染みのある構成であることが分かります:
As we'll soon see, the similarity of the international language and US English folder structures means that the same instructions and commands can be used to manage different language translations.	後で説明しますが、多言語と英語（US）のフォルダ構成が似ているため、同じ手順とコマンドを使用してさまざまな言語の翻訳を管理できます。
Again, spend some time examining the [international language repository](https://github.com/hyperledger/fabric-docs-i18n).	ここでも、[国際言語リポジトリ](https://github.com/hyperledger/fabric-docs-i18n)を見るのに少し時間を割いてみてください。
To update the documentation, you simply change one or more language source files in a local git feature branch, build the changes locally to check they're OK, and submit a Pull request (PR) to merge your branch with the appropriate Fabric repository branch.	ドキュメントを更新するには、ローカルのgit作業用ブランチ上でで1つ以上の言語ソースファイルを変更し、ローカルで変更をビルドして問題がないことを確認し、Pull request(PR)を送ってブランチを適切なFabricリポジトリのブランチにマージします。
Once your PR has been reviewed and approved by the appropriate maintainers for the language, it will be merged into the repository and become part of the published documentation.	あなたのPRがその言語の適切なメンテナによってレビューされ、承認されると、それはリポジトリにマージされ、公開されたドキュメントの一部になります。
It really is that easy!	本当に簡単です!
As well as being polite, it's a really good idea to test any documentation changes before you request to include it in a repository.	ドキュメントの変更をリポジトリに取り込むよう要求する前に、その変更をテストすることは、マナーであるというだけでなく、本当に大事なことです。
The following sections show you how to:	次の節では、以下の方法について説明します:
Build and review a documentation change on your own machine.	自分のマシンでドキュメントの変更をビルドして確認します。
Push these changes to your GitHub repository fork where they can populate your personal [ReadTheDocs](https://readthedocs.org/) publication website for collaborators to review.	これらの変更をフォークしたあなたのGitHubリポジトリにプッシュして、あなた個人の[ReadTheDocs](https://readthedocs.org/)Webサイトに反映することで共同作業者がレビューできるようになります。
Submit your documentation PR for inclusion in the `fabric` or  `fabric-docs-i18n` repository.	`fabric`または`fabric-docs-i18n`リポジトリに取り込むドキュメントのPRを送信します。
Use these simple steps to build the documentation.	次の簡単な手順に従ってドキュメントをビルドします。
1. Create a fork of the appropriate [`fabric`](https://github.com/hyperledger/fabric) or [`fabric-i18n`](https://github.com/hyperledger/fabric-docs-i18n) repository to your GitHub account.	1. 適切な[`fabric`](https://github.com/hyperledger/fabric)または[`fabric-docs-i18n`](https://github.com/hyperledger/fabric-docs-i18n)リポジトリのforkをGitHubアカウントに作成します。
2. Install the following prerequisites;	2. 以下の必要なツールをインストールします。
you may need to adjust depending on your OS:	ご使用のOSによっては、調整が必要な場合があります:
3. For US English:	3. 英語（US）の場合:
For Malayalam (for example):	マラヤーラム語の場合(例):
The `make` command generates documentation html files in the `build/html/` folder which you can now view locally;	`make`コマンドを実行すると、`build/html/`フォルダにドキュメントのhtmlファイルが生成されます。このファイルはローカルで表示できます。
simply navigate your browser to the `build/html/index.html` file.	ブラウザで`build/html/index.html`ファイルに移動するだけです。
4. Now make a small change to a file, and rebuild the documentation to verify that your change was as expected.	4. ここで、ファイルを少し変更し、ドキュメントを再構築して、変更が期待どおりであることを確認します。
Every time you make a change to the documentation you will of course need to rerun `make html`.	ドキュメントに変更を加えるたびに、当然のことながら`make html`を再実行する必要があります。
5. If you'd like, you may also run a local web server with the following commands (or equivalent depending on your OS):	5. 必要に応じて、次のコマンド(またはご使用のOS準じた同等の手順）でローカルWebサーバを立ち上げることもできます:
You can then access the html files at `http://localhost/index.html`.	その後、`http://localhost/index.html`にあるhtmlファイルにアクセスできます。
6. You can learn how to make a PR [here](./github/github.html).	6. PRの作成方法については[こちら](./github/github.html)から学ぶことができます。
Moreover, if you are new to git or GitHub, you will find the [Git book](https://git-scm.com/book/en/v2) invaluable.	さらに、gitやGitHubを初めて使う人にとっては、[Git book](https://git-scm.com/book/en/v2)は非常に役に立ちます。
It is often helpful to use your fork of the Fabric repository to build the Fabric documentation so that others can review your changes before you submit them for approval.	多くの場合、Fabricリポジトリからフォークしたあなた自身のレポジトリを使用してFabricドキュメントをビルドし、あなたが承認依頼を送信する前に他のユーザが変更を確認できるようにすることが有用です。
The following instructions show you how to use ReadTheDocs to do this.	次の手順では、ReadTheDocsを使用してこれを行う方法を示します。
1. Go to [`http://readthedocs.org`](http://readthedocs.org) and sign up for an account.	1. [`http://readthedocs.org`](http://readthedocs.org)にアクセスして、アカウントにサインアップします。
2. Create a project.	2. プロジェクトを作成します。
Your username will preface the URL and you may want to append `-fabric` to ensure that you can distinguish between this and other docs that you need to create for other projects.	ユーザ名はURLの前に挿入されます。他のプロジェクト用に作成するドキュメントと区別できるように、`-fabric`を追加することもできます。
So for example:	例えば以下の通りです:
`YOURGITHUBID-fabric.readthedocs.io/en/latest`.	`YOURGITHUBID-fabric.readthedocs.io/en/latest`.
3. Click `Admin`, click `Integrations`, click `Add integration`, choose `GitHub incoming webhook`, then click `Add integration`.	3. `Admin`をクリックし、`Integrations`をクリックし、`Add integration`をクリックし、`GitHub incoming webhook`を選択し、`Add integration`をクリックします。
4. Fork the [`fabric`](https://github.com/hyperledger/fabric) repository.	4. [`fabric`](https://github.com/hyperledger/fabric)リポジトリをフォークします。
5. From your fork, go to `Settings` in the upper right portion of the screen.	5. フォークしたレポジトリから、画面右上の`Settings`に移動します。
6. Click `Webhooks`.	6. `Webhooks`をクリックします。
7. Click `Add webhook`.	7. `Add webhook`をクリックします。
8. Add the ReadTheDocs's URL into `Payload URL`.	8. ReadTheDocsのURLを`Payload URL`に追加します。
9. Choose `Let me select individual events`:`Pushes`、`Branch or tag creation`、 `Branch or tag deletion`.	9. `Let me select individual events`:`Pushs`、`Branch or tag creation`、`Branch or tag deletion`を選択します。
10. Click `Add webhook`.	10. `Add webhook`をクリックします。
Use `fabric-docs-i18n` instead of `fabric` in the above instructions if you're building an international language translation.	国際言語翻訳をビルドする場合は、上記の手順で`fabric`の代わりに`fabric-docs-i18n`を使用します。
Now, anytime you modify or add documentation content to your fork, this URL will automatically get updated with your changes! 	ドキュメントの内容をあなたのフォーク上で変更または追加するたびに、このURL上の内容が自動的にあなたの修正で更新されます!
You can submit your PR for inclusion using the following [instructions](./github/github.html).	次の[手順](./github/github.html)に従って、修正取り込みのPRを送信することができます。
Pay special attention to signing your commit with the `-s` option: 	`-s`オプションを使用してコミットに署名することに特に注意してください。
This states that your changes conform to the [Developer Certificate of Origin](https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin).	これは、変更が[Developer Certificate of Origin](https://en.wikipedia.org/wiki/Developer_Certificate_of_Origin)に準拠していることを示します。
Before your PR can be included in the appropriate `fabric` or `fabric-docs-i18n` repository, it must be approved by an appropriate maintainer.	PRを適切な`fabric`または`fabric-docs-i18n`リポジトリに含めるには、適切なメンテナの承認が必要です。
For example, a Japanese translation must be approved by a Japanese maintainer, and so on.	たとえば、日本語の翻訳は日本語のメンテナの承認が必要です。
You can find the maintainers listed in the following `CODEOWNERS` files:	メンテナは、次の`CODEOWNERS`ファイルにリストされています。
Both language repositories have a GitHub webhook defined so that, once approved, your newly merged content in the `docs/` folder will trigger an automatic build and publication of the updated documentation.	どちらの言語リポジトリにもGitHubのwebhookが定義されているので、いったん承認されると、`docs/`フォルダに新しくマージされたコンテンツが自動的にビルドされ、更新されたドキュメントが発行されます。
Updating content in the [Commands Reference](https://hyperledger-fabric.readthedocs.io/en/latest/command_ref.html) topic requires additional steps.	[コマンドリファレンス](https://hyperledger-fabric.readthedocs.io/en/latest/command_ref.html)トピックの内容を更新するには、追加の手順が必要です。
Because the information in the Commands Reference topic is generated content, you cannot simply update the associated markdown files.	コマンドリファレンストピックの情報は生成されたコンテンツであるため、関連するMarkdownファイルを単純に更新することはできません。
Instead you need to update the `_preamble.md` or `_postscript.md` files under `src/github.com/hyperledger/fabric/docs/wrappers` for the command.	代わりに、`src/github.com/hyperledger/fabric/docs/wrappers`の下にある、このコマンドの`_preamble.md`または`_postscript.md`ファイルを更新する必要があります。
To update the command help text, you need to edit the associated `.go` file for the command that is located under `/fabric/internal/peer`.	コマンドのヘルプテキストを更新するには、`/fabric/internal/peer`の下にあるコマンドに関連付けられた`.go`ファイルを編集する必要があります。
Then, from the `fabric` folder, you need to run the command `make help-docs` which generates the updated markdown files under `docs/source/commands`.	次に`fabric`フォルダ内で`make help-docs`コマンドを実行し、`docs/source/commands`の下に更新されたMarkdownファイルを生成します。
Remember that when you push the changes to GitHub, you need to include the `_preamble.md`, `_postscript.md` or `_.go` file that was modified as well as the generated markdown file.	GitHubに変更をプッシュするときは、生成されたMarkdownファイルと同様に、変更された`_preamble.md`、`_postscript.md`、`_.go`ファイルを含める必要があることに注意してください。
This process only applies to English language translations.	このプロセスは、英語の翻訳にのみ適用されます。
Command Reference translation is currently not possible in international languages.	現在、コマンドリファレンスの翻訳は、国際言語向けには使用できません。
To add a new CLI command, perform the following steps:	新しいCLIコマンドを追加するには、次の手順を実行します:
Create a new folder under `/fabric/internal/peer` for the new command and the associated help text.	新しいコマンドと関連するヘルプテキストのために、`/fabric/internal/peer`の下に新しいフォルダを作成します。
See `internal/peer/version` for a simple example to get started.	新しいコマンド追加を始めるための簡単な例については、`internal/peer/version`を参照してください。
Add a section for your CLI command in `src/github.com/hyperledger/fabric/scripts/generateHelpDoc.sh`.	あなたが追加したCLIコマンドのセクションを`src/github.com/hyperledger/fabric/scripts/generateHelpDoc.sh`に追加します。
Create two new files under `/src/github.com/hyperledger/fabric/docs/wrappers` with the associated content:	`/src/github.com/hyperledger/fabric/docs/wrappers`の下に、関連するコンテンツとともに2つの新しいファイルを作成します:
`<command>_preamble.md` (Command name and syntax)	`<command>_preamble.md` (コマンド名と構文)
`<command>_postscript.md` (Example usage)	`<command>_postscript.md` (使用例)
Run `make help-docs` to generate the markdown content and push all of the changed files to GitHub.	`make help-docs`を実行してMarkdownコンテンツを生成し、変更されたすべてのファイルをGitHubにプッシュします。
This process only applies to English language translations.	このプロセスは、英語の翻訳にのみ適用されます。
CLI command translation is currently not possible in international languages.	CLIコマンドの翻訳は、現在、国際言語では使用できません。
Before we begin, if you haven't already done so, you may wish to check that you have all the :doc:`prereqs` installed on the platform(s) on which you'll be developing blockchain applications and/or operating Hyperledger Fabric. Once you have the prerequisites installed, you are ready to download and install HyperLedger Fabric.	最初に、ブロックチェーンアプリケーションを開発したり、Hyperledger Fabricを運用したりするプラットフォームに、必要な :doc:`ソフトウェア <prereqs>` がインストールされていることを確認します。
While we work on developing real installers for the Fabric binaries, we provide a script that will :doc:`install` to your system.	Fabricのバイナリの本当のインストーラは現在開発中ですが、あなたのシステムに :doc:`インストール <install>` するためのスクリプトを提供しています。
The script also will download the Docker images to your local registry. 	スクリプトはDockerイメージもローカルレジストリにダウンロードします。
After you have downloaded the Fabric Samples and Docker images to your local machine, you can get started working with Fabric with the :doc:`test_network` tutorial. 	Fabric SamplesとDockerイメージをローカルマシンにダウンロードしたら、チュートリアル :doc:`test_network <test_network>` を使ってFabricを使い始めることができます。
Hyperledger Fabric offers a number of APIs to support developing smart contracts (chaincode) in various programming languages.	Hyperledger Fabricは、さまざまなプログラミング言語でのスマートコントラクト(チェーンコード)の開発をサポートするために、多数のAPIを提供しています。
Smart contract APIs are available for Go, Node.js, and Java: 	スマートコントラクトのAPIはGo用、Node.js用、Java用のものが利用可能です。
`Node.js contract API <https://github.com/hyperledger/fabric-chaincode-node>`__ and `Node.js contract API documentation <https://hyperledger.github.io/fabric-chaincode-node/>`__. 	`Node.js contract API <https://github.com/hyperledger/fabric-chaincode-node>`__ と `Node.js contract API documentation <https://hyperledger.github.io/fabric-chaincode-node/>`__ <https://hyperledger.github.io/fabric-chaincode-node/>`__
`Java contract API <https://github.com/hyperledger/fabric-chaincode-java>`__ and `Java contract API documentation <https://hyperledger.github.io/fabric-chaincode-java/>`__. 	`Java contract API <https://github.com/hyperledger/fabric-chaincode-java>`__ と `Java contract API documentation <https://hyperledger.github.io/fabric-chaincode-java/>`__
Hyperledger Fabric offers a number of SDKs to support developing applications in various programming languages.	Hyperledger Fabricは、さまざまなプログラミング言語でのアプリケーション開発をサポートするために、多数のSDKを提供しています。
SDKs are available for Node.js and Java: 	SDKはNode.js用とJava用のものが利用可能です。
`Node.js SDK <https://github.com/hyperledger/fabric-sdk-node>`__ and `Node.js SDK documentation <https://hyperledger.github.io/fabric-sdk-node/>`__. 	`Node.js SDK <https://github.com/hyperledger/fabric-sdk-node>`__ と `Node.js SDK documentation <https://hyperledger.github.io/fabric-sdk-node/>`__
`Java SDK <https://github.com/hyperledger/fabric-gateway-java>`__ and `Java SDK documentation <https://hyperledger.github.io/fabric-gateway-java/>`__. 	`Java SDK <https://github.com/hyperledger/fabric-gateway-java>`__ と `Java SDK documentation <https://hyperledger.github.io/fabric-gateway-java/>`__
Prerequisites for developing with the SDKs can be found in the Node.js SDK `README <https://github.com/hyperledger/fabric-sdk-node#build-and-test>`__ and Java SDK `README <https://github.com/hyperledger/fabric-gateway-java/blob/master/README.md>`__. 	"SDKで開発するための前提条件は、Node.js SDK `README <https://github.com/hyperledger/fabric-sdk-node#build-and-test>`__ と Java SDK `README <https://github.com/hyperledger/fabric-gateway-java/blob/master/README.md>`__ にあります。
"
In addition, there are two more application SDKs that have not yet been officially released (for Python and Go), but they are still available for downloading and testing: 	さらに、まだ正式にリリースされていない(PythonとGo用)2つのアプリケーションSDKがありますが、ダウンロードしてテストすることができます。
Currently, Node.js, Java and Go support the new application programming model delivered in Hyperledger Fabric v1.4.	"現在、Node.js、Java、Goは、Hyperledger Fabric v1.4で提供される新しいアプリケーションプログラミングモデルをサポートしています。
"
Hyperledger Fabric provides an optional `certificate authority service <http://hyperledger-fabric-ca.readthedocs.io/en/latest>`_that you may choose to use to generate the certificates and key material to configure and manage identity in your blockchain network. However, any CA that can generate ECDSA certificates may be used. 	Hyperledger Fabricには、オプションで `認証局サービス <http://hyperledger-fabric-ca.readthedocs.io/en/latest>`_ が用意されています。このサービスを使用すると、ブロックチェーンネットワーク内のアイデンティティを設定および管理するための証明書と鍵を生成できます。
**Audience**: Architects, application and smart contract developers, administrators	**想定読者**: アーキテクト、アプリ/スマートコントラクト開発者、管理者
In this topic, we'll cover:	このトピックでは、以下について説明します:
At its most basic level, a policy is a set of rules that define the structure for how decisions are made and specific outcomes are reached.	最も基本的なレベルでは、ポリシーとは、意思決定がどのように行われ、特定の結果が得られるか、に関する構造を定義する一連のルールです。
To that end, policies typically describe a **who** and a **what**, such as the access or rights that an individual has over an **asset**.	そのために、ポリシーには通常、ある **資産 (asset)** に対する個人のアクセス権や権利のような、**誰が** と **なにを** を記述します。
We can see that policies are used throughout our daily lives to protect assets of value to us, from car rentals, health, our homes, and many more.	レンタカー、健康、住宅など、我々にとって価値のある資産を守るために我々の日常生活を通じてポリシーが使われてることがわかります。
For example, an insurance policy defines the conditions, terms, limits, and expiration under which an insurance payout will be made.	例えば、インシュアランス・ポリシー (保険契約) は、保険の支払いがされる内容条件、期間、制限事項、および有効期限を定義します。
The policy is agreed to by the policy holder and the insurance company, and defines the rights and responsibilities of each party.	そのポリシーは、保険契約者と保険会社によって合意され、各当事者の権利と責任を定義します。
Whereas an insurance policy is put in place for risk management, in Hyperledger Fabric, policies are the mechanism for infrastructure management.	インシュアランス・ポリシーは、リスク管理のために導入されていますが、Hyperledger Fabricでは、ポリシーは、インフラ管理のメカニズムです。
Fabric policies represent how members come to agreement on accepting or rejecting changes to the network, a channel, or a smart contract.	Fabricのポリシーは、ネットワーク、チャネル、スマートコントラクトへの変更を受け入れるか却下するかをメンバーが合意する方法を表します。
Policies are agreed to by the consortium members when a network is originally configured, but they can also be modified as the network evolves.	ポリシーは、ネットワークが最初に設定されるときにコンソーシアムメンバーによって合意されますが、ネットワークの成長に応じて変更されることもあります。
For example, they describe the criteria for adding or removing members from a channel, change how blocks are formed, or specify the number of organizations required to endorse a smart contract.	例えば、ポリシーにはチャネルへのメンバーの追加や削除の基準を記述したり、チャネルのブロックのフォーマットを変更したり、スマートコントラクトをエンドースするのに必要な組織数を指定したりします。
All of these actions are described by a policy which defines who can perform the action.	これらのアクションはすべて、誰がアクションをできるかを定義するポリシーによって記述されます。
Simply put, everything you want to do on a Fabric network is controlled by a policy.	簡単に言うと、Fabricネットワークでやりたいことはすべてポリシーで制御されるということです。
Policies are one of the things that make Hyperledger Fabric different from other blockchains like Ethereum or Bitcoin.	ポリシーは、Hyperledger FabricがEthereumやBitcoinのような他のブロックチェーンとは異なる要素の1つです。
In those systems, transactions can be generated and validated by any node in the network.	これらのシステムでは、トランザクションはネットワークの任意のノードによって生成・検証することが可能です。
The policies that govern the network are fixed at any point in time and can only be changed using the same process that governs the code.	ネットワークを管理するポリシーについては、常時固定されており、コードを管理するのと同じプロセスで変更することができます。
Because Fabric is a permissioned blockchain whose users are recognized by the underlying infrastructure, those users have the ability to decide on the governance of the network before it is launched, and change the governance of a running network.	Fabricは基盤となるインフラによってユーザーが認識される許可型ブロックチェーンであるため、それらのユーザーはネットワークのガバナンスを起動する前に決定し、稼働中のネットワークのカバナンスを変更することができます。
Policies allow members to decide which organizations can access or update a Fabric network, and provide the mechanism to enforce those decisions.	ポリシーは、メンバーがどの組織がFabricネットワークにアクセスしたり更新したりできるかを決定することを可能にし、その決定を強制するメカニズムを提供します。
Policies contain the lists of organizations that have access to a given resource, such as a user or system chaincode.	ポリシーはユーザーチェーンコードやシステムチェーンコードなどの特定のリソースにアクセスできる組織のリストを含みます。
They also specify how many organizations need to agree on a proposal to update a resource, such as a channel or smart contracts.	ポリシーはチャネルやスマートコントラクトなどのリソースを更新するための提案を合意するための必要な組織数も指定します。
Once they are written, policies evaluate the collection of signatures attached to transactions and proposals and validate if the signatures fulfill the governance agreed to by the network.	一度ポリシーが記述されると、ポリシーはトランザクションや提案に添付された署名のコレクションを評価し、署名がポリシーはそのネットワークによって合意されたカバナンスを満たすかどうかを検証します。
Policies are implemented at different levels of a Fabric network.	ポリシーはFabricネットワーク上の様々なレベルで実装されています。
Each policy domain governs different aspects of how a network operates.	各ポリシーのドメインは、ネットワークの運用方法の様々な側面を管理します。
A visual representation of the Fabric policy hierarchy.	Fabricポリシー階層の視覚的表現
Every network begins with an ordering **system channel**.	すべてのネットワークは、オーダリング用の **システムチャネル** を用いて開始されます。
There must be exactly one ordering system channel for an ordering service, and it is the first channel to be created.	オーダリングサービスのためには、システムチャネルは1つだけ必要であり、このチャネルは最初に生成されるチャネルです。
The system channel also contains the organizations who are the members of the ordering service (ordering organizations) and those that are on the networks to transact (consortium organizations).	システムチャネルにはオーダリングサービスのメンバーとなる組織 (オーダリング組織, ordering organizations)、取引を行うネットワーク上にある組織 (コンソーシアム組織、consortium organizations)も含まれます。
The policies in the ordering system channel configuration blocks govern the consensus used by the ordering service and define how new blocks are created.	オーダリング用のシステムチャネル設定ブロック内のポリシーはオーダリングサービスで使われる合意形成を管理し、新しいブロックの生成方法を定義します。
The system channel also governs which members of the consortium are allowed to create new channels.	また、システムチャネルはコンソーシアムのどのメンバーが新しいチャネルを生成できるかも管理します。
Application _channels_ are used to provide a private communication mechanism between organizations in the consortium.	アプリケーション _チャネル_ はコンソーシアム内の組織の間でプライベートなやり取りをするメカニズムを提供するために使用されます。
The policies in an application channel govern the ability to add or remove members from the channel.	アプリケーションチャネルのポリシーは、チャネルからメンバーを追加または削除する機能を管理します。
Application channels also govern which organizations are required to approve a chaincode before the chaincode is defined and committed to a channel using the Fabric chaincode lifecycle.	アプリケーションチャネルは、Fabricのチェーンコードライフサイクルを使ってチャネルにチェーンコードが定義・コミットされる前に、そのチェーンコードをどの組織が承認する必要があるかも管理します。
When an application channel is initially created, it inherits all the ordering service parameters from the orderer system channel by default.	アプリケーションチャネルは最初に生成されるときに、デフォルトではシステムチャネルからすべてのオーダリングサービスのパラメータを継承します。
However, those parameters (and the policies governing them) can be customized in each channel.	しかし、これらのパラメータ (およびそれらを管理するポリシー) は、チャネルごとにカスタマイズ可能です。
Network administrators will be especially interested in the Fabric use of ACLs, which provide the ability to configure access to resources by associating those resources with existing policies.	ネットワーク管理者はFabricのACLの使用に特に関心があるでしょう。ACLはリソースを既存のポリシーに関連付けることで、リソースへのアクセスを設定する機能を提供します。
These "resources" could be functions on system chaincode (e.g., "GetBlockByNumber" on the "qscc" system chaincode) or other resources (e.g.,who can receive Block events).	これらの「リソース」は、システムチェーンコードの機能 (例えば、「qscc」の「GetBlockByNumber」) あるいはその他のリソース (例えば、誰がブロックイベントを受信できるか) である可能性があります。
ACLs refer to policies defined in an application channel configuration and extends them to control additional resources.	ACLはアプリケーションチャネル設定の中で定義されたポリシーを参照し、それらを拡張して追加のリソースを制御します。
The default set of Fabric ACLs is visible in the `configtx.yaml` file under the `Application: &ApplicationDefaults` section but they can and should be overridden in a production environment.	FabricのACLのデフォルトセットは `configtx.yaml` ファイル内の `Application: &ApplicationDefaults` セクションに記述されますが、本番環境では、それらは上書き可能であり、上書きするべきです。
The list of resources named in `configtx.yaml` is the complete set of all internal resources currently defined by Fabric.	`configtx.yaml` で指定されたリソースのリストは、Fabricによって現在定義されているすべての内部リソースの完全なセットです。
In that file, ACLs are expressed using the following format:	このファイル内では、ACLは以下のフォーマットで表現されます。
ACL policy for chaincode to chaincode invocation	チェーンコード間呼び出しのためのACLポリシー
Where `peer/ChaincodeToChaincode` represents the resource being secured and `/Channel/Application/Readers` refers to the policy which must be satisfied for the associated transaction to be considered valid.	ここで、 `peer/ChaincodeToChaincode` は保護されているリソースを表し、`/Channel/Application/Readers` は関連するトランザクションが有効とみなされるために満たす必要があるポリシーを表します。
For a deeper dive into ACLS, refer to the topic in the Operations Guide on [ACLs](../access_control.html).	ACLの詳細については、運用ガイドの[ACLs](../access_control.html)を参照してください。
Every smart contract inside a chaincode package has an endorsement policy that specifies how many peers belonging to different channel members need to execute and validate a transaction against a given smart contract in order for the transaction to be considered valid.	チェーンコードパッケージ内のすべてのスマートコントラクトは、トランザクションが有効とみなされるために、特定のスマートコントラクトに対してそのトランザクションを実行および検証する必要がある異なるチャネルメンバー組織に属しているピアの数を指定する、エンドースメントポリシーを持ちます。
Hence, the endorsement policies define the organizations (through their peers) who must “endorse” (i.e., approve of) the execution of a proposal.	エンドースメントポリシーは、提案の実行を (ピアを通じて)「エンドース」(つまり、承認) する必要がある組織を定義します。
There is one last type of policy that is crucial to how policies work in Fabric, the `Modification policy`.	最後の種類のポリシーとして、Fabricの動作に重要なものがあります。それが、「変更ポリシー (`Modification policy`) 」です。
Modification policies specify the group of identities required to sign (approve) any configuration _update_.	変更ポリシーは、任意の設定 _更新_ の署名 (承認) に必要なアイデンティティのグループを指定します。
It is the policy that defines how the policy is updated.	ポリシー更新方法を定義するポリシーです。
Thus, each channel configuration element includes a reference to a policy which governs its modification.	つまり、各チャネル設定要素には、その変更を管理するポリシーへの参照が含まれています。
While Fabric policies are flexible and can be configured to meet the needs of a network, the policy structure naturally leads to a division between the domains governed by either the Ordering Service organizations or the members of the consortium.	Fabricのポリシーは柔軟であり、ネットワークのニーズに合わせて設定することができる一方、ポリシーの構造は当然、オーダリングサービスの組織、あるいは、コンソーシアムメンバーが管理するドメイン間の分割につながります。
In the following diagram you can see how the default policies implement control over the Fabric policy domains below.	次の図では、デフォルトポリシーがどのように下層のFabricポリシードメインに対する制御を実装しているかを示しています。
A more detailed look at the policy domains governed by the Orderer organizations and consortium organizations.	オーダリング組織とコンソーシアム組織が管理するポリシードメインの詳細
A fully functional Fabric network can feature many organizations with different responsibilities.	完全に機能するFabricネットワークは異なる責任を持つ多くの組織を特色とすることができます。
The domains provide the ability to extend different privileges and roles to different organizations by allowing the founders of the ordering service the ability to establish the initial rules and membership of the consortium.	ドメインは、オーダリングサービスの創設者がコンソーシアムの初期ルールやメンバーシップを設立可能にできるようにすることで、異なる権限や役割を異なる組織に拡張する機能を提供します。
They also allow the organizations that join the consortium to create private application channels, govern their own business logic, and restrict access to the data that is put on the network.	また、ドメインは、コンソーシアムに参加する組織がプライベートアプリケーションチャネルを生成し、その組織のビジネスロジックを管理し、ネットワーク上に配置されるデータにアクセス制限できるようにします。
The system channel configuration and a portion of each application channel configuration provides the ordering organizations control over which organizations are members of the consortium, how blocks are delivered to channels, and the consensus mechanism used by the nodes of the ordering service.	システムチャネル設定と各アプリケーションチャネル設定の一部により、オーダリング組織は、コンソーシアムのメンバーである組織、ブロックがチャネルに配信される方法、オーダリングサービスのノードによって使われる合意形成機構を制御できます。
The system channel configuration provides members of the consortium the ability to create channels.	システムチャネル設定によって、コンソーシアムのメンバーがチャネルを生成することを可能とします。
Application channels and ACLs are the mechanism that consortium organizations use to add or remove members from a channel and restrict access to data and smart contracts on a channel.	アプリケーションチャネルとACLは、コンソーシアム組織がチャネルのメンバーを追加または削除し、チャネル上のデータとスマートコントラクトへのアクセスを制限するために使用するメカニズムです。
If you want to change anything in Fabric, the policy associated with the resource describes **who** needs to approve it, either with an explicit sign off from individuals, or an implicit sign off by a group.	Fabricで何かを変更したい場合、そのリソースに関連付けられたポリシーは、個別メンバーからの明示的な署名、あるいはグループからの暗黙的な署名のいずれかによって、**誰** がそれを承認する必要があるかを記述しています。
In the insurance domain, an explicit sign off could be a single member of the homeowners insurance agents group.	保険ドメインでは、明示的な承認は、住宅オーナー保険代理店グループのメンバーの一人がありえます。
And an implicit sign off would be analogous to requiring approval from a majority of the managerial members of the homeowners insurance group.	そして、暗黙的な承認は、住宅オーナー保険グループの管理メンバーの過半数の承認を必要とすることに類似しています。
This is particularly useful because the members of that group can change over time without requiring that the policy be updated.	ポリシーを更新する必要なしに、そのグループのメンバーを時間の経過とともに変更できるため、暗黙的な承認は特に便利です。
In Hyperledger Fabric, explicit sign offs in policies are expressed using the `Signature` syntax and implicit sign offs use the `ImplicitMeta` syntax.	Hyperledger Fabricでは、明示的な承認のためには `Signature` シンタックスが、暗黙的な承認のためには`ImplicitMeta` シンタックスが使われます。
`Signature` policies define specific types of users who must sign in order for a policy to be satisfied such as `OR('Org1.peer', 'Org2.peer')`.	`Signature` ポリシーは、`OR('Org1.peer', 'Org2.peer')` など、ポリシーが満たされるために署名する必要がある特定のタイプのユーザーを定義します。
These policies are considered the most versatile because they allow for the construction of extremely specific rules like: “An admin of org A and 2 other admins, or 5 of 6 organization admins”.	これらのポリシーは、「組織Aの管理者と他の2組織の管理者、または6組織のうち5組織の管理者」のような非常に具体的なルールの構築を可能にするため、最も用途が広いと考えられています。
The syntax supports arbitrary combinations of `AND`, `OR` and `NOutOf`.	構文は、 `AND` 、 `OR` 、 `NOutOf` の任意の組み合わせをサポートしています。
For example, a policy can be easily expressed by using `AND('Org1.member', 'Org2.member')`	たとえば、 `AND('Org1.member', 'Org2.member')` のような形でポリシーを簡単に表現できます。
which means that a signature from at least one member in Org1 AND one member in Org2 is required for the policy to be satisfied.	これは、Org1の少なくとも1名のメンバーとOrg2の1名のメンバーからの署名がポリシーを満たすために必要であることを意味します。
`ImplicitMeta` policies are only valid in the context of channel configuration which is based on a tiered hierarchy of policies in a configuration tree.	`ImplicitMeta` ポリシーは、設定ツリー内のポリシーの階層に基づいたチャネル設定のコンテキストでのみ有効です。
ImplicitMeta policies aggregate the result of policies deeper in the configuration tree that are ultimately defined by Signature policies.	ImplicitMetaポリシーは、最終的にSignatureポリシーによって定義された設定ツリーのより深いポリシーの結果を集約します。
They are `Implicit` because they are constructed implicitly based on the current organizations in the channel configuration, and they are `Meta` because their evaluation is not against specific MSP principals, but rather against other sub-policies below them in the configuration tree.	ImplicitMetaポリシーはチャネル設定の現在の組織に基づいて暗黙的に構築されているため `Implicit` (暗黙的) と呼ばれ、それらの評価は特定のMSPプリンシパルに対してではなく、設定ツリー内でそれらよりも下にある他のサブポリシーに対して行われるため `Meta` と呼ばれます。
The following diagram illustrates the tiered policy structure for an application channel and shows how the `ImplicitMeta` channel configuration admins policy, named `/Channel/Admins`, is resolved when the sub-policies named `Admins` below it in the configuration hierarchy are satisfied where each check mark represents that the conditions of the sub-policy were satisfied.	次の図は、アプリケーションチャネルの階層型ポリシー構造を示し、 `/Channel/Admins` という名前の `ImplicitMeta`チャネル設定ポリシーが、設定階層でその下にある `Admins` というサブポリシーが満たされたときにどのように解決されるかを示しています。各チェックマークはサブポリシーの条件が満たされたことを表しています。
As you can see in the diagram above, `ImplicitMeta` policies, Type = 3, use a different syntax, `"<ANY|ALL|MAJORITY> <SubPolicyName>"`,	上記の図を見るとわかるように、 `ImplicitMeta` ポリシーは、Type = 3、異なるシンタックスである `"<ANY|ALL|MAJORITY> <SubPolicyName>"` を使います。
for example: The diagram shows a sub-policy `Admins`, which refers to all the `Admins` policy below it in the configuration tree.	例えば、以下の通りです。この図では この設定ツリー以下のすべての `Admins` ポリシーを参照する `Admins` サブポリシーが示されています。
You can create your own sub-policies and name them whatever you want and then define them in each of your organizations.	管理者は、独自のサブポリシーを作成し、好きな名前を付けて、各組織でそれらを定義できます。
As mentioned above, a key benefit of an `ImplicitMeta` policy such as `MAJORITY Admins` is that when you add a new admin organization to the channel, you do not have to update the channel policy.	前述の通り、 `MAJORITY Admins` などの `ImplicitMeta` ポリシーの主な利点は、新しい管理組織をチャネルに追加するときに、チャネルポリシーを更新する必要がないことです。
Therefore `ImplicitMeta` policies are considered to be more flexible as the consortium members change.	従って、 `ImplicitMeta` ポリシーは、コンソーシアムのメンバーが変わったときにも、より柔軟であると考えられます。
The consortium on the orderer can change as new members are added or an existing member leaves with the consortium members agreeing to the changes, but no policy updates are required.	Ordererに関するコンソーシアムでは、新しいメンバーを追加したり、既存のメンバーが退会したりする場合に、コンソーシアムのメンバーがその変更に同意することで変更できますが、その際にポリシーの更新自体は必要ありません。
Recall that `ImplicitMeta` policies ultimately resolve the `Signature` sub-policies underneath them in the configuration tree as the diagram shows.	図が示すように、 `ImplicitMeta` ポリシーは、設定ツリーでそれらの下にある `Signature` サブポリシーを最終的に解決することを思い出してください。
You can also define an application level implicit policy to operate across organizations, in a channel for example, and either require that ANY of them are satisfied, that ALL are satisfied, or that a MAJORITY are satisfied.	また、アプリケーションレベルの `ImplicitMeta` ポリシーを定義して、たとえばチャネルなどの組織横断での操作を行うことができます。ANY、ALL、またはMAJORITYが満たされていることを要求することが可能です。
This format lends itself to much better, more natural defaults, so that each organization can decide what it means for a valid endorsement.	このフォーマットは、より優れた、より自然なデフォルト設定として適しているため、各組織が有効なエンドースメントの意味を決めることができます。
Further granularity and control can be achieved if you include [`NodeOUs`](msp.html#organizational-units) in your organization definition.	組織定義に [`NodeOUs`](msp.html#organizational-units) を含めると、さらに細かく制御できます。
Organization Units (OUs) are defined in the Fabric CA client configuration file and can be associated with an identity when it is created.	組織単位 (OU) は、Fabric CAのクライアント設定ファイルで定義されており、アイデンティ作成時に関連付けることができます。
In Fabric, `NodeOUs` provide a way to classify identities in a digital certificate hierarchy.	Fabricでは、 `NodeOUs` はデジタル証明書階層のアイデンティを分類する方法を提供します。
For instance, an organization having specific `NodeOUs` enabled could require that a 'peer' sign for it to be a valid endorsement, whereas an organization without any might simply require that any member can sign.	たとえば、特定の `NodeOUs` が有効になっている組織では、その「ピア」署名が有効な承認であることを要求できますが、何もない組織では、任意のメンバー署名を要求するだけかもしれません。
Understanding policies begins with examining the `configtx.yaml` where the channel policies are defined.	ポリシーを理解するには、チャネルポリシーが定義されている `configtx.yaml` を調べることから始めます。
We can use the `configtx.yaml` file in the Fabric test network to see examples of both policy syntax types.	Fabricテストネットワーク (test-network) 内の `configtx.yaml` ファイルを使用して、両方のポリシー構文タイプの例を確認できます。
We are going to examine the configtx.yaml file used by the [fabric-samples/test-network](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/test-network/configtx/configtx.yaml) sample.	[fabric-samples/test-network](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/test-network/configtx/configtx.yaml) サンプルで使われる configtx.yaml ファイルを見ていきます。
The first section of the file defines the organizations of the network.	ファイルの最初のセクションでは、ネットワークの組織を定義します。
Inside each organization definition are the default policies for that organization, `Readers`, `Writers`, `Admins`, and `Endorsement`, although you can name your policies anything you want.	各組織の定義の内部には、その組織のデフォルトのポリシーである `Readers` 、 ` Writers` 、 `Admins` 、および `Endorsement` がありますが、ポリシーには任意の名前を付けることができます。
Each policy has a `Type` which describes how the policy is expressed (`Signature` or `ImplicitMeta`) and a `Rule`.	各ポリシーには、ポリシーの表現方法 ( `Signature` または `ImplicitMeta` ) を示す `Type` と `Rule` があります。
The test network example below shows the Org1 organization definition in the system channel, where the policy `Type` is `Signature` and the endorsement policy rule is defined as `"OR('Org1MSP.peer')"`.	以下のテストネットワークの例は、システムチャネルのOrg1の組織定義を示しています。ここで、ポリシーの `Type` は `Signature` であり、エンドースメントポリシールールは`"OR('Org1MSP.peer')"` として定義されています。
This policy specifies that a peer that is a member of `Org1MSP` is required to sign.	このポリシーは、 `Org1MSP` のメンバーであるピアが署名する必要があることを指定します。
It is these signature policies that become the sub-policies that the ImplicitMeta policies point to.	ImplicitMetaポリシーが指すサブポリシーになるのは、これらのSignatureポリシーです。
Click here to see an example of an organization defined with signature policies	Signatureポリシーを使って定義された組織の例を見るにはこちらをクリックして下さい
DefaultOrg defines the organization which is used in the sample config of the fabric.git development environment	DefaultOrgは、fabric.git開発環境のsampleconfig内で使われる組織を定義します。
ID to load the MSP definition as MSPDir: crypto-config/peerOrganizations/org1.example.com/msp	MSP定義をロードするID Policiesでは、設定ツリーのこのレベルにおけるポリシーのセットを定義します。
Policies defines the set of policies at this level of the config tree	組織ポリシーの場合、その正規化パス (canonical path) は通常以下の通りです。
The next example shows the `ImplicitMeta` policy type used in the `Application` section of the `configtx.yaml`.	次の例は、 `configtx.yaml` の `Application` セクションで使用される `ImplicitMeta` ポリシータイプを示しています。
These set of policies lie on the `/Channel/Application/` path.	これらのポリシーのセットは、 `/Channel/Application/` パスにあります。
If you use the default set of Fabric ACLs, these policies define the behavior of many important features of application channels, such as who can query the channel ledger, invoke a chaincode, or update a channel config.	FabricのACLのデフォルトセットを使用する場合、これらのポリシーは、台帳へのクエリ、チェーンコードの呼び出し、チャネル設定の更新など、アプリケーションチャネルの多くの重要な機能の動作を定義します。
These policies point to the sub-policies defined for each organization.	これらのポリシーは、各組織に定義されたサブポリシーを参照します。
The Org1 defined in the section above contains `Reader`, `Writer`, and `Admin` sub-policies that are evaluated by the `Reader`, `Writer`, and `Admin` `ImplicitMeta` policies in the `Application` section.	上記のセクションで定義されたOrg1には、 `Application` セクションの `Reader` 、 `Writer` 、および `Admin`の `ImplicitMeta` ポリシーによって評価される`Reader`、 `Writer`、および `Admin` サブポリシーが含まれています。
Because the test network is built with the default policies, you can use the example Org1 to query the channel ledger, invoke a chaincode, and approve channel updates for any test network channel that you create.	テストネットワークはデフォルトのポリシーで使って構築されているため、サンプルのOrg1を使用してチャネル上の台帳をクエリし、チェーンコードを呼び出し、作成したテストネットワークチャネルのチャネル更新を承認できます。
Click here to see an example of ImplicitMeta policies	ImplicitMetaポリシーの例を見るにはこちらをクリックしてください
This section defines the values to encode into a config transaction or genesis block for application related parameters Application: &ApplicationDefaults	このセクションでは、アプリケーション関連パラメータに関するコンフィグトランザクションあるいはジェネシスブロックにエンコードする値を定義します
Organizations is the list of orgs which are defined as participants on the application side of the network	Organizationsは、ネットワークのアプリケーション側の参加者として定義されている組織の一覧です
Policies defines the set of policies at this level of the config tree	Policiesは、設定ツリーのこのレベルでのポリシーのセットを定義します
For Application policies, their canonical path is	アプリケーションポリシーの場合、正規化パス (canonical path) は以下の通りです
In the Fabric 2.0 release, a new chaincode lifecycle process was introduced, whereby a more democratic process is used to govern chaincode on the network.	Fabric 2.0リリースでは、新しいチェーンコードライフサイクルプロセスが導入され、より民主的なプロセスを使用してネットワーク上のチェーンコードを管理しています。
The new process allows multiple organizations to vote on how a chaincode will be operated before it can be used on a channel.	新しいプロセスでは、複数の組織が、チェーンコードをチャネルで使用する前に、どのように運用するかを投票することができます。
This is significant because it is the combination of this new lifecycle process and the policies that are specified during that process that dictate the security across the network.	この新しいライフサイクルプロセスとそのプロセス中に指定されるポリシーの組み合わせは、ネットワーク全体のセキュリティを決定するため、重要な意味を持ちます。
More details on the flow are available in the [Fabric chaincode lifecycle](../chaincode_lifecycle.html) concept topic,	そのフローの詳細については、[Fabric chaincode lifecycle](../chaincode_lifecycle.html) コンセプトトピックをご覧ください。
but for purposes of this topic you should understand how policies are used in this flow.	ただし、本トピックの目的のために、このフローでのポリシーの使用方法を理解する必要があります。
The new flow includes two steps where policies are specified: when chaincode is **approved** by organization members, and when it is **committed** to the channel.	新しいフローには、ポリシーを指定する2つのステップが含まれます。それは、 **承認 (approved)** されたときと、チャネルに **コミット (committed)** されたときです。
The `Application` section of  the `configtx.yaml` file includes the default chaincode lifecycle endorsement policy.	`configtx.yaml` ファイルの `Application` セクション は、デフォルトのチェーンコードライフサイクルエンドースメントポリシーを含みます。
In a production environment you would customize this definition for your own use case.	本番環境では、ユースケースに応じて定義をカスタマイズする必要があるかもしれません。
This section defines the values to encode into a config transaction or genesis block for application related parameters	このセクションでは、アプリケーション関連パラメータに関するコンフィグトランザクションあるいはジェネシスブロックにエンコードする値を定義します
Organizations is the list of orgs which are defined as participants on the application side of the network 	Organizationsは、ネットワークのアプリケーション側の参加者として定義されている組織の一覧です
Policies defines the set of policies at this level of the config tree	Policiesは、設定ツリーのこのレベルでのポリシーのセットを定義します
For Application policies, their canonical path is	アプリケーションポリシーの場合、正規化パス (canonical path) は以下の通りです
The `LifecycleEndorsement` policy governs who needs to _approve a chaincode definition_.	`LifecycleEndorsement` ポリシーは誰が _チェーンコード定義を承認_ する必要があるか管理します。
The `Endorsement` policy is the _default endorsement policy for a chaincode_.	`Endorsement` ポリシーは、 _チェーンコードのデフォルトエンドースメントポリシー_ です。
More on this below.	これについては以下で詳しく説明します。
The endorsement policy is specified for a **chaincode** when it is approved and committed to the channel using the Fabric chaincode lifecycle (that is, one endorsement policy covers all of the state associated with a chaincode).	エンドースメントポリシーは、Fabricチェーンコードライフサイクルを使用して、承認され (approved)、チャネルにコミットされる (committed) ときに**チェーンコード** に指定されます (つまり、1つのエンドースメントポリシーがチェーンコードに関連付けられたすべてのステートをカバーします) 。
The endorsement policy can be specified either by reference to an endorsement policy defined in the channel configuration or by explicitly specifying a Signature policy.	エンドースメントポリシーは、チャネル設定で定義されているエンドースメントポリシーを参照するか、Signatureポリシーを明示的に指定することによって指定できます。
If an endorsement policy is not explicitly specified during the approval step, the default `Endorsement` policy `"MAJORITY Endorsement"` is used which means that a majority of the peers belonging to the different channel members (organizations) need to execute and validate a transaction against the chaincode in order for the transaction to be considered valid.	承認 (approval) ステップ中にエンドースメントポリシーが明示的に指定されていない場合、デフォルト `Endorsement` ポリシー `"MAJORITY Endorsement"` が使用されます。これは、チェーンコードに対するトランザクションが有効と見なされるために、異なるチャネルメンバー (組織) に属するピアの過半数がそのトランザクションを実行して検証する必要があることを意味します。
This default policy allows organizations that join the channel to become automatically added to the chaincode endorsement policy.	このデフォルトポリシーにより、チャネルに組織が参加するとその組織が自動的にチェーンコードエンドースメントポリシーに追加されるようになります。
If you don't want to use the default endorsement policy, use the Signature policy format to specify a more complex endorsement policy (such as requiring that a chaincode be endorsed by one organization, and then one of the other organizations on the channel).	デフォルトのエンドースメントポリシーを使用しない場合は、Signatureポリシー形式を使用して、より複雑なエンドースメントポリシーを指定します(たとえば、チェーンコードをある特定の1つの組織が承認し、さらにチャネル上の他の組織の1つが承認することを要求するなど)。
Signature policies also allow you to include `principals` which are simply a way of matching an identity to a role.	Signatureポリシーを使用すると、アイデンティティをロールにマッチさせるための方法である `principals` (プリンシパル) を含めることもできます。
Principals are just like user IDs or group IDs, but they are more versatile because they can include a wide range of properties of an actor’s identity, such as the actor’s organization, organizational unit, role or even the actor’s specific identity.	プリンシパルはユーザーIDまたはグループIDに似ていますが、アクターの組織、組織単位 (OU)、ロール、特定のアイデンティティなど、アクターのアイデンティティの幅広いプロパティを含めることができるため、より用途が広くなっています。
When we talk about principals, they are the properties which determine their permissions.	プリンシパルについて語るとき、それらはプリンシパルの権限を決定するプロパティです。
Principals are described as 'MSP.ROLE', where `MSP` represents the required MSP ID (the organization),  and `ROLE` represents one of the four accepted roles: Member, Admin, Client, and Peer.	プリンシパルは「MSP.ROLE」として記述されます。 `MSP` は必要なMSP ID (組織) を表し、`ROLE` は4つの許可されたロール (メンバー、管理者、クライアント、ピア) の1つを表します。
A role is associated to an identity when a user enrolls with a CA.	ユーザーをCAを用いてエンロールすると、ロールがアイデンティティに関連付けられます。
You can customize the list of roles available on your Fabric CA.	Fabric CAで使用可能なロールのリストはカスタマイズ可能です。
Some examples of valid principals are:	有効なプリンシパルの例としては、以下のようなものがあります:
'Org0.Admin': an administrator of the Org0 MSP	'Org0.Admin': Org0 MSPの管理者
'Org1.Member': a member of the Org1 MSP	'Org1.Member': Org1 MSPのメンバー
'Org1.Client': a client of the Org1 MSP	'Org1.Client': Org1 MSPのクライアント
'Org1.Peer': a peer of the Org1 MSP	'Org1.Peer': Org1 MSPのピア
'OrdererOrg.Orderer': an orderer in the OrdererOrg MSP	'OrdererOrg.Orderer': OrdererOrg MSPのOrderer
There are cases where it may be necessary for a particular state (a particular key-value pair, in other words) to have a different endorsement policy.	特定のステート (言い換えると、特定のKey-Valueペア) に別のエンドースメントポリシーしたい場合があります。
This **state-based endorsement** allows the default chaincode-level endorsement policies to be overridden by a different policy for the specified keys.	**ステートベースエンドースメント** は、デフォルトのチェーンコードレベルのエンドースメントポリシーを、特定のKeyのために別のエンドースメントポリシーで上書きするを可能とします。
For a deeper dive on how to write an endorsement policy refer to the topic on [Endorsement policies](../endorsement-policies.html) in the Operations Guide.	エンドースメントポリシーの記述方法の詳細については、オペレーションガイドの [Endorsement policies](../endorsement-policies.html) に関するトピックを参照してください。
**Note:**  Policies work differently depending on which version of Fabric you are   using:	**注:**  ポリシーは、使用しているFabricのバージョンによって動作が異なります。
In Fabric releases prior to 2.0, chaincode endorsement policies can be   updated during chaincode instantiation or by using the chaincode lifecycle   commands.	2.0より前のFabricリリースでは、チェーンコードのエンドースメントポリシーは、チェーンコードのインスタンス化中、またはチェーンコードのライフサイクルコマンドを使用して更新できます。
If not specified at instantiation time, the endorsement policy defaults to “any member of the organizations in the channel”.	  インスタンス化時に指定されていない場合、エンドースメントポリシーはデフォルトで「チャネル内の組織の任意のメンバー」になります。
For example,   a channel with “Org1” and “Org2” would have a default endorsement policy of   “OR(‘Org1.member’, ‘Org2.member’)”.	たとえば、「Org1」と「Org2」を持つチャンネルのデフォルトのエンドースメントポリシーは「OR(‘Org1.member’, ‘Org2.member’)」です。
Starting with Fabric 2.0, Fabric introduced a new chaincode  lifecycle process that allows multiple organizations to agree on how a   chaincode will be operated before it can be used on a channel.	Fabric 2.0以降では、Fabricは新しいチェーンコードライフサイクルプロセスを導入しました。これにより、チャネルで使用する前にチェーンコードをどのように運用するかについて複数の組織が合意することができます。
The new process   requires that organizations agree to the parameters that define a chaincode,   such as name, version, and the chaincode endorsement policy.	新しいプロセスでは、名前、バージョン、チェーンコードのエンドースメントポリシーなど、チェーンコードを定義するパラメーターに組織が同意する必要があります。
Hyperledger Fabric includes default policies which are useful for getting started, developing, and testing your blockchain, but they are meant to be customized in a production environment.	Hyperledger Fabricには、ブロックチェーンの開始、開発、テストに役立つデフォルトポリシーが含まれていますが、本番環境でカスタマイズされることを想定しています。
You should be aware of the default policies in the `configtx.yaml` file.	`configtx.yaml` ファイルのデフォルトポリシーに注意する必要があります。
Channel configuration policies can be extended with arbitrary verbs, beyond the default `Readers, Writers, Admins` in `configtx.yaml`.	チャネル設定ポリシーは、 `configtx.yaml` のデフォルトの `Readers` 、 `Writers` 、 `Admins` を超えて、任意の動詞で拡張できます。
The orderer system and application channels are overridden by issuing a config update when you override the default policies by editing the `configtx.yaml` for the orderer system channel or the `configtx.yaml` for a specific channel.	Orderer用のシステムチャネルとアプリケーションチャネルは、Orderer用のシステムチャネルの `configtx.yaml` または特定のチャネルの `configtx.yaml` を編集して、デフォルトポリシーを上書きするときに、config updateを発行することで上書きされます。
See the topic on [Updating a channel configuration](../config_update.html#updating-a-channel-configuration) for more information.	より詳細な情報は、トピック[Updating a channel configuration](../config_update.html#updating-a-channel-configuration) を参照してください。
MSP Identity Validity Rules	MSPアイデンティ検証ルール
As mentioned in MSP description, MSPs may be configured with a set of root certificate authorities (rCAs), and optionally a set of intermediate certificate authorities (iCAs).	MSPの説明でも述べた通り、MSPはルート認証局 (rCA) と、オプショナルな中間認証局 (iCA) のセットで構成されます。
An MSP's iCA certificates must be signed by **exactly one** of the MSP's rCAs or iCAs.	MSPのiCA証明書はそのMSPのrCAまたはiCAのうち **いずれか1つのみ** によって、署名されていなければなりません。
An MSP's configuration may contain a certificate revocation list, or CRL.	MSPの設定には証明書失効リスト (Certificate Revocation List, 略称CRL) が含まれる場合があります。
If any of the MSP's root certificate authorities are listed in the CRL, then the MSP's configuration must not include any iCA that is also included in the CRL, or the MSP setup will fail.	もしMSPのルート認証局のいずれかがCRLにリストされている場合には、MSPの設定にそのCRLにも含まれているiCAを含めないで下さい。含めると、MSPのセットアップが失敗します。
Each rCA is the root of a certification tree.	各rCAは証明書ツリーのルートです。
That is, each rCA may be the signer of the certificates of one or more iCAs, and these iCAs will be the signer either of other iCAs or of user-certificates.	つまり、各rCAは一つ以上のiCAの証明書の署名者であり、これらのiCAは他のiCAまたはユーザ証明書の署名者になります。
Here are a few examples::	以下にいくつかの例を示します::
The default MSP implementation accepts as valid identities X.509 certificates signed by the appropriate authorities.	デフォルトのMSP実装では、適切な認証局によって署名されたX509証明書を有効なアイデンティティとして受け入れます。
In the diagram above, only certificates signed by iCA11, iCA12, iCA2, iCA3, and rCA3 will be considered valid.	上の図では、iCA11、iCA12、iCA2、iCA3そしてrCA3によって署名された証明書のみが有効とみなされます。
Certificates signed by internal nodes will be rejected.	内部 (中間) ノードによって署名された証明書は拒否されます。
Notice that the validity of a certificate is also affected, in a similar way, if one or more organizational units are specified in the MSP configuration.	MSP設定で1つ以上の組織単位 (OU) が指定されている場合、証明書の有効性も同様に影響を受けることに注意してください。
Recall that an organizational unit is specified in an MSP configuration as a pair of two values, say (parent-cert, ou-string) representing the certificate authority that certifies that organizational unit, and the actual organizational unit identifier, respectively.	MSP設定では、組織単位が、その組織単位を証明する認証局と実際の組織単位の識別子とを表す2つの値のペア (親CAによって署名された証明書 (parent-cert)、OU文字列 (ou-string)) でそれぞれ指定されることに注意してください。
If a certificate C is signed by an iCA or rCA for which an organizational unit has been specified in the MSP configuration, then C is considered valid if, among other requirements, it includes ou-string as part of its OU field.	もし、MSP設定で指定されるある組織単位のための証明書Cが、あるiCAまたはrCAによって署名されている場合、その他の要件の中で、CがOUフィールドの一部としてOU文字列を含んでいるときに、Cは有効とみなされます。
Licensed under Creative Commons Attribution 4.0 International License	Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/	https://creativecommons.org/licenses/by/4.0/
In general terms, a blockchain is an immutable transaction ledger, maintained within a distributed network of peer nodes.	一般的に、ブロックチェーンはイミュータブルなトランザクションの台帳であり、複数のピアノードからなる分散ネットワークで管理されるものです。
These nodes each maintain a copy of the ledger by applying transactions that have been validated by a consensus protocol, grouped into blocks that include a hash that bind each block to the preceding block.	トランザクションは、ある合意形成プロトコルに従って検証され、ブロックにまとめられます。各ノードは、それぞれが持つ台帳のコピーに対して、これらのトランザクションを適用していくことで管理しています。なお、各ブロックは、直前のブロックと紐づけるためにハッシュ値を含んでいます。
The first and most widely recognized application of blockchain is the [Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) cryptocurrency, though others have followed in its footsteps.	ブロックチェーンアプリケーションの中で、最初でかつ最もよく知られているものは、暗号資産(暗号通貨)である[Bitcoin](https://en.wikipedia.org/wiki/Bitcoin) です。
Ethereum, an alternative cryptocurrency, took a different approach, integrating many of the same characteristics as Bitcoin but adding smart contracts to create a platform for distributed applications.	他の例もこれの後を継いでいますが、暗号資産のEthereumは異なるアプローチをとっており、新しくスマートコントラクトと、Bitcoin同様の特徴をあわせもつことで、分散アプリケーションのプラットフォームとなりました。
Bitcoin and Ethereum fall into a class of blockchain that we would classify as public permissionless blockchain technology.	BitcoinとEthereumは、パブリック・パーミッションレスブロックチェーン技術というカテゴリに分類されます。
Basically, these are public networks, open to anyone, where participants interact anonymously.	これらは、誰でもアクセスできる、パブリックなネットワークで、参加者が匿名でやりとりすることができます。
As the popularity of Bitcoin, Ethereum and a few other derivative technologies grew, interest in applying the underlying technology of the blockchain, distributed ledger and distributed application platform to more innovative enterprise use cases also grew.	BitcoinやEthereum、またそこから派生した技術が発展するに従って、その元となる技術であるブロックチェーン、分散台帳、分散アプリケーションプラットフォームの技術を より革新的なエンタープライズ向けに適用しようという動きもでてきました。
However, many enterprise use cases require performance characteristics that the permissionless blockchain technologies are unable (presently) to deliver.	しかし、多くのエンタープライズ向けのユースケースでは、(今のところ)満たすことが不可能な性能特性が要件になっています。
In addition, in many use cases, the identity of the participants is a hard requirement, such as in the case of financial transactions where Know-Your-Customer (KYC) and Anti-Money Laundering (AML) regulations must be followed.	さらに、多くのユースケースでは、参加者の素性が明らかであることが強い要件となることがあります。例えば、”Know Your Customer" (KYC) や アンチマネーロンダリング (AML) といった規制に従わなければならない金融系のトランザクションです。
For enterprise use, we need to consider the following requirements:	エンタープライズでの利用にあっては、下記の要件について考慮しなければなりません。
Participants must be identified/identifiable	参加者が特定されている/特定可能であること
Networks need to be permissioned	ネットワークが許可型であること
High transaction throughput performance	高いトランザクション・スループット性能
Low latency of transaction confirmation	低レイテンシでトランザクションが確定すること
Privacy and confidentiality of transactions and data pertaining to business transactions	実際の商取引にかかわるトランザクションとデータのプライバシーと機密性の保持
While many early blockchain platforms are currently being adapted for enterprise use, Hyperledger Fabric has been designed for enterprise use from the outset.	初期のブロックチェーンプラットフォームの多くが、現在エンタープライズ向けにそれに適応するように変更されているところであるのに対し、Hyperledger Fabricはエンタープライズ向けに最初から設計されています。
The following sections describe how Hyperledger Fabric (Fabric) differentiates itself from other blockchain platforms and describes some of the motivation for its architectural decisions.	以下の節では、Hyperledger Fabric (Fabric) と他のブロックチェーンとの違いを説明し、そのアーキテクチャを決定する上での動機づけについて述べていきます。
Hyperledger Fabric is an open source enterprise-grade permissioned distributed ledger technology (DLT) platform, designed for use in enterprise contexts, that delivers some key differentiating capabilities over other popular distributed ledger or blockchain platforms.	Hyperledger Fabricは、オープンソースで、エンタープライズグレードで、許可型の分散台帳技術(DLT)のプラットフォームです。Fabricは、エンタープライズ向けに設計されており、よく使われている他の分散台帳やブロックチェーンプラットフォームとは大きく異なる特性を持っています。
One key point of differentiation is that Hyperledger was established under the Linux Foundation, which itself has a long and very successful history of nurturing open source projects under **open governance** that grow strong sustaining communities and thriving ecosystems.	一つは、HyperledgerがLinux Foundationの傘下で設立されたことです。Linux Foundationは、**オープンガバナンス** の考え方で、オープンソースプロジェクトを育てることに成功してきた長い歴史があります。コミュニティを持続しエコシステムを育むことで、これらのプロジェクトは立派に成長することができました。
Hyperledger is governed by a diverse technical steering committee, and the Hyperledger Fabric project by a diverse set of maintainers from multiple organizations.	Hyperledgerは、多様性のあるテクニカル・ステアリング・コミッティ (TSC)によって運営されており、Hyperledger Fabricは、複数の組織からの多様性のあるメンテナによって運営されています。
It has a development community that has grown to over 35 organizations and nearly 200 developers since its earliest commits.	最初のコミット以来、Fabricの開発者コミュニティは、組織数は35以上、開発者の数は200人近くにまで成長しました。
Fabric has a highly **modular** and **configurable** architecture, enabling innovation, versatility and optimization for a broad range of industry use cases including banking, finance, insurance, healthcare, human resources, supply chain and even digital music delivery.	Fabricは、高度に **モジュール化され**、**構成変更可能な** アーキテクチャを採用しており、銀行業務や金融、保険、ヘルスケア、人材、サプライチェーン、さらには音楽のデジタル配信といった幅広い産業のユースケースに対するイノベーション、汎用化、最適化を可能としています。
Fabric is the first distributed ledger platform to support **smart contracts authored in general-purpose programming languages** such as Java, Go and Node.js, rather than constrained domain-specific languages (DSL).	Fabricは、ドメイン固有言語(DSL)ではなく、JavaやGoやNode.jsといった**汎用プログラミング言語によって書かれたスマートコントラクト** をサポートした最初の分散台帳プラットフォームです。
This means that most enterprises already have the skill set needed to develop smart contracts, and no additional training to learn a new language or DSL is needed.	つまり、ほとんどの企業は、スマートコントラクトを開発するのに必要なスキルをすでに持っているということであり、新しい言語やDSLを学ぶための追加のトレーニングは必要ないということです。
The Fabric platform is also **permissioned**, meaning that, unlike with a public permissionless network, the participants are known to each other, rather than anonymous and therefore fully untrusted.	Fabricのプラットフォームは **許可型** でもあります。これは、匿名で互いに信用を全く信用しないパブリック・パーミッションレスとは異なり、参加者は互いを知っているというものです。
This means that while the participants may not fully trust one another (they may, for example, be competitors in the same industry), a network can be operated under a governance model that is built off of what trust does exist between participants, such as a legal agreement or framework for handling disputes.	つまり、参加者は互いを完全には信用していないかもしれませんが(例えば、同じ産業の競合同士)、例えば法的な合意や紛争解決の枠組みといった、参加者間に何らかの形で存在する信頼をもとに、ネットワークを運営することができるということです。
One of the most important of the platform's differentiators is its support for **pluggable consensus protocols** that enable the platform to be more effectively customized to fit particular use cases and trust models.	Fabricと他のプラットフォームの違いのうちで、最も重要なものの一つは、 **プラグ可能な合意形成プロトコル** のサポートです。これにより、特定のユースケースや信頼モデルに合うように、効率よくカスタマイズすることができます。
For instance, when deployed within a single enterprise, or operated by a trusted authority, fully byzantine fault tolerant consensus might be considered unnecessary and an excessive drag on performance and throughput.	例えば、一つの企業内で利用する場合や、信頼できる機関により運営される場合などでは、完全なビザンチン故障耐性のある合意形成アルゴリズムは不要であり、性能やスループットを必要以上に損なうと考えられるかもしれません。
In situations such as that, a [crash fault-tolerant](https://en.wikipedia.org/wiki/Fault_tolerance) (CFT) consensus protocol might be more than adequate whereas, in a multi-party, decentralized use case, a more traditional [byzantine fault tolerant](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance) (BFT) consensus protocol might be required.	そのような場合、 [クラッシュ故障耐性](https://en.wikipedia.org/wiki/Fault_tolerance) (CFT)をもつ合意形成プロトコルのほうがはるかに適切でしょうし、複数の参加者による非中央集権型のユースケースでは、従来の[ビザンチン故障耐性](https://en.wikipedia.org/wiki/Byzantine_fault_tolerance) (BFT)をもつ合意形成プロトコルが必要になるでしょう。
Fabric can leverage consensus protocols that **do not require a native cryptocurrency** to incent costly mining or to fuel smart contract execution.	Fabricは、**ネイティブな暗号資産を必要としない**合意形成プロトコルを利用することができます。他のプラットフォームでは、暗号資産は、コストのかかるマイニングやスマートコントラクトの実行に対するインセンティブとして使われています。
Avoidance of a cryptocurrency reduces some significant risk/attack vectors, and absence of cryptographic mining operations means that the platform can be deployed with roughly the same operational cost as any other distributed system.	暗号資産の利用を避けることによって、いくつかの大きなリスクや攻撃ベクタを減らすことができ、また、マイニング処理を必要としないことで、他の分散システムとほぼ同様の運用コストでプラットフォームをデプロイすることができます。
The combination of these differentiating design features makes Fabric one of the **better performing platforms** available today both in terms of transaction processing and transaction confirmation latency, and it enables **privacy and confidentiality** of transactions and the smart contracts (what Fabric calls "chaincode") that implement them.	これらの特徴的な設計の組み合わせにより、Fabricは、トランザクション処理性能とトランザクションの確定レイテンシの両方において、今日利用できる**高い性能のプラットフォーム**の一つであり、トランザクションとスマートコントラクト(Fabricではチェーンコードと呼びます)の実装によって**プライバシーと機密性**を実現することができます。
Let's explore these differentiating features in more detail.	では、これらの特徴的な機能について詳細に見ていきましょう。
Hyperledger Fabric has been specifically architected to have a modular architecture.	Hyperledger Fabricは、モジュール化されたアーキテクチャとなるように特に注意を払って設計されています。
Whether it is pluggable consensus, pluggable identity management protocols such as LDAP or OpenID Connect, key management protocols or cryptographic libraries, the platform has been designed at its core to be configured to meet the diversity of enterprise use case requirements.	Fabricは、合意形成プロトコルのプラグイン、LDAPやOpenID Connectといったアイデンティティ管理のプラグイン、鍵管理のプロトコルや暗号ライブラリなど、エンタープライズのユースケースにおける要件に合うように、コアが設定可能となるように設計されています。
At a high level, Fabric is comprised of the following modular components:	Fabricは、大まかにいうと、次のモジュール化されたコンポーネントからなっています。
A pluggable ordering service establishes consensus on the order of transactions and then broadcasts blocks to peers.	プラグ可能なオーダリングサービス: トランザクションの順番に対する合意形成を行い、ピアにブロックをブロードキャストします。
A pluggable membership service provider is responsible for associating entities in the network with cryptographic identities.	プラグ可能なメンバーシップサービスプロバイダ: ネットワーク上の実体と暗号的なアイデンティティを紐づけます。
An optional peer-to-peer gossip service disseminates the blocks output by ordering service to other peers.	P2Pのゴシップサービス(オプショナル): オーダリングサービスから出力されたブロックを他のピアに配布します。
Smart contracts ("chaincode") run within a container environment (e.g. Docker) for isolation.	スマートコントラクト ("チェーンコード"): 隔離のためにDockerなどのコンテナ環境で動作します。
They can be written in standard programming languages but do not have direct access to the ledger state.	  標準的なプログラム言語で書くことができますが、台帳のステートに直接アクセスできるわけではありません。
The ledger can be configured to support a variety of DBMSs.	台帳: 様々なDBMSをサポートできます。
A pluggable endorsement and validation policy enforcement that can be independently configured per application.	プラグ可能なエンドースメントおよび検証ポリシー: アプリケーションごとによって、強制する設定を変更することができます。
There is fair agreement in the industry that there is no "one blockchain to rule them all".	ブロックチェーン業界においては、「全てを統べるブロックチェーンは存在しない」というのが、ひとまずの合意となっています。
Hyperledger Fabric can be configured in multiple ways to satisfy the diverse solution requirements for multiple industry use cases.	Hyperledger Fabricは、多くの産業のユースケースの様々な要件を満たせるようにいろいろな形で設定変更が可能になっています。
In a permissionless blockchain, virtually anyone can participate, and every participant is anonymous.	パーミッションレスなブロックチェーンには、事実上誰でも参加することができ、各参加者は匿名となります。
In such a context, there can be no trust other than that the state of the blockchain, prior to a certain depth, is immutable.	そこでは、ある程度以上の過去のブロックについてはイミュータブルである、という以外の信頼は必要ありません。
In order to mitigate this absence of trust, permissionless blockchains typically employ a "mined" native cryptocurrency or transaction fees to provide economic incentive to offset the extraordinary costs of participating in a form of byzantine fault tolerant consensus based on "proof of work" (PoW).	信頼をおかない代わりに、"Proof of Work" (PoW)をもとにした、ビザンチン故障耐性をもつ合意形成を行い、それに参加する膨大なコストを打ち消す経済的なインセンティブとして、典型的なパーミッションレスブロックチェーンでは、"マイニング"によって得られるネイティブな暗号通貨やトランザクション手数料を導入しています。
Permissioned blockchains, on the other hand, operate a blockchain amongst a set of known, identified and often vetted participants operating under a governance model that yields a certain degree of trust.	これに対して、許可型 のブロックチェーンは、既に知っていて素性のわかっている(多くの場合、深く吟味された)参加者によって、ある程度の信頼をおく管理モデルで運用されます。
A permissioned blockchain provides a way to secure the interactions among a group of entities that have a common goal but which may not fully trust each other.	許可型のブロックチェーンは、共通する目標をもちつつ、完全には互いを信用していないグループの中でのセキュアなやりとりを行う場を提供します。
By relying on the identities of the participants, a permissioned blockchain can use more traditional crash fault tolerant (CFT) or byzantine fault tolerant (BFT) consensus protocols that do not require costly mining.	参加者の素性が明らかであることで、許可型ブロックチェーンでは、コストのかかるマイニングを必要としない、クラッシュ故障耐性(CFT)やビザンチン故障耐性(BFT)をもつ、従来から存在する合意形成プロトコルを使用することができます。
Additionally, in such a permissioned context, the risk of a participant intentionally introducing malicious code through a smart contract is diminished.	くわえて、許可型のブロックチェーンでは、参加者が、意図的にスマートコントラクトに悪意のあるコードをもたらすリスクも低くなります。
First, the participants are known to one another and all actions, whether submitting application transactions, modifying the configuration of the network or deploying a smart contract are recorded on the blockchain following an endorsement policy that was established for the network and relevant transaction type.	まず第一に、参加者は互いを知っています。そして、アプリケーショントランザクションの発行、ネットワークの設定変更、スマートコントラクトのデプロイといった全ての行動は、ネットワークとトランザクションの種類ごとに設定されたエンドースメントポリシーに従って、ブロックチェーンに記録されます。
Rather than being completely anonymous, the guilty party can be easily identified and the incident handled in accordance with the terms of the governance model.	このため、完全な匿名の場合と異なり、問題ある参加者は簡単に特定され、管理モデルの規定に従ってそのインシデントが処理されることになります。
A smart contract, or what Fabric calls "chaincode", functions as a trusted distributed application that gains its security/trust from the blockchain and the underlying consensus among the peers.	Fabricでは「チェーンコード」と呼ばれるスマートコントラクトは、信頼された分散アプリケーションとして動作します。ブロックチェーンとそこで行われるピア間での合意形成によって、チェーンコードのセキュリティや信頼が保たれます。
It is the business logic of a blockchain application.	チェーンコードは、ブロックチェーンのアプリケーションのビジネスロジックとなります。
There are three key points that apply to smart contracts, especially when applied to a platform:	ブロックチェーンプラットフォームでのスマートコントラクトについては、次の三つの重要な点があります。
many smart contracts run concurrently in the network,	ネットワーク上では、多くのスマートコントラクトが同時に動作すること
they may be deployed dynamically (in many cases by anyone), and	スマートコントラクトは、動的にデプロイされる可能性があること（そして多くの場合では、誰でもデプロイできること）
application code should be treated as untrusted, potentially even malicious.	アプリケーションのコードは、信頼できないもの、場合によっては悪意のあるものとして扱うべきこと
Most existing smart-contract capable blockchain platforms follow an **order-execute** architecture in which the consensus protocol:	スマートコントラクトに対応している既存のほとんどのブロックチェーンプラットフォームでは、**order-execute** (順序付け→実行) アーキテクチャを採用しています。このアーキテクチャでは、合意形成プロトコルは、下記のようになります:
validates and orders transactions then propagates them to all peer nodes,	最初に、トランザクションを検証し順序を決定し、それを全てのピアに対して伝播させます
each peer then executes the transactions sequentially.	各ピアは、そのトランザクションを逐次的に実行します
The order-execute architecture can be found in virtually all existing blockchain systems, ranging from public/permissionless platforms such as [Ethereum](https://ethereum.org/) (with PoW-based consensus) to permissioned platforms such as [Tendermint](http://tendermint.com/), [Chain](http://chain.com/), and [Quorum](http://www.jpmorgan.com/global/Quorum).	この order-execute アーキテクチャは、[Etheruem](https://ethereum.org/)(PoWベースの合意形成を使用)のようなパブリック・パーミッションレスなプラットフォームから[Tendermint](http://tendermint.com/)・[Chain](http://chain.com/)・[Quorum](http://www.jpmorgan.com/global/Quorum)のような許可型のプラットフォームに至るまで、既存のほとんど全てのブロックチェーンシステムで使われています。
Smart contracts executing in a blockchain that operates with the order-execute architecture must be deterministic;	order-executeアーキテクチャのブロックチェーンで実行されるスマートコントラクトの動作は、決定的(deterministic)でなければなりません。
otherwise, consensus might never be reached.	そうでなければ、合意に至ることは不可能であるからです。
To address the non-determinism issue, many platforms require that the smart contracts be written in a non-standard, or domain-specific language (such as [Solidity](https://solidity.readthedocs.io/en/v0.4.23/)) so that non-deterministic operations can be eliminated.	非決定的動作(non-determinism)の問題に対応するため、多くのプラットフォームでは、スマートコントラクトを書くのに、非決定的操作を排除するために、標準的ではない、あるいはドメイン固有のプログラミング言語(例: [Solidity](https://solidity.readthedocs.io/en/v0.4.23/))を使う必要があります。
This hinders wide-spread adoption because it requires developers writing smart contracts to learn a new language and may lead to programming errors.	一方、これによって、スマートコントラクトの開発者はこれらの新しい言語を学ぶ必要があり、プログラムのミスも引き起こす可能性もあり、普及の妨げとなっているという問題があります。
Further, since all transactions are executed sequentially by all nodes, performance and scale is limited.	さらには、全てのトランザクションが全てのノードで逐次的に実行されるため、性能もスケーラビリティも限界があります。
The fact that the smart contract code executes on every node in the system demands that complex measures be taken to protect the overall system from potentially malicious contracts in order to ensure resiliency of the overall system.	システム上の全てのノードでスマートコントラクトが実行されるということは、悪意あるスマートコントラクトが実行される可能性を考えて、システム全体を保護するために複雑な対策を必要とすることでもあります。それがなければ、システム全体のレジリエンスを担保することができません。
Fabric introduces a new architecture for transactions that we call **execute-order-validate**.	Fabricでは、**execute-order-validate** (実行→順序付け→検証)と呼ばれる新しいアーキテクチャを導入しました。
It addresses the resiliency, flexibility, scalability, performance and confidentiality challenges faced by the order-execute model by separating the transaction flow into three steps:	このアーキテクチャは、order-executeモデルで問題となったレジリエンス、柔軟性、スケーラビリティ、性能と機密性に対応するため、トランザクションのフローを次の3ステップに分割しています。
execute a transaction and check its correctness, thereby endorsing it,	実行(execute): トランザクションを実行し、その正しさをチェックし、エンドースを行う
order transactions via a (pluggable) consensus protocol, and	順序付け(order): トランザクションを(プラグ可能な)合意形成プロトコルによって順序を決定する
validate transactions against an application-specific endorsement policy before committing them to the ledger	検証(validate): トランザクションをアプリケーションごとのエンドースメントポリシーを用いて検証し、台帳にコミットする
This design departs radically from the order-execute paradigm in that Fabric executes transactions before reaching final agreement on their order.	Fabricでは、順序が最終的に合意される前にトランザクションを実行します。この設計は、order-executeのパラダイムからは大きく異なるものです。
In Fabric, an application-specific endorsement policy specifies which peer nodes, or how many of them, need to vouch for the correct execution of a given smart contract.	Fabricでは、スマートコントラクトの実行結果が正しいことを証明するのに、どのピア・ノード、あるいは、いくつのピアが必要であるかを、アプリケーションごとのエンドースメントポリシーで規定します。
Thus, each transaction need only be executed (endorsed) by the subset of the peer nodes necessary to satisfy the transaction's endorsement policy.	そのため、各トランザクションの実行は、エンドースメントポリシーを満たすようなピアの部分集合で行われるだけで十分となります。
This allows for parallel execution increasing overall performance and scale of the system.	これにより、並列実行が可能となり、システム全体の性能やスケーラビリティを向上させることができます。
This first phase also **eliminates any non-determinism**, as inconsistent results can be filtered out before ordering.	この最初のフェーズでは、結果が一貫しないものを取り除くことができるため、 **非決定的動作を排除** することもできます。
Because we have eliminated non-determinism, Fabric is the first blockchain technology that **enables use of standard programming languages**.	非決定的動作を排除することによって、Fabricは **標準的なプログラミング言語を利用することができる**最初のブロックチェーン技術となりました。
As we have discussed, in a public, permissionless blockchain network that leverages PoW for its consensus model, transactions are executed on every node.	前述したように、合意形成モデルにPoWを利用するパブリック・パーミッションレスなブロックチェーンのネットワークでは、トランザクションは各ノードで実行されます。
This means that neither can there be confidentiality of the contracts themselves, nor of the transaction data that they process.	これでは、スマートコントラクトそのものの機密性も、処理するトランザクションのデータの機密性も実現することができません。
Every transaction, and the code that implements it, is visible to every node in the network.	各トランザクションとそれを実装するコードは、ネットワーク上のすべてのノードから見ることができます。
In this case, we have traded confidentiality of contract and data for byzantine fault tolerant consensus delivered by PoW.	すなわち、PoWによるビザンチン故障耐性の合意形成の代わりに、スマートコントラクトとデータの機密性を失ったということです。
This lack of confidentiality can be problematic for many business/enterprise use cases.	多くのビジネスやエンタープライズのユースケースでは、機密性が保てないことは問題となりえます。
For example, in a network of supply-chain partners, some consumers might be given preferred rates as a means of either solidifying a relationship, or promoting additional sales.	例えば、サプライチェーンのパートナーのネットワークにおいては、ある消費者に対して優遇価格を提示することで、関係を強化したりさらなる売上を上げようとすることがあります。
If every participant can see every contract and transaction, it becomes impossible to maintain such business relationships in a completely transparent network --- everyone will want the preferred rates!	もし、全ての参加者が全てのスマートコントラクトやトランザクションを見ることができたら、つまり、完全に透明性のあるネットワークにおいては、そのようなビジネスの関係を維持することは不可能になるでしょう。なぜなら、みなその優遇価格で取引したいと思うからです。
As a second example, consider the securities industry, where a trader building a position (or disposing of one) would not want her competitors to know of this, or else they will seek to get in on the game, weakening the trader's gambit.	もう一つの例として、証券業界を考えます。あるトレーダーが、ポジションを持とうとする(あるいは処分しようとする)にあたり、そのことを他の同業者に知られたいとは思わないでしょう。さもなければ、同業者がその流れに加わってしまい、そのトレーダーの旨味が損なわれてしまうでしょう。
In order to address the lack of privacy and confidentiality for purposes of delivering on enterprise use case requirements, blockchain platforms have adopted a variety of approaches.	このエンタープライズのユースケースで要件となるプライバシーと機密性の問題に対応するため、ブロックチェーンプラットフォームは様々なアプローチをとってきました。
All have their trade-offs.	それぞれのアプローチにはトレードオフがあります。
Encrypting data is one approach to providing confidentiality;	機密性を保持するための一つのアプローチに、データの暗号化があります。
however, in a permissionless network leveraging PoW for its consensus, the encrypted data is sitting on every node.	しかし、合意形成にPoWを用いるパーミッションレスのネットワークにおいては、暗号されたデータはすべてのノードに存在することになってしまいます。
Given enough time and computational resource, the encryption could be broken.	十分な時間と計算資源があれば、この暗号は解くことができるかもしれません。
For many enterprise use cases, the risk that their information could become compromised is unacceptable.	多くのエンタープライズのユースケースにおいて、情報が漏洩してしまうかもしれないというリスクは受け入れられるものではありません。
Zero knowledge proofs (ZKP) are another area of research being explored to address this problem, the trade-off here being that, presently, computing a ZKP requires considerable time and computational resources.	この問題に対する別の研究として、ゼロ知識証明(ZKP)があります。ZKPのトレードオフは、現在のところは、ZKPの計算には相当の時間と計算資源が必要となることです。
Hence, the trade-off in this case is performance for confidentiality.	つまり、ZKPのトレードオフは、機密性と性能、ということになります。
In a permissioned context that can leverage alternate forms of consensus, one might explore approaches that restrict the distribution of confidential information exclusively to authorized nodes.	PoW以外の合意形成を用いることのできる許可型においては、許可された(authorized)ノードにのみ機密情報を配布するアプローチを考えることができるかもしれません。
Hyperledger Fabric, being a permissioned platform, enables confidentiality through its channel architecture and [private data](./private-data/private-data.html) feature.	許可型のプラットフォームであるHyperledger Fabricでは、チャネル・アーキテクチャと[プライベートデータ](./private-data/private-data.html)の機能によって、機密性を実現できます。
In channels, participants on a Fabric network establish a sub-network where every member has visibility to a particular set of transactions.	チャネルを利用することで、Fabricのネットワークの参加者は、サブネットワークを作成することができます。このサブネットワークでは、参加者は特定のトランザクションのみ見ることができます。
Thus, only those nodes that participate in a channel have access to the smart contract (chaincode) and data transacted, preserving the privacy and confidentiality of both.	そのため、チャネルに参加しているノードだけがスマートコントラクト(チェーンコード)とトランザクションのデータにアクセスすることができるため、この二つのプライバシーと機密性を守ることができます。
Private data allows collections between members on a channel, allowing much of the same protection as channels without the maintenance overhead of creating and maintaining a separate channel.	プライベートデータの機能では、チャネルのメンバーの間でコレクションを作成することができ、別のチャネルの作成・維持の管理のオーバヘッドをかけることなく、チャネルの場合とかなり近い保護を実現することができます。
The ordering of transactions is delegated to a modular component for consensus that is logically decoupled from the peers that execute transactions and maintain the ledger. Specifically, the ordering service.	トランザクションのオーダリング(順序付け)は、トランザクションを実行し台帳を管理するピアとは論理的に切り離されている、モジュール化された合意形成コンポーネント、具体的にはオーダリングサービスの役割です。
Since consensus is modular, its implementation can be tailored to the trust assumption of a particular deployment or solution.	合意形成はモジュール化されているため、それぞれの構成やソリューションに応じた実装を使うことができます。
This modular architecture allows the platform to rely on well-established toolkits for CFT (crash fault-tolerant) or BFT (byzantine fault-tolerant) ordering.	このモジュール化アーキテクチャによって、CFT(クラッシュ故障耐性)やBFT(ビザンチン故障耐性)のオーダリングに既に確立されているツールキットを用いることができます。
Fabric currently offers a CFT ordering service implementation based on the [`etcd` library](https://coreos.com/etcd/) of the [Raft protocol](https://raft.github.io/raft.pdf).	Fabricは現在のところ、[Raft プロトコル](https://raft.github.io/raft.pdf) の [`etcd` ライブラリ](https://coreos.com/etcd/)をベースとしたCFTのオーダリングサービス実装を提供しています。
For information about currently available ordering services, check out our [conceptual documentation about ordering](./orderer/ordering_service.html).	現在利用できるオーダリングサービスについては、[オーダリングの概念についてのドキュメント](./orderer/ordering_service.html) を参照してください。
Note also that these are not mutually exclusive.	なお、これらは排他的ではないことに注意してください。
A Fabric network can have multiple ordering services supporting different applications or application requirements.	一つのFabricのネットワークは、異なるアプリケーションや要件に対応する複数のオーダリングサービスをもつことができます。
Performance of a blockchain platform can be affected by many variables such as transaction size, block size, network size, as well as limits of the hardware, etc.	ブロックチェーンプラットフォームの性能は、トランザクションのサイズ、ブロックのサイズ、ネットワークのサイズ、ハードウェアの制約といった多くの変数によって影響を受けます。
The Hyperledger Fabric [Performance and Scale working group](https://wiki.hyperledger.org/display/PSWG/Performance+and+Scale+Working+Group) currently works on a benchmarking framework called [Hyperledger Caliper](https://wiki.hyperledger.org/projects/caliper).	Hyperledger Fabricの [Performance and Scale working group](https://wiki.hyperledger.org/display/PSWG/Performance+and+Scale+Working+Group) は、[Hyperledger Caliper](https://wiki.hyperledger.org/projects/caliper) というベンチマークのためのフレームワークに現在取り組んでいます。
Several research papers have been published studying and testing the performance capabilities of Hyperledger Fabric.	Hyperledge Fabricの性能について調査、測定を行った研究論文がいくつかあります。
The latest [scaled Fabric to 20,000 transactions per second](https://arxiv.org/abs/1901.00910).	最新のものには、[Fabricを毎秒20,000トランザクションまでスケールさせたもの](https://arxiv.org/abs/1901.00910)があります。
Any serious evaluation of blockchain platforms should include Hyperledger Fabric in its short list.	ブロックチェーンプラットフォームに関するまともな評価には、必ずHyperledger Fabricを加えるべきです。
Combined, the differentiating capabilities of Fabric make it a highly scalable system for permissioned blockchains supporting flexible trust assumptions that enable the platform to support a wide range of industry use cases ranging from government, to finance, to supply-chain logistics, to healthcare and so much more.	Fabricは、これらの特徴によって、許可型ブロックチェーンのための高いスケーラビリティをもつシステムとなりました。Fabricは信頼の仮定について柔軟に変更可能であり、それにより、政府から金融、サプライチェーン、ヘルスケア、そのほか多くの幅広い産業のユースケースに対応することができるようになりました。
Hyperledger Fabric is the most active of the Hyperledger projects.	Hyperledger Fabricは、Hyperledgerのプロジェクトの中で最も活発なものです。
The community building around the platform is growing steadily, and the innovation delivered with each successive release far out-paces any of the other enterprise blockchain platforms.	このプラットフォームをとりまくコミュニティは着実に成長しており、各リリースによってもたらされるイノベーションは、他のエンタープライズ向けブロックチェーンプラットフォームを凌駕しています。
The preceding is derived from the peer reviewed 	この内容は、査読された下記の論文によります。
The document serves to provide details on the setup and best practices for MSPs.	このドキュメントは、MSPのセットアップとベストプラクティスの詳細を提供します。
Membership Service Provider (MSP) is a Hyperledger Fabric component that offers an abstraction of membership operations.	メンバーシップサービスプロバイダ (Membership Service Provider, 以下、MSP) は、メンバーシップ操作の抽象化を提供するHyperledger Fabricのコンポーネントです。
In particular, an MSP abstracts away all cryptographic mechanisms and protocols behind issuing certificates, validating certificates, and user authentication.	特に、MSPは、証明書の発行、証明書の検証、およびユーザ認証の背後にあるすべての暗号化メカニズムとプロトコルを抽象化します。
An MSP may define its own notion of identity, and the rules by which those identities are governed (identity validation) and authenticated (signature generation and verification).	MSPは、MSP自身のアイデンティティ、およびそれらのアイデンティティを管理するルール (アイデンティティの検証) と認証するルール (署名の生成と検証) を定義することができます。
A Hyperledger Fabric blockchain network can be governed by one or more MSPs.	Hyperledger Fabricブロックチェーンネットワークは、1つまたは複数のMSPによって管理されます。
This provides modularity of membership operations, and interoperability across different membership standards and architectures.	これにより、メンバーシップ操作のモジュール性と、異なるメンバーシップ標準やアーキテクチャ間での相互運用性を提供します。
In the rest of this document we elaborate on the setup of the MSP implementation supported by Hyperledger Fabric, and discuss best practices concerning its use.	このドキュメントの残りの部分では、Hyperledger FabricがサポートするMSP実装のセットアップについて詳しく説明し、その使用に関するベストプラクティスについて議論します。
MSP Configuration	MSPの設定
To setup an instance of the MSP, its configuration needs to be specified locally at each peer and orderer (to enable peer and orderer signing), and on the channels to enable peer, orderer, client identity validation, and respective signature verification (authentication) by and for all channel members.	MSPのインスタンスをセットアップするためには、その設定を、各ピアやOrdererについてローカルに指定し (ピアとOrdererの署名を有効にするため)、ピア、Orderer、クライアントのアイデンティティ検証、およびすべてのチャネルメンバーによるそれぞれの署名検証 (認証) を有効にするために、チャネル上で指定をする必要があります。
Firstly, for each MSP a name needs to be specified in order to reference that MSP in the network (e.g. ``msp1``, ``org2``, and ``org3.divA``).	まず、各MSPについて、そのMSPをネットワーク上で参照するために、名前を指定する必要があります (例: ``msp1``, ``org2``, ``org3.divA``)。
This is the name under which membership rules of an MSP representing a consortium, organization or organization division is to be referenced in a channel.	これは、コンソーシアム、組織、または組織の部門を表すMSPのメンバーシップルールがチャネル内で参照される名前です。
This is also referred to as the *MSP Identifier* or *MSP ID*.	これは *MSP識別子* または *MSP ID* とも呼ばれます。
MSP Identifiers are required to be unique per MSP instance.	MSP IDは、MSPインスタンスごとに一意である必要があります。
For example, shall two MSP instances with the same identifier be detected at the system channel genesis, orderer setup will fail.	例えば、同じIDを持つ2つのMSPインスタンスがあると、システムチャネル生成時に検出されて、Ordererのセットアップが失敗します。
In the case of the default MSP implementation, a set of parameters need to be specified to allow for identity (certificate) validation and signature verification.	デフォルトのMSP実装の場合、アイデンティティ (証明書) 検証と署名検証を可能にするために、一連のパラメータを指定する必要があります。
These parameters are deduced by `RFC5280 <http://www.ietf.org/rfc/rfc5280.txt>`_, and include:	これらのパラメータは、`RFC5280 <http://www.ietf.org/rfc/rfc5280.txt>`_ によって推定されて、以下を含みます:
A list of self-signed (X.509) CA certificates to constitute the *root of trust*	*信頼のルート(root of trust)* を構成する自己署名 (X.509) CA証明書のリスト
A list of X.509 certificates to represent intermediate CAs this provider considers for certificate validation; 	このプロバイダが証明書を検証するために考慮する中間CA (Intermediate CA) を表すX.509証明書のリスト。
these certificates ought to be certified by exactly one of the certificates in the root of trust;	これらの証明書は、信頼のルートにある証明書のいずれか1つのみによって認証される必要があります。
intermediate CAs are optional parameters	中間CAはオプショナルなパラメータです。
A list of X.509 certificates representing the administrators of this MSP with a verifiable certificate path to exactly one of the CA certificates of the root of trust;	このMSPの管理者を表すX.509証明書のリスト。これらの証明書は、信頼のルートとなるCA証明書のいずれか1つにのみによって、検証可能な証明書のパスを持たなくてはいけません。
owners of these certificates are authorized to request changes to this MSP configuration (e.g. root CAs, intermediate CAs)	これらの証明書の所有者は、このMSPの設定 (例: ルートCAや中間CA) への変更を要求することが許可されています。
A list of Organizational Units that valid members of this MSP should include in their X.509 certificate;	このMSPの有効なメンバーがX.509証明書に含める必要のある組織単位 (Organizational Unit, OU) のリスト。
this is an optional configuration parameter, used when, e.g., multiple organizations leverage the same root of trust, and intermediate CAs, and have reserved an OU field for their members	これは、オプショナルな設定パラメータであり、例えば、複数の組織が同一の信頼ルートと中間CAを利用している場合や、メンバーのためのOUフィールドを予約している場合に利用されます。
A list of certificate revocation lists (CRLs) each corresponding to exactly one of the listed (intermediate or root) MSP Certificate Authorities;	証明書失効リスト (Certificate Revocation List, CRL) のリスト。それぞれは、(中間またはルート) MSP CAのうちいずれか1つのみに対応します。
this is an optional parameter	このオプショナルなパラメータです。
A list of self-signed (X.509) certificates to constitute the *TLS root of trust* for TLS certificates.	TLS証明書のためのの *TLS信頼ルート* を構成するための自己署名 (X.509) 証明書のリスト。
A list of X.509 certificates to represent intermediate TLS CAs this provider considers;	このプロバイダが考慮する必要のある中間TLS CAを表すX.509証明書のリスト。
these certificates ought to be certified by exactly one of the certificates in the TLS root of trust;	これらの証明書はTLSの信頼されたルート証明書のいずれか1つのみによって認証される必要があります。
intermediate CAs are optional parameters.	中間CAはオプショナルなパラメータです。
Valid  identities for this MSP instance are required to satisfy the following conditions:	MSPインスタンスの 有効な アイデンティティは以下の条件を満たす必要があります:
They are in the form of X.509 certificates with a verifiable certificate path to exactly one of the root of trust certificates;	アイデンティティは、X.509証明書の形式であり、信頼できるルート証明書のいずれか1つのみに対して検証可能な証明書のパスが含まれている。
They are not included in any CRL;	アイデンティティは、どのCRLにも含まれていない。
And they *list* one or more of the Organizational Units of the MSP configuration in the ``OU`` field of their X.509 certificate structure.	アイデンティティは、X.509証明書の ``OU`` フィールドに、MSPで設定している組織単位 (OU) を1つ以上 *リストアップ* している。
For more information on the validity of identities in the current MSP implementation, we refer the reader to :doc:`msp-identity-validity-rules`.	現在のMSP実装におけるアイデンティティの有効性に関する詳細については、:doc:`msp-identity-validity-rules` を参照してください。
In addition to verification related parameters, for the MSP to enable the node on which it is instantiated to sign or authenticate, one needs to specify:	検証に関連するパラメータに加えて、MSPがインスタンス化されたノードが署名または認証するためには、以下を指定する必要があります。
The signing key used for signing by the node (currently only ECDSA keys are supported), and	ノードによる署名に使われる署名鍵 (現在は、ECDSA鍵のみがサポートされています)。
The node's X.509 certificate, that is a valid identity under the verification parameters of this MSP.	このノードのX.509証明書。これはこのMSPの検証パラメータで有効なアイデンティティです。
It is important to note that MSP identities never expire;	MSPアイデンティティは決して期限切れにならないことに注意してください。
they can only be revoked by adding them to the appropriate CRLs.	それらは、適切なCRLに追加することによってのみ取り消すことができます。
Additionally, there is currently no support for enforcing revocation of TLS certificates.	また、TLS証明書の強制失効については現在サポートされていません。
How to generate MSP certificates and their signing keys?	MSPの証明書とその署名鍵を生成する方法
`Openssl <https://www.openssl.org/>`_ can be used to generate X.509 certificates and keys.	`OpenSSL <https://www.openssl.org/>`_ はX.509証明書と鍵を生成することができます。
Please note that Hyperledger Fabric does not support RSA key and certificates.	Hyperledger FabricはRSA鍵と証明書をサポートしていないことに注意してください。
Alternatively, the ``cryptogen`` tool can be used as described in :doc:`getting_started`.	あるいは、:doc:`getting_started` で説明されているように、ツール ``cryptogen`` を使用することもできます。
`Hyperledger Fabric CA <http://hyperledger-fabric-ca.readthedocs.io/en/latest/>`_ can also be used to generate the keys and certificates needed to configure an MSP.	`Hyperledger Fabric CA <http://hyperledger-fabric-ca.readthedocs.io/en/latest/>`_もMSPを設定するために必要な鍵や証明書の生成に使用できます。
MSP setup on the peer & orderer side	ピアおよびOrderer側のMSPセットアップ
To set up a local MSP (for either a peer or an orderer), the administrator should create a folder (e.g. ``$MY_PATH/mspconfig``) that contains six subfolders and a file:	ローカルMSP (ピア用もしくはOrderer用) をセットアップするために、管理者は、以下の6つのサブフォルダと1つのファイルを含むフォルダ (例: ``$MY_PATH/mspconfig``) を生成しなければなりません。
1. a folder ``admincerts`` to include PEM files each corresponding to an administrator certificate	1. 管理者の証明書に対応するPEMファイルを含んだ ``admincerts`` フォルダ (フォルダ内の各PEMファイルが証明書と1対1対応)
2. a folder ``cacerts`` to include PEM files each corresponding to a root CA's certificate	2. ルートCAの証明書に対応するPEMファイルを含んだ ``cacerts`` フォルダ (フォルダ内の各PEMファイルが証明書と1対1対応)
3. (optional) a folder ``intermediatecerts`` to include PEM files each corresponding to an intermediate CA's certificate	3. (Optional) 中間CAの証明書に対応するPEMファイルを含んだ ``intermediatecerts`` フォルダ (フォルダ内の各PEMファイルが証明書と1対1対応)
4. (optional) a file ``config.yaml`` to configure the supported Organizational Units and identity classifications (see respective sections below).	4. (Optional) サポートされる組織単位 (OU) とアイデンティティ分類を設定するための ``config.yaml`` ファイル (以降の各セッションを参照)
5. (optional) a folder ``crls`` to include the considered CRLs	5. (Optional) 対象となるCRLを含んだ ``crls`` フォルダ
6. a folder ``keystore`` to include a PEM file with the node's signing key; we emphasise that currently RSA keys are not supported	6. そのノードの署名鍵を持つPEMファイルを含んだ ``keystore`` フォルダ。現在はRSA鍵はサポートしていないことを強調しておきます。
7. a folder ``signcerts`` to include a PEM file with the node's X.509 certificate	7. そのノードのX.509証明書を持つPEMファイルを含んだ ``signcerts`` フォルダ
8. (optional) a folder ``tlscacerts`` to include PEM files each corresponding to a TLS root CA's certificate	8. (Optional) TLSルートCA証明書に対応するPEMファイルを含んだ ``tlscacerts`` フォルダ (フォルダ内の各PEMファイルが証明書と1対1対応)
9. (optional) a folder ``tlsintermediatecerts`` to include PEM files each corresponding to an intermediate TLS CA's certificate In the configuration file of the node (core.yaml file for the peer, and orderer.yaml for the orderer), one needs to specify the path to the mspconfig folder, and the MSP Identifier of the node's MSP.	9. (Optional) 中間TLS CA証明書に対応するPEMファイルを含んだ ``tlsintermediatecerts`` フォルダ (フォルダ内の各PEMファイルが証明書と1対1対応)ノードの設定ファイル (ピア用のcore.yamlファイルやOrderer用のorderer.yamlファイル) において、mspconfigフォルダへのパスと、そのノードのMSP IDを指定する必要があります。
The path to the mspconfig folder is expected to be relative to FABRIC_CFG_PATH and is provided as the value of parameter ``mspConfigPath`` for the peer, and ``LocalMSPDir`` for the orderer.	mspconfigフォルダへのパスは、FABRIC_CFG_PATHからの相対パスであることが想定されており、ピアに関してはパラメータ ``mspConfigPath`` の値、およびOrdererに関しては ``LocalMSPDir`` の値として提供されます。
The identifier of the node's MSP is provided as a value of parameter ``localMspId`` for the peer and ``LocalMSPID`` for the orderer.	そのノードのMSP IDは、ピアに関してはパラメータ ``localMspId`` の値、およびOrdererに関しては ``LocalMSPID`` の値として提供されます。
These variables can be overridden via the environment using the CORE prefix for peer (e.g. CORE_PEER_LOCALMSPID) and the ORDERER prefix for the orderer (e.g. ORDERER_GENERAL_LOCALMSPID).	これらの変数は、ピア用の接頭語 (Prefix) であるCOREを使った環境変数 (例: CORE_PEER_LOCALMSPID) とOrderer用の接頭語 (Prefix) であるOREDERERを使った環境変数 (例: ORDERER_GENERAL_LOCALMSPID) を介して上書きできます。
Notice that for the orderer setup, one needs to generate, and provide to the orderer the genesis block of the system channel.	Ordererのセットアップでは、システムチャネルのジェネシスブロックを生成し、Ordererに提供する必要があることに注意してください。
The MSP configuration needs of this block are detailed in the next section.	MSP設定のニーズについては、次のセクションで説明します。
Reconfiguration of a "local" MSP is only possible manually, and requires that the peer or orderer process is restarted.	「ローカル」MSPの 再設定 は、手動でのみ可能で、ピアあるいはOrdererプロセスを再起動する必要があります。
In subsequent releases we aim to offer online/dynamic reconfiguration (i.e. without requiring to stop the node by using a node managed system chaincode).	将来のリリースでは、オンライン/動的再設定を提供することをめざしています (つまり、ノードによって管理されるシステムチェーンコードを用いることで、ノードを止めることが必要とされなくなります)。
Organizational Units	組織単位 (OU)
In order to configure the list of Organizational Units that valid members of this MSP should include in their X.509 certificate, the ``config.yaml`` file needs to specify the organizational unit (OU, for short) identifiers.	MSPの有効なメンバーがX.509証明書に含まれるべき組織単位のリストを設定するために、``config.yaml`` ファイルに組織単位 (略称: OU) を指定する必要があります。
You can find an example below:	以下に例を示します。
The above example declares two organizational unit identifiers: commercial and administrators.	上記の例では、commercial と administrators という二つの組織単位 (OU) 識別子を宣言しています。
An MSP identity is valid if it carries at least one of these organizational unit identifiers.	MSPアイデンティティは、これらのOU識別子のうち少なくとも1つを保持している場合に有効となります。
The ``Certificate`` field refers to the CA or intermediate CA certificate path under which identities, having that specific OU, should be validated.	``Certificate`` フィールドは、特定のOUを持つIDが検証されるべきCAまたは中間CAの証明書へのパスを指します。
The path is relative to the MSP root folder and cannot be empty.	これらのパスは、MSPルートフォルダの相対パスであり、空にすることはできません。
Identity Classification	アイデンティティ分類
The default MSP implementation allows organizations to further classify identities into clients, admins, peers, and orderers based on the OUs of their x509 certificates.	デフォルトのMSP実装では、組織は、X.509証明書のOUに基づいて、IDをクライアント (client)、管理者 (admin)、ピア、Ordererにさらに分類することができます。
An identity should be classified as a client if it transacts on the network.	ネットワーク上で取引を行う場合、アイデンティティは クライアント (client) に分類される必要があります。
An identity should be classified as an admin if it handles administrative tasks such as joining a peer to a channel or signing a channel configuration update transaction.	チャネルへのピアの参加 (Join) やチャネル設定更新トランザクションへの署名のような管理タスクを処理する場合、アイデンティティは 管理者 (admin) に分類される必要があります。
An identity should be classified as a peer if it endorses or commits transactions.	トランザクションのエンドースやコミットをする場合、アイデンティティは ピア に分類される必要があります。
An identity should be classified as an orderer if belongs to an ordering node.	オーダリングノードに属している場合、アイデンティティは orderer に分類される必要があります。
In order to define the clients, admins, peers, and orderers of a given MSP, the ``config.yaml`` file needs to be set appropriately.	MSPのクライアント、管理者、ピア、Ordererを定義するためには、``config.yaml`` ファイルを適切に設定する必要があります。
You can find an example NodeOU section of the ``config.yaml`` file below:	以下にその設定のために必要な ``config.yaml`` ファイルのNodeOUセクションの例を示します。
For each identity classification that you would like to utilize, specify an OU identifier.	利用したいアイデンティティ分類ごとに、OU識別子を指定します。
You can optionally configure that the OU identifier must be issued by a specific CA or intermediate certificate from your organization.	オプションで、特定のCAまたはあなたの組織の中間証明書によってOU識別子が発行されなければならないことを設定できます。
However, it is typical to NOT configure a specific Certificate.	しかし、特定の証明書を設定しないのが一般的な使い方です。
By not configuring a specific Certificate, you will be able to add other CA or intermediate certs later, without having to reissue all credentials.	特定の証明書を設定しないことで、すべての証明書を再発行することなく、あとから他のCAまたは中間証明書を追加できます。
For this reason, the sample below comments out the Certificate field.	このため、以下のサンプルでは、証明書設定用 (Certificate) フィールドをコメントアウトしています。
orderer Identity classification is enabled when ``NodeOUs.Enable`` is set to ``true``.	アイデンティティ分類は ``NodeOUs.Enable`` が ``true`` に設定された場合に有効化されます。
Then the client (admin, peer, orderer) organizational unit identifier is defined by setting the properties of the ``NodeOUs.ClientOUIdentifier`` (``NodeOUs.AdminOUIdentifier``, ``NodeOUs.PeerOUIdentifier``, ``NodeOUs.OrdererOUIdentifier``) key:	そして、クライアント (管理者、ピア、Orderer) 組織単位 (OU) 識別子は、それぞれ ``NodeOUs.ClientOUIdentifier``(``NodeOUs.AdminOUIdentifier``, ``NodeOUs.PeerOUIdentifier``, ``NodeOUs.OrdererOUIdentifier``)キーのプロパティを設定することで定義されます。
a. ``OrganizationalUnitIdentifier``: Is the OU value that the x509 certificate needs to contain to be considered a client (admin, peer, orderer respectively).	a. ``OrganizationalUnitIdentifier``: は、クライアント (管理者、ピア、Orderer) とみなされるためにX.509証明書に含める必要のあるOUの値です。
If this field is empty, then the classification is not applied.	このフィールドが空の場合には、分類は適用されません。
b. ``Certificate``: (Optional) Set this to the path of the CA or intermediate CA certificate under which client (peer, admin or orderer) identities should be validated.	b. ``Certificate``: (Optional) には、クライアント (または管理者、ピア、Orderer) IDを検証するべきCAまたは中間CA証明書へのパスを設定します。
The field is relative to the MSP root folder.	このフィールドは、MSPルートフォルダの相対パスです。
Only a single Certificate can be specified.	このフィールドに指定できる証明書は1つだけです。
If you do not set this field, then the identities are validated under any CA defined in the organization's MSP configuration, which could be desirable in the future if you need to add other CA or intermediate certificates.	このフィールドを設定しない場合には、アイデンティティはこの組織のMSP設定で定義されている任意のCAによって検証されます。将来的に他のCAまたは中間証明書を追加する必要がある場合には、設定しないことが望ましい可能性があります。
Notice that if the ``NodeOUs.ClientOUIdentifier`` section (``NodeOUs.AdminOUIdentifier``, ``NodeOUs.PeerOUIdentifier``, ``NodeOUs.OrdererOUIdentifier``) is missing, then the classification is not applied.	``NodeOUs.ClientOUIdentifier`` セクション (``NodeOUs.AdminOUIdentifier``, ``NodeOUs.PeerOUIdentifier``,``NodeOUs.OrdererOUIdentifier``) がない場合には、分類が適用されないことに注意してください。
If ``NodeOUs.Enable`` is set to ``true`` and no classification keys are defined, then identity classification is assumed to be disabled.	``NodeOUs.Enable`` が ``true`` に設定されており、分類キーが定義されていない場合には、アイデンティティ分類が無効であるとみなされます。
Identities can use organizational units to be classified as either a client, an admin, a peer, or an orderer.	アイデンティティは組織単位 (OU) を使うことで、クライアント、管理者、ピア、Ordererのいずれかに分類することができます。
The four classifications are mutually exclusive.	この4つの分類は排他的です。
The 1.1 channel capability needs to be enabled before identities can be classified as clients or peers.	アイデンティティをクライアントまたはピアとして分類するためには、v1.1 チャネルケイパビリティを有効にする必要があります。
The 1.4.3 channel capability needs to be enabled for identities to be classified as an admin or orderer.	管理者またはOrdererとして分類するためには、v1.4.3 チャネルケイパビリティを有効にする必要があります。
Classification allows identities to be classified as admins (and conduct administrator actions) without the certificate being stored in the ``admincerts`` folder of the MSP.	分類によって、MSPの ``admincerts`` フォルダに証明書を格納しなくても、アイデンティティを管理者として分類 (および管理者のアクションを実行) 可能です。
Instead, the ``admincerts`` folder can remain empty and administrators can be created by enrolling identities with the admin OU.	代わりに、 ``admincerts`` フォルダを空のままにして、管理者OU (admin OU) を設定したアイデンティを登録することで管理者を作成できます。
Certificates in the ``admincerts`` folder will still grant the role of administrator to their bearer, provided that they possess the client or admin OU.	``admincerts`` フォルダ内の証明書は、クライアントOU (client OU) または 管理者OU (admin OU) を所有している場合に、それらのベアラ (bearer、持参者) に管理者の役割を付与することができます。
Channel MSP setup	チャネルMSPセットアップ
At the genesis of the system, verification parameters of all the MSPs that appear in the network need to be specified, and included in the system channel's genesis block.	システム生成 (ジェネシス) 時においては、ネットワークに現れるすべてのMSPの検証パラメータを指定し、システムチャネルのジェネシスブロックに含める必要があります。
Recall that MSP verification parameters consist of the MSP identifier, the root of trust certificates, intermediate CA and admin certificates, as well as OU specifications and CRLs.	MSP検証用パラメータは、MSP ID、ルート証明書、中間CA証明書、管理者の証明書、およびOUの仕様とCRLで構成されることを思い出してください。
The system genesis block is provided to the orderers at their setup phase, and allows them to authenticate channel creation requests.	システムジェネシスブロックは、セットアップ段階でOrdererによって提供され、チャネル生成リクエストを認証できるようにします。
Orderers would reject the system genesis block, if the latter includes two MSPs with the same identifier, and consequently the bootstrapping of the network would fail.	もしシステムジェネシスブロックが同一の識別子を持つ2つのMSPを含む場合には、Ordererはシステムジェネシスブロックを却下し、その結果、ネットワークのブートストラップが失敗します。
For application channels, the verification components of only the MSPs that govern a channel need to reside in the channel's genesis block.	アプリケーションチャネルに関しては、チャネルのジェネシスブロックが、チャネルを管理するMSPだけの検証コンポーネント (※訳者注: 検証パラメータと同義と思われる) を含んでいる必要があります。
We emphasize that it is the responsibility of the application to ensure that correct MSP configuration information is included in the genesis blocks (or the most recent configuration block) of a channel prior to instructing one or more of their peers to join the channel.	1つ以上のピアにチャネルにジョインするように指示をする前に、チャネルのジェネシスブロック (あるいは最新のコンフィグレーションブロック) に正しいMSP設定情報が含まれていることを確認することは、 アプリケーション側の責任 であることを強調します。
When bootstrapping a channel with the help of the configtxgen tool, one can configure the channel MSPs by including the verification parameters of MSP in the mspconfig folder, and setting that path in the relevant section in ``configtx.yaml``.	configtxgenツールを使用してチャネルを立ち上げる場合には、MSPの検証パラメータをmspconfigフォルダに含め、``configtx.yaml`` の関連セクションにそのパスを指定することで、チャネルMSPを設定できます。
Reconfiguration of an MSP on the channel, including announcements of the certificate revocation lists associated to the CAs of that MSP is achieved through the creation of a ``config_update`` object by the owner of one of the administrator certificates of the MSP.	チャネル上のあるMSPの 再設定 (そのMSPのCAに関連付けられた証明書失効リストのアナウンスも含む) は、MSPの管理者証明書の所有者が ``config_update`` オブジェクトの作成を通じて実施可能です。
The client application managed by the admin would then announce this update to the channels in which this MSP appears.	その管理者によって管理されるクライアントアプリケーションは、さらに、このMSPが登場している (複数の) チャネルに対してもこの更新をアナウンスする必要があります。
Best Practices	ベストプラクティス
In this section we elaborate on best practices for MSP configuration in commonly met scenarios.	このセクションでは、一般的なシナリオにおけるMSP設定のベストプラクティスについて詳しく説明します。
1) Mapping between organizations/corporations and MSPs	1) 組織/会社とMSPの間のマッピング
We recommend that there is a one-to-one mapping between organizations and MSPs.	組織とMSPの間には1対1のマッピングがされることをお勧めします。
If a different type of mapping is chosen, the following needs to be to considered:	もし異なるタイプのマッピングが選択された場合には、以下の点を考慮する必要があります:
One organization employing various MSPs.	1つの組織が様々なMSPを使用する場合
This corresponds to the case of an organization including a variety of divisions each represented by its MSP, either for management independence reasons, or for privacy reasons.	これは、管理の独立性の理由あるいはプライバシーの理由のために、MSPによってそれぞれ表現される様々な部門を含む組織の場合に対応します。
In this case a peer can only be owned by a single MSP, and will not recognize peers with identities from other MSPs as peers of the same organization.	この場合、ピアは単一のMSPのみが所有することができ、他のMSPのアイデンティティを持つピアを同じ組織のピアとして認識することはできません。
The implication of this is that peers may share through gossip organization-scoped data with a set of peers that are members of the same subdivision, and NOT with the full set of providers constituting the actual organization.	これの意味するところは、ピアは、実際の組織を構成するプロバイダのすべての集合ではなく、同じ部門のメンバーであるピアの集合と、ゴシッププロトコルを介した組織スコープのデータ (gossip organization-scoped data) を共有ができるということです。
Multiple organizations using a single MSP.	単一のMSPを複数の組織が使う場合
This corresponds to a case of a consortium of organizations that are governed by similar membership architecture.	これは、似たようなメンバーシップアーキテクチャで管理される組織のコンソーシアムの場合に対応します。
One needs to know here that peers would propagate organization-scoped messages to the peers that have an identity under the same MSP regardless of whether they belong to the same actual organization.	この場合には、ピアが実際に同じ組織に属しているかどうかに関わらず、同一MSPの下でアイデンティティを持つピアに組織スコープのメッセージが伝達されることを知っておく必要があります。
This is a limitation of the granularity of MSP definition, and/or of the peer’s configuration.	これは、MSP定義の粒度、および/またはピアの設定の制限です。
2) One organization has different divisions (say organizational units), to which it wants to grant access to different channels.	2) 1つの組織に異なる部門 (組織単位 (OU)) があり、それらに異なるチャネルへのアクセスを許可したい場合
Two ways to handle this:	以下の二つの対処方法があります:
Define one MSP to accommodate membership for all organization’s members.	すべての組織のメンバーのためのメンバーシップに対応する1つのMSPを定義.
Configuration of that MSP would consist of a list of root CAs, intermediate CAs and admin certificates; and membership identities would include the organizational unit (``OU``) a member belongs to.	そのMSPの設定は、ルートCA、中間CA、および管理証明書のリストで構成されます。そして、メンバーシップIDには、メンバーが所属する組織単位 (``OU``) が含まれます。
Policies can then be defined to capture members of a specific ``role`` (should be one of: peer, admin, client, orderer, member), and these policies may constitute the read/write policies of a channel or endorsement policies of a chaincode.	さらに、ポリシーは特定の「役割」(peer, admin, client, orderer, memberのうちのいずれか) のメンバーを捉えるために定義することができ、これらのポリシーは、チャネルの読み書き (read/write) ポリシーやチェーンコードのエンドースメントポリシーを構成することができます。
Specifying custom OUs in the profile section of ``configtx.yaml`` is currently not configured.	``configtx.yaml`` のプロファイルセクションでカスタムOUを指定することは現在のところできません。
A limitation of this approach is that gossip peers would consider peers with membership identities under their local MSP as members of the same organization, and would consequently gossip with them organization-scoped data (e.g. their status).	このアプローチの制約は、ゴシップピアがローカルMSPの下で同一メンバーシップアイデンティティを持つピアを同じ組織のメンバーとしてみなすため、その結果、それらのピアに組織スコープのデータ (例えばステータス) を伝搬することです。
Defining one MSP to represent each division.	各部門を表現するために1つのMSPを定義.
This would involve specifying for each division, a set of certificates for root CAs, intermediate CAs, and admin Certs, such that there is no overlapping certification path across MSPs.	これは、ルートCA、中間CA、および管理者証明書のセットを各部門に対して指定する必要があり、MSP間で重複する証明書パスが存在しないようにする必要があります。
This would mean that, for example, a different intermediate CA per subdivision is employed.	このことは、例えば、部門ごとに異なる中間CAが使用されることを意味します。
Here the disadvantage is the management of more than one MSPs instead of one, but this circumvents the issue present in the previous approach.	この欠点は1つではなく複数のMSPを管理する必要があることですが、これにより1つ目のアプローチで存在していた問題が回避されます。
One could also define one MSP for each division by leveraging an OU extension of the MSP configuration.	MSP設定のOU拡張を活用することで、各部門に1つのMSPを定義することができます。
3) Separating clients from peers of the same organization.	3) 同一組織内でクライアントとピアを分離したい場合
In many cases it is required that the “type” of an identity is retrievable from the identity itself (e.g. it may be needed that endorsements are guaranteed to have derived by peers, and not clients or nodes acting solely as orderers).	多くのケースでは、アイデンティティの「タイプ」がアイデンティティ自体から取得可能である必要があります(例: エンドースメントが、クライアントやOrdererとしてのみ動くノードではなく、ピアから派生したものであることが保証されていることが必要な場合があります)。
There is limited support for such requirements.	このような要件のためのサポートは限られています。
One way to allow for this separation is to create a separate intermediate CA for each node type - one for clients and one for peers/orderers; and configure two different MSPs - one for clients and one for peers/orderers.	この分離を可能にする1つの方法は、ノードタイプごとに (1つはクライアント用に、もう1つはピア/Orderer用に) 別々の中間CAを作成し、2つの異なるMSPを設定することです (1つはクライアント用、もう1つはピア/Orderer用)。
Channels this organization should be accessing would need to include both MSPs, while endorsement policies will leverage only the MSP that refers to the peers.	この組織がアクセスする必要があるチャネルには、両方のMSPを含める必要がありますが、エンドースメントポリシーは、ピアを参照するMSPのみを利用します。
This would ultimately result in the organization being mapped to two MSP instances, and would have certain consequences on the way peers and clients interact.	これにより、最終的に、この組織が2つのMSPインスタンスにマッピングされ、ピアとクライアントの相互作用の方法に特定の結果をもたらすでしょう。
Gossip would not be drastically impacted as all peers of the same organization would still belong to one MSP.	同じ組織のすべてのピアが1つのMSPに属しているために、ゴシップに大きな影響はありません。
Peers can restrict the execution of certain system chaincodes to local MSP based policies.	ピアは特定のシステムチェーンコードの実行をローカルMSPベースのポリシーで制限できます。
For example, peers would only execute “joinChannel” request if the request is signed by the admin of their local MSP who can only be a client (end-user should be sitting at the origin of that request).	例えば、クライアントのみとなるローカルMSPの管理者がリクエストに署名した場合にのみ (エンドユーザがそのリクエストの起点としてなっているはず) 、ピアは「joinChannel」リクエストを実行するとします。
We can go around this inconsistency if we accept that the only clients to be members of a peer/orderer MSP would be the administrators of that MSP.	このケースでの矛盾は、ピア/Orderer用のMSPメンバーになるクライアントのみがそのMSPの管理者になることを許可するようにすれば、回避できます。
Another point to be considered with this approach is that peers authorize event registration requests based on membership of request originator within their local MSP.	このアプローチで考慮すべきもう1つのポイントは、ピアがイベント登録要求を、ローカルMSP内のリクエスト組織のメンバーシップに基づいて行うことです。
Clearly, since the originator of the request is a client, the request originator is always deemed to belong to a different MSP than the requested peer and the peer would reject the request.	明らかに、リクエストの発行者はクライアントであるため、常にリクエスト組織はリクエストされたピアと異なるMSPに属しているとみなされ、ピアはリクエストを却下します。
4) Admin and CA certificates.	4) 管理者とCAの証明書
It is important to set MSP admin certificates to be different than any of the certificates considered by the MSP for ``root of trust``, or intermediate CAs.	MSPの管理者証明書を、 信頼のルート または中間CAのためにMSPが考慮する証明書とは異なるものに設定することは重要です。
This is a common (security) practice to separate the duties of management of membership components from the issuing of new certificates, and/or validation of existing ones.	これは、新しい証明書の発行、および/または既存の証明書の検証から、メンバーシップコンポーネントの管理義務を切り離すための一般的な (セキュリティの) 慣例です。
5) Blocking an intermediate CA.	5) 中間CAのブロック
As mentioned in previous sections, reconfiguration of an MSP is achieved by reconfiguration mechanisms (manual reconfiguration for the local MSP instances, and via properly constructed ``config_update`` messages for MSP instances of a channel).	前のセクションで述べたように、MSPの再設定は、再設定メカニズム (ローカルMSPインスタンスの手動での再設定、およびチャネルのMSPインスタンス用の、適切に構成された ``config_update`` メッセージを介した再設定) によって実現されます。
Clearly, there are two ways to ensure an intermediate CA considered in an MSP is no longer considered for that MSP's identity validation:	明らかに、MSPで考慮されている中間CAがそのMSPのアイデンティティ検証で使わなくするための2つの方法があります:
1. Reconfigure the MSP to no longer include the certificate of that intermediate CA in the list of trusted intermediate CA certs.	1. そのMSPを再設定して、信頼できる中間CA証明書のリストに対象となる中間CAの証明書が含まれないようにします。
For the locally configured MSP, this would mean that the certificate of this CA is removed from the ``intermediatecerts`` folder.	ローカルMSPでは、これは対象となるCA証明書が ``intermediatecerts`` フォルダから削除されることを意味します。
2. Reconfigure the MSP to include a CRL produced by the root of trust which denounces the mentioned intermediate CA's certificate.	2. そのMSPを再設定して、前述の中間CAの証明書を非難する、信頼のルートによって生成されたCRLを含むようにします。
In the current MSP implementation we only support method (1) as it is simpler and does not require blocking the no longer considered intermediate CA.	現在のMSP実装では、このうち(1)の方法のみをサポートしています。この方法のほうがシンプルであり、中間CAをブラックリスト化する必要がないためです。
6) CAs and TLS Cas	6) CAとTLS CA
MSP identities' root CAs and MSP TLS certificates' root CAs (and relative intermediate CAs) need to be declared in different folders.	MSPアイデンティティのルートCAとMSP TLS証明書のルートCA (およびそれらの各中間CA) は、別フォルダで宣言する必要があります。
This is to avoid confusion between different classes of certificates.	これは、異なるクラスの証明書が混同されないようにするためです。
It is not forbidden to reuse the same CAs for both MSP identities and TLS certificates but best practices suggest to avoid this in production.	MSPアイデンティティとTLS証明書の両方で同じCAを流用することは禁止されてはいませんが、ベストプラクティスとしては、本番においてはこれを避けることを提案しています。
Identity	アイデンティティ
What is an Identity?	アイデンティティとは？
The different actors in a blockchain network include peers, orderers, client applications, administrators and more.	ブロックチェーンネットワークには、peer、orderer、クライアントアプリケーション、管理者などさまざまなアクターが含まれます。
Each of these actors --- active elements inside or outside a network able to consume services --- has a digital identity encapsulated in an X.509 digital certificate.	これらの各アクター(サービスを消費できるネットワークの内部または外部のアクティブな要素)は、X.509デジタル証明書にカプセル化されたデジタルアイデンティティを持っています。
These identities really matter because they determine the exact permissions over resources and access to information that actors have in a blockchain network.	これらのアイデンティティは、ブロックチェーン・ネットワーク内のアクターが持つリソースや情報への正確なアクセス権を決定するため、非常に重要です。
A digital identity furthermore has some additional attributes that Fabric uses to determine permissions, and it gives the union of an identity and the associated attributes a special name --- principal.	さらにデジタルアイデンティティには、Fabricがアクセス権を決定するために使用するいくつかの追加属性があり、アイデンティティとそれに関連付けられた属性の組み合わせに特別な名前(プリンシパル)が与えられています。
Principals are just like userIDs or groupIDs, but a little more flexible because they can include a wide range of properties of an actor's identity, such as the actor's organization, organizational unit, role or even the actor's specific identity.	プリンシパルはユーザーIDやグループIDに似ていますが、アクターの組織、組織単位、ロール、さらにはアクター固有のアイデンティティなど、アクターのアイデンティティのさまざまなプロパティを含めることができるため、少し柔軟です。
When we talk about principals, they are the properties which determine their permissions.	このドキュメントでは、プリンシパルとは、アクセス権を決定するプロパティのことを指します。
For an identity to be verifiable, it must come from a trusted authority.	アイデンティティを検証可能にするには、信頼できる機関から取得する必要があります。
A [membership service provider](../membership/membership.html) (MSP) is that trusted authority in Fabric.	[メンバーシップ・サービス・プロバイダ](../membership/membership.html)(MSP)は、Fabricにおける信頼できる機関です。
More specifically, an MSP is a component that defines the rules that govern the valid identities for this organization.	より具体的には、MSPは、組織の有効なアイデンティティを管理する規則を定義するコンポーネントです。
The default MSP implementation in Fabric uses X.509 certificates as identities, adopting a traditional Public Key Infrastructure (PKI) hierarchical model (more on PKI later).	FabricのデフォルトのMSP実装では、アイデンティティとしてX.509証明書を使用し、従来の公開鍵基盤(PKI)階層モデルを採用しています(PKIの詳細については後述します)。
A Simple Scenario to Explain the Use of an Identity	アイデンティティの使用を説明する簡単なシナリオ
Imagine that you visit a supermarket to buy some groceries.	スーパーマーケットに買い物に行ったとします。
At the checkout you see a sign that says that only Visa, Mastercard and AMEX cards are accepted.	レジのところに、ビザ、マスターカード、アメックスカードしか使えないと書いてあります。
If you try to pay with a different card --- let's call it an "ImagineCard" --- it doesn't matter whether the card is authentic and you have sufficient funds in your account.	別のカード(「ImagineCard」と呼びましょう)で支払いをしようとする場合、カードが本物で、あなたの口座に十分な資金があるかどうかは、関係がありません。
It will be not be accepted.	そのカード会社が受け付けられないのです。
Having a valid credit card is not enough --- it must also be accepted by the store!	有効なクレジットカードを持っているだけでは十分ではなく、店舗にも受け入れてもらわないといけません！
PKIs and MSPs work together in the same way ---	PKIとMSPは同じように連携します。
a PKI provides a list of identities, and an MSP says which of these are members of a given organization that participates in the network.	つまり、PKIはアイデンティティのリストを提供し、MSPはこの中のどのアイデンティティがネットワークに参加する特定の組織のメンバーであるか指定します。
PKI certificate authorities and MSPs provide a similar combination of functionalities.	PKI認証局とMSPは、同様の機能の組み合わせを提供します。
A PKI is like a card provider --- it dispenses many different types of verifiable identities.	PKIはカードプロバイダーのようなもので、さまざまな種類の検証可能なアイデンティティを提供します。
An MSP, on the other hand, is like the list of card providers accepted by the store, determining which identities are the trusted members (actors) of the store payment network.	一方、MSPは、店舗が受け入れるカード・プロバイダーのリストのようなものであり、どのアイデンティティが店舗支払いネットワークの信頼できるメンバー(アクター)であるかを決定する仕組みに相当します。
MSPs turn verifiable identities into the members of a blockchain network.	MSPは、検証可能なアイデンティティをブロックチェーンネットワークのメンバーに変換します。
Let's drill into these concepts in a little more detail.	これらの概念をもう少し詳しく見ていきましょう。
What are PKIs?	PKIとは？
A public key infrastructure (PKI) is a collection of internet technologies that provides secure communications in a network.	公開鍵基盤(PKI)は、ネットワークで安全に通信を行うためのインターネット技術の集まりです。
It's PKI that puts the S in HTTPS ---	HTTPSのSを加えているのがPKIです。
and if you're reading this documentation on a web browser, you're probably using a PKI to make sure it comes from a verified source.	そして、この文書をWebブラウザーで読んでいるのであれば、おそらくPKIを使って、それが検証された情報源からのものであることを確認していることでしょう。
The elements of Public Key Infrastructure (PKI).	公開鍵基盤(PKI)の要素。
A PKI is comprised of Certificate Authorities who issue digital certificates to parties (e.g., users of a service, service provider), who then use them to authenticate themselves in the messages they exchange in their environment.	PKIは、関係者(例えば、サービスの利用者、サービス提供者)にデジタル証明書を発行する認証局から構成され、関係者はそれを使用して彼らの環境において交換するメッセージにおいて自分自身を認証します。
A CA's Certificate Revocation List (CRL) constitutes a reference for the certificates that are no longer valid.	CAの証明書失効リスト(CRL)は、有効でなくなった証明書の参照を構成します。
Revocation of a certificate can happen for a number of reasons.	証明書の失効は、さまざまな理由で発生する可能性があります。
For example, a certificate may be revoked because the cryptographic private material associated to the certificate has been exposed.	例えば、証明書は、その証明書に関連付けられた暗号の秘密情報が暴露されたために失効され得ます。
Although a blockchain network is more than a communications network, it relies on the PKI standard to ensure secure communication between various network participants, and to ensure that messages posted on the blockchain are properly authenticated.	ブロックチェーンネットワークは単なる通信ネットワークではありませんが、さまざまなネットワーク参加者間の安全な通信を確保し、ブロックチェーンに投稿されたメッセージが適切に認証されることを保証するために、PKI標準に依存しています。
It's therefore important to understand the basics of PKI and then why MSPs are so important.	したがって、PKIの基本を理解し、MSPがなぜそれほど重要なのかを理解することが重要です。
There are four key elements to PKI:	PKIには、次の4つの主要な要素があります。
Digital Certificates	デジタル証明書
Public and Private Keys	公開鍵と秘密鍵
Certificate Authorities	認証局
Certificate Revocation Lists	証明書失効リスト
Let's quickly describe these PKI basics, and if you want to know more details, [Wikipedia](https://en.wikipedia.org/wiki/Public_key_infrastructure) is a good place to start.	これらのPKIの基本について簡単に説明します。詳細を知りたい場合は、[Wikipedia](https://en.wikipedia.org/wiki/Public_key_infrastructure)から始めるとよいでしょう。
Digital Certificates	デジタル証明書
A digital certificate is a document which holds a set of attributes relating to the holder of the certificate.	デジタル証明書は、証明書の所有者に関する一連の属性を保持する文書です。
The most common type of certificate is the one compliant with the [X.509 standard](https://en.wikipedia.org/wiki/X.509), which allows the encoding of a party's identifying details in its structure.	最も一般的なタイプの証明書は、[X.509標準](https://en.wikipedia.org/wiki/X.509)に準拠したものであり、これは、その構造において、主体の識別詳細の符号化を可能にします。
For example, Mary Morris in the Manufacturing Division of Mitchell Cars in Detroit, Michigan might have a digital certificate with a `SUBJECT` attribute of `C=US`, `ST=Michigan`, `L=Detroit`, `O=Mitchell Cars`, `OU=Manufacturing`, `CN=Mary Morris /UID=123456`.	たとえば、ミシガン州デトロイト市のMitchell Carsの製造部門のメアリーモリス(Mary Morris)が、`SUBJECT`属性が`C=US`、`ST=Michigan`、`L=Detroit`、`O=Mitchell Cars`、`OU=Manufacturing`、`CN=Mary Morris /UID=123456`のデジタル証明書を持っているとします。
Mary's certificate is similar to her government identity card --- it provides information about Mary which she can use to prove key facts about her.	メアリーの証明書は、彼女の政府の身分証明書に似ています、つまり、彼女についての重要な事実を証明するために彼女が使用できる彼女の情報を提供します。
There are many other attributes in an X.509 certificate, but let's concentrate on just these for now.	X.509証明書には他にも多くの属性がありますが、ここではこれらの属性だけに注目します。
A digital certificate describing a party called Mary Morris.	メアリーモリスと呼ばれる主体を記述するデジタル証明書。
Mary is the `SUBJECT` of the certificate, and the highlighted `SUBJECT` text shows key facts about Mary.	メアリーは証明書の`SUBJECT`であり、強調表示された`SUBJECT`のテキストは、メアリーに関する重要な事実を示します。
The certificate also holds many more pieces of information, as you can see.	ご覧のように、証明書にはさらに多くの情報が保持されています。
Most importantly, Mary's public key is distributed within her certificate, whereas her private signing key is not.	最も重要なのは、メアリーの公開鍵がメアリーの証明書内で配布されるのに対し、メアリーの秘密署名鍵は配布されないことです。
This signing key must be kept private.	この署名鍵は秘密にしておく必要があります。
What is important is that all of Mary's attributes can be recorded using a mathematical technique called cryptography (literally, "secret writing") so that tampering will invalidate the certificate.	重要なのは、メアリーのすべての属性が、暗号技術(文字通りには「秘密の書き込み」)と呼ばれる数学的手法を使用して記録され、改ざんすれば証明書が無効になることです。
Cryptography allows Mary to present her certificate to others to prove her identity so long as the other party trusts the certificate issuer, known as a Certificate Authority (CA).	暗号技術によって、相手が認証局(CA)と呼ばれる証明書の発行元を信頼している限り、メアリーは自分の証明書を他の人に提示して自分の身元を証明できます。
As long as the CA keeps certain cryptographic information securely (meaning, its own private signing key), anyone reading the certificate can be sure that the information about Mary has not been tampered with ---	認証局が特定の暗号情報(つまり、自身の秘密署名鍵)を安全に保持している限り、証明書を見た誰もが、メアリーに関する情報が改ざんされていないことを確認できます。
it will always have those particular attributes for Mary Morris.	つまり、証明書が常にメアリーモリスの特定の属性を持つことを確認できるのです。
Think of Mary's X.509 certificate as a digital identity card that is impossible to change.	メアリーのX.509証明書は、変更不可能なデジタルアイデンティティカードと考えることができます。
Authentication, Public keys, and Private Keys	認証、公開鍵、および秘密鍵
Authentication and message integrity are important concepts in secure communications.	認証とメッセージ完全性は、安全な通信において重要な概念です。
Authentication requires that parties who exchange messages are assured of the identity that created a specific message.	認証においては、メッセージを交換する当事者が、そのアイデンティティが特定のメッセージを作成したことを確信できなくてはなりません。
For a message to have "integrity" means that cannot have been modified during its transmission.	メッセージが「完全性」を持つということは、伝送中に変更できなかったことを意味します。
For example, you might want to be sure you're communicating with the real Mary Morris rather than an impersonator.	たとえば、なりすましではない本物のメアリーモリスと通信していることを確認したいかもしれません。
Or if Mary has sent you a message, you might want to be sure that it hasn't been tampered with by anyone else during transmission.	あるいは、メアリーからメッセージが送信された場合は、伝送中に他のユーザによってメッセージが改ざんされていないことを確認したいかもしれません。
Traditional authentication mechanisms rely on digital signatures that, as the name suggests, allow a party to digitally sign its messages.	伝統的な認証メカニズムは、その名前が示すように、当事者がそのメッセージにデジタルに署名することを可能にするデジタル署名技術に依存します。
Digital signatures also provide guarantees on the integrity of the signed message.	デジタル署名は、署名されたメッセージの完全性も保証します。
Technically speaking, digital signature mechanisms require each party to hold two cryptographically connected keys: a public key that is made widely available and acts as authentication anchor, and a private key that is used to produce digital signatures on messages.	技術的に言えば、デジタル署名メカニズムでは、各当事者が2つの暗号的に接続された鍵を保持する必要があります。1つは、広く利用可能にされ、認証アンカーとして機能する公開鍵で、もう1つは、メッセージにデジタル署名を生成するために使用される秘密鍵です。
Recipients of digitally signed messages can verify the origin and integrity of a received message by checking that the attached signature is valid under the public key of the expected sender.	デジタル署名されたメッセージの受信者は、添付された署名が期待される送信者の公開鍵の下で有効であることを確認することによって、受信したメッセージの発信元と完全性を検証できます。
The unique relationship between a private key and the respective public key is the cryptographic magic that makes secure communications possible.	秘密鍵とそれに対応する公開鍵との間の固有の関係は、安全な通信を可能にする暗号マジックです。
The unique mathematical relationship between the keys is such that the private key can be used to produce a signature on a message that only the corresponding public key can match, and only on the same message.	鍵間の固有な数学的関係は、対応する公開鍵のみが同じメッセージに対してのみマッチする署名を、秘密鍵が作成できるというようなものです。
In the example above, Mary uses her private key to sign the message.	上の例では、メアリーは自分の秘密鍵を使用してメッセージに署名します。
The signature can be verified by anyone who sees the signed message using her public key.	署名は、彼女の公開鍵を使用することで、署名されたメッセージを見た人なら誰でも検証できます。
Certificate Authorities	認証局
As you've seen, an actor or a node is able to participate in the blockchain network, via the means of a digital identity issued for it by an authority trusted by the system.	これまで見てきたように、アクターまたはノードは、システムによって信頼された機関によって発行されたデジタルアイデンティティを介して、ブロックチェーンネットワークに参加することができます。
In the most common case, digital identities (or simply identities) have the form of cryptographically validated digital certificates that comply with X.509 standard and are issued by a Certificate Authority (CA).	最も一般的なケースでは、デジタルアイデンティティ(または単にアイデンティティ)は、X.509標準に準拠し、認証局(CA)によって発行される、暗号学的に検証されたデジタル証明書の形式を持ちます。
CAs are a common part of internet security protocols, and you've probably heard of some of the more popular ones: Symantec (originally Verisign), GeoTrust, DigiCert, GoDaddy, and Comodo, among others.	CAはインターネットセキュリティプロトコルの共通のパーツであり、Symantec(元はVerisign)、GeoTrust、DigiCert、GoDaddy、Comodoなど、より一般的なCAのいくつかを聞いたことがあるでしょう。
A Certificate Authority dispenses certificates to different actors.	認証局は、異なるアクターに証明書を配布します。
These certificates are digitally signed by the CA and bind together the actor with the actor's public key (and optionally with a comprehensive list of properties).	これらの証明書は、CAによってデジタル署名され、アクターの公開鍵(およびオプションで、プロパティの包括的なリスト)をアクターと結びつけます。
As a result, if one trusts the CA (and knows its public key), it can trust that the specific actor is bound to the public key included in the certificate, and owns the included attributes, by validating the CA's signature on the actor's certificate.	その結果、CAを信頼する(そして、その公開鍵を知っている)場合、そのアクターの証明書上のCAの署名を検証することによって、その特定のアクターが、その証明書に含まれる公開鍵に結びついており、証明書に含まれる属性を所有することを信頼することができます。
Certificates can be widely disseminated, as they do not include either the actors' nor the CA's private keys.	証明書は、アクターの秘密鍵もCAの秘密鍵も含まないので、広く配布することができます。
As such they can be used as anchor of trusts for authenticating messages coming from different actors.	したがって、異なるアクターからのメッセージを認証するための信頼のアンカーとして使用できます。
CAs also have a certificate, which they make widely available.	CAも証明書を持っており、広く入手可能になっています。
This allows the consumers of identities issued by a given CA to verify them by checking that the certificate could only have been generated by the holder of the corresponding private key (the CA).	これにより、特定のCAによって発行されたアイデンティティを受け取った側は、証明書が対応する秘密鍵の所有者(CA)によってのみ生成されえたことを確認することによって、アイデンティティを検証できます。
In a blockchain setting, every actor who wishes to interact with the network needs an identity.	ブロックチェーンの設定では、ネットワークと対話したいすべてのアクターにアイデンティティが必要です。
In this setting, you might say that one or more CAs can be used to define the members of an organization's from a digital perspective.	この設定では、1つ以上のCAを使用して、デジタルの観点から組織のメンバーを定義できます。
It's the CA that provides the basis for an organization's actors to have a verifiable digital identity.	組織のアクターが検証可能なデジタルアイデンティティを持つための基盤を提供するのは、CAです。
Root CAs, Intermediate CAs and Chains of Trust	ルートCA、中間CA、および信頼のチェーン
CAs come in two flavors: Root CAs and Intermediate CAs.	CAには、ルートCAと中間CAの2種類があります。
Because Root CAs (Symantec, Geotrust, etc) have to securely distribute hundreds of millions of certificates to internet users, it makes sense to spread this process out across what are called Intermediate CAs.	ルートCA(Symantec、Geotrustなど)は、数億個の証明書をインターネットユーザに安全に配布する必要があるため、このプロセスを中間CAと呼ばれるものに分散することは理にかなっています。
These Intermediate CAs have their certificates issued by the root CA or another intermediate authority, allowing the establishment of a "chain of trust" for any certificate that is issued by any CA in the chain.	これらの中間CAは、ルートCAまたは別の中間CAによって発行された証明書を有し、チェーン内の任意のCAによって発行された任意の証明書のための「信頼のチェーン」の確立を可能にします。
This ability to track back to the Root CA not only allows the function of CAs to scale while still providing security --- allowing organizations that consume certificates to use Intermediate CAs with confidence --- it limits the exposure of the Root CA, which, if compromised, would endanger the entire chain of trust.	このルートCAまで遡る能力は、セキュリティを提供しながら(証明書を消費する組織が安心して中間CAを使用できるようしながら)CAの機能をスケールできるようにするだけでなく、侵害された場合、信頼のチェーン全体が危険になるルートCAのリスクを限定します。
If an Intermediate CA is compromised, on the other hand, there will be a much smaller exposure.	一方、中間CAが侵害された場合は、はるかに少ないリスクしかありません。
A chain of trust is established between a Root CA and a set of Intermediate CAs as long as the issuing CA for the certificate of each of these Intermediate CAs is either the Root CA itself or has a chain of trust to the Root CA.	信頼のチェーンは、ルートCAと一連の中間CAとの間で確立されます。ただし、これらの各中間CAの証明書の発行元CAが、ルートCA自体であるか、ルートCAに対する信頼のチェーンを持っている必要があります。
Intermediate CAs provide a huge amount of flexibility when it comes to the issuance of certificates across multiple organizations, and that's very helpful in a permissioned blockchain system (like Fabric).	中間CAは、複数の組織にわたる証明書の発行に関して非常に柔軟性があり、許可型ブロックチェーン・システム(Fabricなど)で非常に役立ちます。
For example, you'll see that different organizations may use different Root CAs, or the same Root CA with different Intermediate CAs --- it really does depend on the needs of the network.	たとえば、異なる組織が異なるルートCAを使用する場合や、異なる中間CAを介して同じルートCAを使用する場合がありますが、実際にはネットワークのニーズによって異なります。
It's because CAs are so important that Fabric provides a built-in CA component to allow you to create CAs in the blockchain networks you form.	CAが非常に重要であるため、作成したブロックチェーンネットワークにCAを作成できるよう、Fabricは組み込みのCAコンポーネントを提供します。
This component --- known as Fabric CA is a private root CA provider capable of managing digital identities of Fabric participants that have the form of X.509 certificates.	このコンポーネントは、Fabric CAと呼ばれ、X.509証明書の形式を持つFabric参加者のデジタルアイデンティティを管理できるプライベートルートCAプロバイダーです。
Because Fabric CA is a custom CA targeting the Root CA needs of Fabric, it is inherently not capable of providing SSL certificates for general/automatic use in browsers.	Fabric CAは、FabricのルートCAのニーズを満たすためのカスタムCAであるため、本来的には、ブラウザでの一般的/自動的な使用のためのSSL証明書を提供することはできません。
However, because some CA must be used to manage identity (even in a test environment), Fabric CA can be used to provide and manage certificates.	ただし、なんらかのCAを使用してアイデンティティを管理する必要があるため(テスト環境でも)、Fabric CAを使用して証明書を提供および管理できます。
It is also possible --- and fully appropriate --- to use a public/commercial root or intermediate CA to provide identification.	また、公開/商用のルートまたは中間CAを使用して識別情報を提供することも可能ですし、それもまた完全に適切なことです。
If you're interested, you can read a lot more about Fabric CA [in the CA documentation section](http://hyperledger-fabric-ca.readthedocs.io/).	Fabric CAの詳細について興味があれば、[CAのドキュメントのセクション](http://hyperledger-fabric-ca.readthedocs.io/)を参照してください。
Certificate Revocation Lists	証明書失効リスト
A Certificate Revocation List (CRL) is easy to understand ---	証明書失効リスト(CRL)は簡単に理解できます。
it's just a list of references to certificates that a CA knows to be revoked for one reason or another.	CRLは、何らかの理由で失効したことをCAが認識している証明書への参照の一覧にすぎません。
If you recall the store scenario, a CRL would be like a list of stolen credit cards.	店舗のシナリオを思い出してみると、CRLは盗まれたクレジットカードのリストのようなものです。
When a third party wants to verify another party's identity, it first checks the issuing CA's CRL to make sure that the certificate has not been revoked.	第3者が、別の主体のアイデンティティを検証したい場合、最初に、証明書が失効されていないことを確かめるために、発行元CAのCRLをチェックします。
A verifier doesn't have to check the CRL, but if they don't they run the risk of accepting a compromised identity.	検証者はCRLをチェックする必要はありませんが、チェックしなければ、侵害されたアイデンティティを受け入れるリスクがあります。
Using a CRL to check that a certificate is still valid.	証明書がまだ有効であることを確認するためのCRLの使用。
If an impersonator tries to pass a compromised digital certificate to a validating party, it can be first checked against the issuing CA's CRL to make sure it's not listed as no longer valid.	なりすました人が侵害されたデジタル証明書を検証側に渡そうとした場合、最初に発行元の認証局のCRLと照合して、その証明書が有効でないことを確認できます。
Note that a certificate being revoked is very different from a certificate expiring.	証明書の失効は、証明書の期限切れとは大きく異なることに注意してください。
Revoked certificates have not expired ---	失効された証明書は、期限が切れていません。
they are, by every other measure, a fully valid certificate.	失効されたこと以外のすべての点において、完全に有効な証明書です。
For more in-depth information about CRLs, click [here](https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#generating-a-crl-certificate-revocation-list).	CRLの詳細については、[ここ](https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#generating-a-crl-certificate-revocation-list)をクリックしてください。
Now that you've seen how a PKI can provide verifiable identities through a chain of trust, the next step is to see how these identities can be used to represent the trusted members of a blockchain network.	PKIが信頼のチェーンを通じて検証可能なアイデンティティを提供する方法を見てきましたが、次のステップは、これらのアイデンティティを使用してブロックチェーン・ネットワークの信頼できるメンバーを表す方法を見ていきます。
That's where a Membership Service Provider (MSP) comes into play --- it identifies the parties who are the members of a given organization in the blockchain network.	メンバーシップサービスプロバイダー(MSP)が登場し、ブロックチェーンネットワーク内の特定の組織のメンバーである主体を識別します。
To learn more about membership, check out the conceptual documentation on [MSPs](../membership/membership.html).	メンバーシップの詳細については、[MSP](../membership/membership.html)のコンセプトドキュメントを参照してください。
Introduction	はじめに
Hyperledger Fabric is a platform for distributed ledger solutions underpinned by a modular architecture delivering high degrees of confidentiality, resiliency, flexibility, and scalability .	HyperledgerFabricは、高度な機密性、耐障害性、柔軟性、および拡張性を提供するモジュラー型アーキテクチャによって支えられた、分散台帳ソリューション用のプラットフォームです。
It is designed to support pluggable implementations of different components and accommodate the complexity and intricacies that exist across the economic ecosystem .	異なるコンポーネントがプラグイン可能な実装となっており、経済的なエコシステム全体に存在する複雑で入り組んだ課題に対応するように設計されています。
We recommend first-time users begin by going through the rest of the introduction below in order to gain familiarity with how blockchains work and with the specific features and components of Hyperledger Fabric .	ブロックチェーンの仕組みや、HyperledgerFabricの特定の機能やコンポーネントについての知識を得るために、初心者のユーザーには、以下の導入から読み進めることをお勧めします。
Once comfortable --- or if you're already familiar with blockchain and Hyperledger Fabric --- go to :doc:`getting_started` and from there explore the demos, technical specifications, APIs, etc .	いったん目を通したら --- もしくはブロックチェーンやHyperledger Fabricに既に慣れ親しんでいる人は --- :doc:`getting_started` へ読み進めて、デモや技術仕様、APIなどに触れてみてください。
What is a Blockchain?	ブロックチェーンとは?
A Distributed Ledger	分散台帳
At the heart of a blockchain network is a distributed ledger that records all the transactions that take place on the network .	ブロックチェーンネットワークの中核には、ネットワーク上で行われるすべてのトランザクションを記録する分散台帳があります。
A blockchain ledger is often described as decentralized because it is replicated across many network participants, each of whom collaborate in its maintenance .	ブロックチェーン上の台帳は、ネットワーク参加者の多くに複製され、各参加者が協力してデータを保持することから、多くの場合、分散型と呼ばれます。
We’ll see that decentralization and collaboration are powerful attributes that mirror the way businesses exchange goods and services in the real world .	このデータの分散化と参加者の協力関係が、企業が現実世界で商品やサービスをやりとりする方法を反映した強力な特性であることがわかります。
In addition to being decentralized and collaborative, the information recorded to a blockchain is append-only, using cryptographic techniques that guarantee that once a transaction has been added to the ledger it cannot be modified .	分散化と協調関係に加えて、ブロックチェーンに記録される情報は追記されるのみであり、一度トランザクションが台帳に追加されると変更できないことを暗号技術を利用して保証しています。
This property of "immutability" makes it simple to determine the provenance of information because participants can be sure information has not been changed after the fact .	不変性というこの特性により、参加者は情報が事後に変更されていないことを確認できるため、情報の出所を簡単に判断できます。
It’s why blockchains are sometimes described as systems of proof .	そのため、ブロックチェーンは証明システムと呼ばれることがあります。
Smart Contracts	スマートコントラクト
To support the consistent update of information --- and to enable a whole host of ledger functions (transacting, querying, etc) --- a blockchain network uses smart contracts to provide controlled access to the ledger .	情報の一貫した更新をサポートするために --- そして台帳機能(トランザクション、クエリーなど)をホスト全体で有効にするために --- ブロックチェーンネットワークは スマートコントラクト を使用して、台帳への制御されたアクセスを提供します。
Smart contracts are not only a key mechanism for encapsulating information and keeping it simple across the network, they can also be written to allow participants to execute certain aspects of transactions automatically .	スマートコントラクトは、情報をカプセル化してネットワーク全体でシンプルに保つための重要なメカニズムであるだけでなく、参加者がトランザクションに関して特定の処理を自動的に実行するためにも利用することが可能です。
A smart contract can, for example, be written to stipulate the cost of shipping an item where the shipping charge changes depending on how quickly the item arrives .	両当事者間で合意され、台帳に書き込まれた条件により、適切な報酬が品目の受入と同時に然るべき当事者の元に自動的で渡されます。
With the terms agreed to by both parties and written to the ledger, the appropriate funds change hands automatically when the item is received .	例えば、商品がどれだけ早く到着するかによって送料が変動するような、商品配送コストの規定にスマートコントラクトを利用することができます。
Consensus	合意形成
The process of keeping the ledger transactions synchronized across the network --- to ensure that ledgers update only when transactions are approved by the appropriate participants, and that when ledgers do update, they update with the same transactions in the same order --- is called consensus .	適切な参加者によってトランザクションが承認された場合にのみ台帳が更新され、台帳の更新時に同じトランザクションが同じ順序で更新されるように、ネットワーク全体で台帳取引を同期化するプロセスのことを合意形成と呼びます。
You'll learn a lot more about ledgers, smart contracts and consensus later .	台帳、スマートコントラクト、合意形成については後で詳しく学んでいきます。
For now, it’s enough to think of a blockchain as a shared, replicated transaction system which is updated via smart contracts and kept consistently synchronized through a collaborative process called consensus .	現時点では、ブロックチェーンは共有され、複製されたトランザクションシステムであり、スマートコントラクトを通じて更新され、合意形成と呼ばれる共同プロセスを通じて一貫して同期されていると考えるだけで十分です。
Why is a Blockchain useful?	ブロックチェーンが有用な理由とは?
Today’s Systems of Record	今日の記録システム
The transactional networks of today are little more than slightly updated versions of networks that have existed since business records have been kept .	今日のトランザクションネットワークは、ビジネス記録が保存されるようになった頃から存在していたネットワークをわずかに更新しただけのものです。
The members of a business network transact with each other, but they maintain separate records of their transactions .	ビジネスネットワークのメンバーは互いにトランザクションを行いますが、トランザクションのレコードは別々に保持します。
And the things they’re transacting --- whether it’s Flemish tapestries in the 16th century or the securities of today --- must have their provenance established each time they’re sold to ensure that the business selling an item possesses a chain of title verifying their ownership of it .	16世紀のフランダース地方の織物であろうと、今日の証券であろうと、彼らが取引するものは、販売されるたびにその出所が確立されていなければなりません。それは商品を販売する事業者が現在その所有権を持っていることを所有権の変遷の情報によって保証するためです。
What you’re left with is a business network that looks like this:	あなたが考える必要があるのは、次のようなビジネスネットワークです。
Modern technology has taken this process from stone tablets and paper folders to hard drives and cloud platforms, but the underlying structure is the same.	現代の技術では、このプロセスを石板や紙のフォルダからハードドライブやクラウドプラットフォームにまで拡張していますが、基本的な構造は同じです。
Unified systems for managing the identity of network participants do not exist, establishing provenance is so laborious it takes days to clear securities transactions (the world volume of which is numbered in the many trillions of dollars), contracts must be signed and executed manually, and every database in the system contains unique information and therefore represents a single point of failure .	ネットワーク参加者の身元を管理するための統一されたシステムは存在せず、出所を確認するのは非常に骨の折れる作業であり、証券取引(数兆ドル規模の世界の取引量)を決済するのに数日を要し、契約は手動で署名され、実行されなければならず、システム内のすべてのデータベースには固有の情報が含まれているため、単一障害点を表します。
It’s impossible with today’s fractured approach to information and process sharing to build a system of record that spans a business network, even though the needs of visibility and trust are clear .	情報やプロセスの共有に関して分断されている今日のアプローチでは、たとえ可視性と信頼性のニーズが明確であっても、ビジネスネットワークにまたがる記録システムを構築することは不可能です。
The Blockchain Difference	ブロックチェーンの違い
What if, instead of the rat’s nest of inefficiencies represented by the “modern” system of transactions, business networks had standard methods for establishing identity on the network, executing transactions, and storing data?	現代的なトランザクションシステムに代表される非効率かつ複雑なシステムの代わりに、ビジネスネットワークにネットワーク上での身元確認、トランザクションの実行、データの保存のための標準的な方法があったとしたらどうでしょうか?
What if establishing the provenance of an asset could be determined by looking through a list of transactions that, once written, cannot be changed, and can therefore be trusted?	一度書き込まれたら書き換えることができない、信頼できるトランザクションのリストを調べることで、資産の出所を確認できるとしたらどうでしょうか?
That business network would look more like this:	このビジネスネットワークは、次のようになります:
This is a blockchain network, wherein every participant has their own replicated copy of the ledger .	これがブロックチェーンネットワークであり、すべての参加者が独自の複製された台帳のコピーを持ちます。
In addition to ledger information being shared, the processes which update the ledger are also shared .	台帳情報の共有に加えて、台帳を更新するプロセスも共有されます。
Unlike today’s systems, where a participant’s private programs are used to update their private ledgers, a blockchain system has shared programs to update shared ledgers .	参加者のプライベートプログラムを使用してプライベートな台帳を更新する現在のシステムとは異なり、ブロックチェーンシステムでは共有する台帳を更新する共有プログラムが存在します。
With the ability to coordinate their business network through a shared ledger, blockchain networks can reduce the time, cost, and risk associated with private information and processing while improving trust and visibility .	共有台帳を通じてビジネスネットワークを統合する機能により、ブロックチェーンネットワークは、信頼性と可視性を向上させながら、プライベートな情報とプロセスに関連する時間、コスト、リスクを削減できます。
You now know what blockchain is and why it’s useful .	これで、ブロックチェーンとは何か、なぜブロックチェーンが便利なのか、が分かったかと思います。
There are a lot of other details that are important, but they all relate to these fundamental ideas of the sharing of information and processes .	他にも重要なことはたくさんありますが、それらはすべて、情報とプロセスの共有という、ここで説明した基本的な考え方に関係しています。
What is Hyperledger Fabric?	Hyperledger Fabricとは?
The Linux Foundation founded the Hyperledger project in 2015 to advance cross-industry blockchain technologies .	Linux Foundationは、業界横断的なブロックチェーン技術を発展させるために、2015年にHyperledgerプロジェクトを設立しました。
Rather than declaring a single blockchain standard, it encourages a collaborative approach to developing blockchain technologies via a community process, with intellectual property rights that encourage open development and the adoption of key standards over time .	単一のブロックチェーン標準を推進するのではなく、コミュニティプロセスを通じてブロックチェーン技術を開発するための協調的なアプローチを奨励しており、知的財産権によって、オープンな開発と長期にわたる主要な標準の採用を促進しています。
Hyperledger Fabric is one of the blockchain projects within Hyperledger .	Hyperledger Fabricは、Hyperledger内のブロックチェーンプロジェクトの1つです。
Like other blockchain technologies, it has a ledger, uses smart contracts, and is a system by which participants manage their transactions .	他のブロックチェーン技術と同様に、台帳があり、スマートコントラクトを使用し、参加者自身がトランザクションを管理するシステムです。
Where Hyperledger Fabric breaks from some other blockchain systems is that it is private and permissioned .	Hyperledger Fabricが他のブロックチェーンシステムと異なる点は、 プライベート であり、許可型 であることです。
Rather than an open permissionless system that allows unknown identities to participate in the network (requiring protocols like "proof of work" to validate transactions and secure the network), the members of a Hyperledger Fabric network enroll through a trusted Membership Service Provider (MSP) .	Hyperledger Fabricネットワークのメンバーは、匿名の参加者がネットワークに参加できるようにするオープンな参加許可の必要ないシステム(トランザクションを検証し、ネットワークを保護するために\"Proof of Work\"などのプロトコルが必要)ではなく、信頼できる メンバーシップサービスプロバイダ (MSP) を通じて登録します。
Hyperledger Fabric also offers several pluggable options .	Hyperledger Fabricは、いくつかのプラグイン可能なオプションも提供します。
Ledger data can be stored in multiple formats, consensus mechanisms can be swapped in and out, and different MSPs are supported .	台帳データは複数のフォーマットで保存でき、合意形成メカニズムは変更が可能であり、異なるMSPがサポートされます。
Hyperledger Fabric also offers the ability to create channels, allowing a group of participants to create a separate ledger of transactions .	Hyperledger Fabricには、 チャネル を作成する機能もあり、参加者のグループがトランザクションの個別の台帳を作成できます。これは、ネットワークにとって特に重要なオプションです。
This is an especially important option for networks where some participants might be competitors and not want every transaction they make --- a special price they're offering to some participants and not others, for example --- known to every participant .	参加者の中には競合他社もいるかもしれません。そのため、自分たちが行うすべてのトランザクション --- たとえば、他の参加者ではなく一部の参加者に提供する特別な価格 --- をすべての参加者に知らせたくないと考える参加者もいます。
If two participants form a channel, then those participants --- and no others --- have copies of the ledger for that channel .	2人の参加者が1つのチャネルを形成する場合、そのチャネルへの参加者である2人だけがそのチャネルの台帳のコピーを保持します。
Shared Ledger	共有台帳
Hyperledger Fabric has a ledger subsystem comprising two components: the world state and the transaction log .	Hyperledger Fabricには、 ワールドステート と トランザクションログ という2つのコンポーネントで構成される台帳サブシステムがあります。
Each participant has a copy of the ledger to every Hyperledger Fabric network they belong to .	各参加者は、所属するすべてのHyperledger Fabricネットワークに台帳のコピーを持っています。
The world state component describes the state of the ledger at a given point in time .	ワールドステートコンポーネントは、特定の時点における台帳の状態を記述します。
It’s the database of the ledger .	これは台帳のデータベースです。
The transaction log component records all transactions which have resulted in the current value of the world state; it’s the update history for the world state .	トランザクションログコンポーネントには、ワールドステートが現在の値となるまでのすべてのトランザクションが記録されます。
The ledger, then, is a combination of the world state database and the transaction log history .	ワールドステートの更新履歴です。したがって、台帳は、ワールドステートデータベースとトランザクションログ履歴の組合せというわけです。
The ledger has a replaceable data store for the world state .	台帳には、ワールドステートに対する変更可能なデータストアがあります。
By default, this is a LevelDB key-value store database .	既定では、ワールドステートのデータストアはLevelDBキーバリューストアデータベースです。
The transaction log does not need to be pluggable .	トランザクションログをプラグイン可能にする必要はありません。
It simply records the before and after values of the ledger database being used by the blockchain network .	ブロックチェーンネットワークで使用されている台帳データベースの変更前の値と変更後の値を記録するだけです。
Smart Contracts	スマートコントラクト
Hyperledger Fabric smart contracts are written in chaincode and are invoked by an application external to the blockchain when that application needs to interact with the ledger .	Hyperledger Fabricスマートコントラクトは、 チェーンコード で記述され、ブロックチェーン外部のアプリケーションが台帳とデータのやり取りをする必要がある場合に、そのアプリケーションによって起動されます。
In most cases, chaincode interacts only with the database component of the ledger, the world state (querying it, for example), and not the transaction log .	ほとんどの場合、チェーンコードは、台帳のデータベースコンポーネント、ワールドステート(クエリなど)とのみデータのやり取りをし、トランザクションログにはアクセスしません。
Chaincode can be implemented in several programming languages .	チェーンコードは、いくつかのプログラミング言語で実装できます。
Currently, Go and Node are supported .	現在、GoとNodeをサポートしています。
Privacy	プライバシー
Depending on the needs of a network, participants in a Business-to-Business (B2B) network might be extremely sensitive about how much information they share .	ネットワークのニーズに応じて、Business-to-Business(B2B)ネットワークの参加者は、共有する情報の量について非常に慎重になる場合があります。
For other networks, privacy will not be a top concern .	他のブロックチェーンネットワークでは、プライバシーは最大の関心事ではないでしょう。
Hyperledger Fabric supports networks where privacy (using channels) is a key operational requirement as well as networks that are comparatively open .	Hyperledger Fabricは、プライバシー(チャネルを使用)が重要な運用要件であるネットワークと、比較的オープンなネットワークをサポートします。
Consensus	合意形成
Transactions must be written to the ledger in the order in which they occur, even though they might be between different sets of participants within the network .	トランザクションは、ネットワークにおいて参加者の異なるセットの間で発生したものであっても、発生した順序で台帳に書き込まれる必要があります。
For this to happen, the order of transactions must be established and a method for rejecting bad transactions that have been inserted into the ledger in error (or maliciously) must be put into place .	これを実現するには、トランザクションの順序を確立し、誤って(または悪意を持って)台帳に挿入された不良トランザクションを拒否する方法を確立する必要があります。
This is a thoroughly researched area of computer science, and there are many ways to achieve it, each with different trade-offs .	この課題はコンピューター科学において徹底的に研究された分野であり、それを達成する方法はたくさんあり、それぞれに異なるトレードオフがあります。
For example, PBFT (Practical Byzantine Fault Tolerance) can provide a mechanism for file replicas to communicate with each other to keep each copy consistent, even in the event of corruption .	たとえば、PBFT(実用的ビザンチン障害耐性)は、故障が発生した場合でも各コピーの整合性を維持するために、ファイルの複製が相互に通信するメカニズムを提供します。
Alternatively, in Bitcoin, ordering happens through a process called mining where competing computers race to solve a cryptographic puzzle which defines the order that all processes subsequently build upon .	一方、Bitcoinでは、マイニングと呼ばれるプロセスを通じて順序付けが行われ、競合するコンピューターが、ブロックの順序を定義する暗号パズルを解く競争をし、その定義された順序に基づいて、その後の全てのプロセスが進められます。
Hyperledger Fabric has been designed to allow network starters to choose a consensus mechanism that best represents the relationships that exist between participants .	Hyperledger Fabricは、ネットワークの発起人が参加者間に存在する関係を最もよく表す合意形成メカニズムを選択できるように設計されています。
As with privacy, there is a spectrum of needs; from networks that are highly structured in their relationships to those that are more peer-to-peer .	プライバシーの場合と同様に、さまざまなニーズがあります。高度に構造化されたネットワークから、ピアツーピアのネットワークまで、さまざまなニーズがあります。
Chaincode is a program, written in [Go](https://golang.org), [Node.js](https://nodejs.org), or [Java](https://java.com/en/) that implements a prescribed interface.	チェーンコードは、[Go](https://golang.org)、[Node.js](https://nodejs.org)、または[Java](https://java.com/en/)で書かれたプログラムで、所定のインタフェースを実装したものです。
Chaincode runs in a secured Docker container isolated from the endorsing peer process.	チェーンコードは、エンドーシングピアのプロセスから分離された安全なDockerコンテナ内で動作します。
Chaincode initializes and manages ledger state through transactions submitted by applications.	チェーンコードは、アプリケーションから送信されたトランザクションを通じて、台帳のステートの初期化と管理をします。
A chaincode typically handles business logic agreed to by members of the network, so it may be considered as a "smart contract".	チェーンコードは通常、ネットワークのメンバーが合意したビジネスロジックを処理するため、「スマートコントラクト」と見なすことができます。
Ledger updates created by a chaincode are scoped exclusively to that chaincode and can't be accessed directly by another chaincode.	あるチェーンコードによって作成された台帳の更新は、そのチェーンコードのみに排他的にスコープされ、他のチェーンコードから直接アクセスすることはできません。
However, within the same network, given the appropriate permission a chaincode may invoke another chaincode to access its state.	ただし、同じネットワーク内では、適切な権限が与えられている場合、チェーンコードは別のチェーンコードを呼び出してそのステートにアクセスできます。
In this concept topic, we will explore chaincode through the eyes of a blockchain network operator rather than an application developer.	このコンセプトトピックでは、アプリケーション開発者ではなく、ブロックチェーンネットワークの運用者の視点でチェーンコードを探索します。
Chaincode operators can use this topic as a guide to how to use the Fabric chaincode lifecycle to deploy and manage chaincode on their network.	チェーンコードの運用者は、このトピックを、Fabricのチェーンコードライフサイクルを用いて、ネットワーク上にチェーンコードをデプロイして管理する方法のガイドとして使用することができます。
The Fabric chaincode lifecycle is a process that allows multiple organizations to agree on how a chaincode will be operated before it can be used on a channel.	Fabricのチェーンコードライフサイクルは、チャネル上で使用される前に、複数の組織がチェーンコードをどのように運用するかについて合意できるようにするプロセスです。
A network operator would use the Fabric lifecycle to perform the following tasks:	ネットワーク運用者は、Fabricライフサイクルを使用して以下のタスクを実行します。
You can use the Fabric chaincode lifecycle by creating a new channel and setting the channel capabilities to V2_0.	新しいチャネルを作成してチャネルのケーパビリティをV2_0に設定することで、Fabricのv2.0からの新しいチェーンコードライフサイクルを使用することができます。
You will not be able to use the old lifecycle to install, instantiate, or update a chaincode on channels with V2_0 capabilities enabled.	V2_0ケーパビリティが有効になっているチャネルでは、v1.4.x以前の古いライフサイクルを使用して、チェーンコードをインストール、インスタンス化、または更新することはできません。
If you are upgrading from a v1.4.x network and need to edit your channel configurations to enable the new lifecycle, check out [Enabling the new chaincode lifecycle](./enable_cc_lifecycle.html).	ネットワークをv1.4.xからアップグレードし、新しいライフサイクルを有効にするためにチャネル設定を編集する必要がある場合は、[Enabling the new chaincode lifecycle]( ./enable_cc_lifecycle.html)をチェックしてください。
Fabric chaincode lifecycle requires that organizations agree to the parameters that define a chaincode, such as name, version, and the chaincode endorsement policy.	Fabricのチェーンコードライフサイクルでは、名前、バージョン、チェーンコードエンドースメントポリシーなど、チェーンコードを定義するパラメータに組織が同意する必要があります。
Channel members come to agreement using the following four steps.	チャネルメンバーは、次の4つのステップを使用して合意に達します。
Not every organization on a channel needs to complete each step.	チャネル上のすべての組織が各ステップを完了する必要があるわけではありません。
1. Package the chaincode: This step can be completed by one organization or  by each organization.	1. チェーンコードをパッケージ化する: このステップは、1つの組織または各組織で実行できます。
2. Install the chaincode on your peers:	2. 自組織のピアにチェーンコードをインストールする:
Every organization that will use the  chaincode to endorse a transaction or query the ledger needs to complete this  step.	チェーンコードを使用してトランザクションのエンドースや台帳へのクエリをするすべての組織は、このステップを完了する必要があります。
3. Approve a chaincode definition for your organization:	3. 自組織のチェーンコード定義を承認する:
Every organization  that will use the chaincode needs to complete this step.	チェーンコードを使用するすべての組織は、このステップを完了する必要があります。
The chaincode  definition needs to be approved by a sufficient number of organizations  to satisfy the channel's LifecycleEndorsment policy (a majority, by default)  before the chaincode can be started on the channel.	チェーンコード定義は、チャネルでチェーンコードを開始する前に、チャネルのLifecycleEndorsementポリシー (デフォルトでは過半数) を満たすのに十分な数の組織によって承認される必要があります。
4. Commit the chaincode definition to the channel:	4. チェーンコード定義をチャネルにコミットする:
The commit transaction  needs to be submitted by one organization once the required number of  organizations on the channel have approved.	チャネル上の必要な数の組織が承認したら、コミットトランザクションを1つの組織が送信する必要があります。
The submitter first collects  endorsements from enough peers of the organizations that have approved, and  then submits the transaction to commit the chaincode definition.	送信者はまず、承認した組織の十分な数のピアからエンドースメントを集め、次にトランザクションを送信して、チェーンコード定義をコミットします。
This topic provides a detailed overview of the operations of the Fabric chaincode lifecycle rather than the specific commands.	本トピックでは、詳しいコマンドではなく、Fabricのチェーンコードライフサイクル運用の詳細な概要を示します。
To learn more about how to use the Fabric lifecycle using the Peer CLI, see the [Deploying a smart contract to a channel tutorial](deploy_chaincode.html) or the [peer lifecycle command reference](commands/peerlifecycle.html).	ピアCLIを使用してFabricライフサイクルを使用する方法の詳細については、[Deploying a smart contract to a channel tutorial](deploy_chaincode.html)または[peer lifecycle command reference](commands/peerlifecycle.html)を参照してください。
Chaincode needs to be packaged in a tar file before it can be installed on your peers.	チェーンコードは、ピアにインストールする前に tar ファイルにパッケージ化する必要があります。
You can package a chaincode using the Fabric peer binaries, the Node Fabric SDK, or a third party tool such as GNU tar.	チェーンコードをパッケージ化するには、Fabricのピアバイナリ、Node Fabric SDK (訳注: v2.2.0リリース時点ではNode.js版SDKでは未サポートと思われます)、または GNU tar のようなサードパーティのツールを使用します。
When you create a chaincode package, you need to provide a chaincode package label to create a succinct and human readable description of the package.	チェーンコードパッケージを作成する際には、そのパッケージの簡潔でヒューマンリーダブルな説明を作成するためにチェーンコードパッケージラベルを指定する必要があります。
If you use a third party tool to package the chaincode, the resulting file needs to be in the format below.	サードパーティのツールを使用してチェーンコードをパッケージ化する場合、結果として得られるファイルは以下の形式である必要があります。
The Fabric peer binaries and the Fabric SDKs will automatically create a file in this format.	FabricのピアバイナリとFabric SDKは、この形式のファイルを自動的に作成します。
The chaincode needs to be packaged in a tar file, ending with a `.tar.gz` file  extension.	チェーンコードは、`.tar.gz`ファイル拡張子で終わるtarファイルにパッケージ化する必要があります。
The tar file needs to contain two files (no directory): a metadata file  "metadata.json" and another tar "code.tar.gz" containing the chaincode files.	tarファイルには2つのファイル (ディレクトリなし) が含まれている必要があります。それはメタデータファイル「metadata.json」とチェーンコードファイルを含むtarファイル「code.tar.gz」です。
metadata.json contains JSON that specifies the  chaincode language, code path, and package label.	「metadata.json」には、チェーンコードの記述言語、コードへのパス、パッケージラベルを指定するJSONが含まれています。
You can see an example of  a metadata file below:	以下にメタデータファイルの例を示します:
The chaincode is packaged separately by Org1 and Org2.	チェーンコードは、Org1とOrg2によって別々にパッケージ化されています。
Both organizations use MYCC_1 as their package label in order to identify the package using the name and version.	どちらの組織も、名前とバージョンを使用してパッケージを識別するために、パッケージラベルとしてMYCC_1を使用しています。
It is not necessary for organizations to use the same package label.	組織が同じパッケージラベルを使用する必要はありません。
You need to install the chaincode package on every peer that will execute and endorse transactions.	トランザクションを実行およびエンドースするすべてのピアにチェーンコードパッケージをインストールする必要があります。
Whether using the CLI or an SDK, you need to complete this step using your Peer Administrator.	CLIとSDKのどちらを使用する場合でも、ピア管理者を使用してこの手順を完了する必要があります。
Your peer will build the chaincode after the chaincode is installed, and return a build error if there is a problem with your chaincode.	ピアは、チェーンコードがインストールされた後にチェーンコードをビルドします。そして、もしチェーンコードに問題があったらビルドエラーを返します。
It is recommended that organizations only package a chaincode once, and then install the same package on every peer that belongs to their org.	組織はチェーンコードを1回だけパッケージ化し、組織に属するすべてのピアに同じパッケージをインストールすることをお勧めします。
If a channel wants to ensure that each organization is running the same chaincode, one organization can package a chaincode and send it to other channel members out of band.	チャネルが各組織が同じチェーンコードを実行していることを確認したい場合、1つの組織がチェーンコードをパッケージ化し、それをFabricネットワークの外側で他のチャネルメンバーに送信します。
A successful install command will return a chaincode package identifier, which is the package label combined with a hash of the package.	インストールコマンドが成功すると、チェーンコードのパッケージ識別子 (パッケージID) が返されます。これは、パッケージラベルとパッケージのハッシュと組み合わせたものです。
This package identifier is used to associate a chaincode package installed on your peers with a chaincode definition approved by your organization.	このパッケージIDは、ピアにインストールされているチェーンコードパッケージを、組織によって承認されたチェーンコード定義に関連付けるために使用されます。
Save the identifier for next step.	パッケージIDを保存して次のステップに進みます。
You can also find the package identifier by querying the packages installed on your peer using the Peer CLI.	ピアCLIを使用してピアにインストールされているパッケージをクエリすることによって、パッケージIDを見つけることもできます。
A peer administrator from Org1 and Org2 installs the chaincode package MYCC_1 on the peers joined to the channel.	Org1およびOrg2のピア管理者は、チャネルに参加しているピアにチェーンコードパッケージMYCC_1をインストールします。
Installing the chaincode package builds the chaincode and creates a package identifier of MYCC_1:hash.	チェーンコードパッケージをインストールすると、チェーンコードが作成され、MYCC_1:hashというパッケージIDが作成されます。
The chaincode is governed by a chaincode definition.	チェーンコードは、チェーンコード定義 (chaincode definition)によって管理されます。
When channel members approve a chaincode definition, the approval acts as a vote by an organization on the chaincode parameters it accepts.	チャネルメンバーがチェーンコード定義を承認すると、その承認は、組織が受け入れるチェーンコードパラメータに対する組織の投票として機能します。
These approved organization definitions allow channel members to agree on a chaincode before it can be used on a channel.	これらの承認された組織定義により、チャネルメンバーは、チャネルで使用する前にチェーンコードについて合意することができます。
The chaincode definition includes the following parameters, which need to be consistent across organizations:	チェーンコード定義には、組織間で一貫している必要がある次のパラメータが含まれます:
Name: The name that applications will use when invoking the chaincode.	名前 (Name):チェーンコードを呼び出すときにアプリケーションが使用する名前。
Version: A version number or value associated with a given chaincodes  package.	バージョン (Version):特定のチェーンコードパッケージに関連付けられたバージョン番号または値。
If you upgrade the chaincode binaries, you need to change your  chaincode version as well.	チェーンコードのバイナリをアップグレードする場合は、チェーンコードのバージョンも変更する必要があります。
Sequence: The number of times the chaincode has been defined.	シーケンス (Sequence):チェーンコードが定義された回数。
This value  is an integer, and is used to keep track of chaincode upgrades.	この値は整数であり、チェーンコードのアップグレードを追跡するために使用されます。
For example,  when you first install and approve a chaincode definition, the sequence number  will be 1.	たとえば、最初にチェーンコード定義をインストールして承認すると、シーケンス番号は1になります。
When you next upgrade the chaincode, the sequence number will be  incremented to 2.	次にチェーンコードをアップグレードすると、シーケンス番号が2に増えます。
Endorsement Policy: Which organizations need to execute and validate the  transaction output.	エンドースメントポリシー (Endorsement Policy):どの組織がトランザクション出力を実行および検証する必要があるかを示したもの。
The endorsement policy can be expressed as a string passed  to the CLI, or it can reference a policy in the channel config.	エンドースメントポリシーは、CLIに渡される文字列として表現することも、チャネル設定内のポリシーを参照することもできます。
By  default, the endorsement policy is set to ``Channel/Application/Endorsement``,  which defaults to require that a majority of organizations in the channel  endorse a transaction.	デフォルトでは、エンドースメントポリシーは `Channel/Application/Endorsement`に設定されています。デフォルトでは、チャネル内の過半数の組織がトランザクションをエンドースする必要があります。
Collection Configuration: The path to a private data collection definition  file associated with your chaincode.	コレクション設定 (Collection Configuration):チェーンコードに関連付けられたプライベートデータコレクション定義ファイルへのパス。
For more information about private data  collections, see the [Private Data architecture reference](https://hyperledger-fabric.readthedocs.io/en/{BRANCH}/private-data-arch.html).	プライベートデータコレクションの詳細については、[Private Data architecture reference](private-data-arch.html)を参照ください。
ESCC/VSCC Plugins: The name of a custom endorsement or validation plugin to be used by this chaincode.	ESCC/VSCCプラグイン (ESCC/VSCC Plugins):このチェーンコードで使用されるカスタムエンドースメントまたはバリデーション (検証) プラグインの名前。
Initialization: If you use the low level APIs provided by the Fabric Chaincode  Shim API, your chaincode needs to contain an `Init` function that is used to  initialize the chaincode.	初期化 (Initialization):Fabric Chaincode Shim APIによって提供される低レベルAPIを使用する場合、チェーンコードには、チェーンコードの初期化に使用される`Init`関数を含める必要があります。
This function is required by the chaincode interface,  but does not necessarily need to invoked by your applications.	この関数はチェーンコードインターフェイスで必要ですが、必ずしもアプリケーションで呼び出す必要はありません。
When you approve  a chaincode definition, you can specify whether `Init` must be called prior to  Invokes.	チェーンコード定義を承認するときに、呼び出しの前に`Init`を呼び出す必要があるかどうかを指定できます。
If you specify that `Init` is required, Fabric will ensure that the `Init`  function is invoked before any other function in the chaincode and is only invoked  once.	`Init`が必要であると指定した場合、Fabricはチェーンコード内の他の関数の前に`Init`関数が1回だけ呼び出されることを保証します。
Requesting the execution of the `Init` function allows you to implement  logic that is run when the chaincode is initialized, for example to set some  initial state.	`Init`関数の実行を要求することで、チェーンコードが初期化されたときに実行されるロジックを実装できます (たとえば、初期状態を設定するため)。
You will need to call `Init` to initialize the chaincode every  time you increment the version of a chaincode, assuming the chaincode definition  that increments the version indicates that `Init` is required.	バージョンをインクリメントするチェーンコード定義が`Init`が必要であることを示していると仮定すると、チェーンコードのバージョンをインクリメントするたびに毎回`Init`を呼び出してチェーンコードを初期化する必要があります。
If you are using the Fabric peer CLI, you can use the `--init-required` flag  when you approve and commit the chaincode definition to indicate that the `Init`  function must be called to initialize the new chaincode version.	FabricのピアCLIを使用している場合、チェーンコード定義を承認およびコミットするときに`--init-required`フラグを使用して、新しいチェーンコードバージョンを初期化するために`Init`関数を呼び出す必要があることを示すことができます。
To call `Init`   using the Fabric peer CLI, use the `peer chaincode invoke` command and pass the  `--isInit` flag.	FabricのピアCLIを使用して`Init`を呼び出すには、`peer chaincode invoke`コマンドを使用して`--isInit`フラグを渡します。
If you are using the Fabric contract API, you do not need to include an `Init`  method in your chaincode.	Fabric Contract APIを使用している場合、チェーンコードに`Init`メソッドを含める必要はありません。
However, you can still use the `--init-required` flag  to request that the chaincode be initialized by a call from your applications.	ただし、`--init-required`フラグを使用して、アプリケーションからの呼び出しによってチェーンコードを初期化するように要求できます。
If you use the `--init-required` flag, you will need to pass the `--isInit` flag  or parameter to a chaincode call in order to initialize the chaincode every time  you increment the chaincode version.	`--init-required`フラグを使用する場合、チェーンコードバージョンをインクリメントするたびにチェーンコードを初期化するために、`--isInit`フラグまたはパラメーターをチェーンコード呼び出しに渡す必要があります。
You can pass `--isInit` and initialize the  chaincode using any function in your chaincode.	チェーンコード内の任意の関数を使用して、`--isInit`を渡し、チェーンコードを初期化できます。
The chaincode definition also includes the Package Identifier.	チェーンコードの定義には、パッケージID (Package Identifier, Package ID)も含まれています。
This is a required parameter for each organization that wants to use the chaincode.	これは、チェーンコードを使用する各組織に必要なパラメータです。
The package ID does not need to be the same for all organizations.	パッケージIDは、すべての組織で同じである必要はありません。
An organization can approve a chaincode definition without installing a chaincode package or including the identifier in the definition.	組織は、チェーンコードパッケージをインストールしたり、パッケージIDを定義に含めたりせずに、チェーンコード定義を承認できます。
Each channel member that wants to use the chaincode needs to approve a chaincode definition for their organization.	チェーンコードを使用する各チャネルメンバーは、組織のチェーンコード定義を承認する必要があります。
This approval needs to be submitted to the ordering service, after which it is distributed to all peers.	この承認はオーダリングサービスに送信する必要があり、その後、すべてのピアに配布されます。
This approval needs to be submitted by your Organization Administrator.	この承認は、組織管理者が送信する必要があります。
After the approval transaction has been successfully submitted, the approved definition is stored in a collection that is available to all the peers of your organization.	承認トランザクションが正常に送信された後、承認された定義は、組織のすべてのピアが利用できるコレクションに保存されます。
As a result you only need to approve a chaincode for your organization once, even if you have multiple peers.	その結果、複数のピアがある場合でも、組織のチェーンコードを承認する必要があるのは一度だけです。
An organization administrator from Org1 and Org2 approve the chaincode definition of MYCC for their organization.	Org1およびOrg2の組織管理者が、それぞれの組織のMYCCチェーンコード定義を承認します。
The chaincode definition includes the chaincode name, version, and the endorsement policy, among other fields.	チェーンコード定義には、チェーンコード名、バージョン、およびエンドースメントポリシーなどが含まれます。
Since both organizations will use the chaincode to endorse transactions, the approved definitions for both organizations need to include the packageID.	両方の組織がトランザクションをエンドースするためにチェーンコードを使用するには、両方の組織の承認された定義にはパッケージIDを含める必要があります。
Once a sufficient number of channel members have approved a chaincode definition, one organization can commit the definition to the channel.	十分な数のチャネルメンバーがチェーンコード定義を承認すると、1つの組織がチャネルに定義をコミットできます。
You can use the ``checkcommitreadiness`` command to check whether committing the chaincode definition should be successful based on which channel members have approved a definition before committing it to the channel using the peer CLI.	ピアCLIを使用してチェーンコード定義をチャネルにコミットする前に、定義を承認したチャネルメンバーに基づいて、定義のコミットが成功するかどうかを確認するために、``checkcommitreadiness``コマンドを使うことができます。
The commit transaction proposal is first sent to the peers of channel members, who query the chaincode definition approved for their organizations and endorse the definition if their organization has approved it.	コミットトランザクション提案は、最初にチャネルメンバーのピアに送信され、そのピアは自分の組織で承認済みのチェーンコード定義を照会し、自分の組織が承認していた場合には、その定義をエンドースする。
The transaction is then submitted to the ordering service, which then commits the chaincode definition to the channel.	次に、トランザクションはオーダリングサービスに送信され、オーダリングサービスはチェーンコード定義をチャネルにコミットします。
The commit definition transaction needs to be submitted as the Organization Administrator.	コミット定義トランザクションは、組織の管理者として送信する必要があります。
The number of organizations that need to approve a definition before it can be successfully committed to the channel is governed by the ``Channel/Application/LifecycleEndorsement`` policy.	定義をチャネルに正常にコミットする前に定義を承認する必要のある組織の数は、``Channel/Application/LifecycleEndorsement``ポリシーによって管理されます。
By default, this policy requires that a majority of organizations in the channel endorse the transaction.	デフォルトでは、このポリシーでは、チャネル内の過半数の組織がトランザクションをエンドースする必要があります。
The LifecycleEndorsement policy is separate from the chaincode endorsement policy.	LifecycleEndorsementポリシーは、チェーンコードエンドースメントポリシーとは別のものです。
For example, even if a chaincode endorsement policy only requires signatures from one or two organizations, a majority of channel members still need to approve the chaincode definition according to the default policy.	たとえば、チェーンコードのエンドースポリシーで1つまたは2つの組織からの署名のみが必要な場合でも、デフォルトのLifecycleEndorsementポリシーに従ってチャネルメンバーの過半数がチェーンコード定義を承認する必要があります。
When committing a channel definition, you need to target enough peer organizations in the channel to satisfy your LifecycleEndorsement policy.	チャネル定義をコミットする場合、LifecycleEndorsementポリシーを満たすために、チャネル内の十分な数のピア組織をターゲットにする必要があります。
You can learn more about the Fabric chaincode lifecycle policies in the [Policies concept topic](policies/policies.html).	Fabricのチェーンコードのライフサイクルポリシーの詳細については、[Policies concept topic](policies/policies.html)を参照してください。
You can also set the ``Channel/Application/LifecycleEndorsement`` policy to be a signature policy and explicitly specify the set of organizations on the channel that can approve a chaincode definition.	``Channel/Application/LifecycleEndorsement``ポリシーをSignatureポリシーに設定し、チェーンコード定義を承認できるチャネル上の組織のセットを明示的に指定することもできます。
This allows you to create a channel where a select number of organizations act as chaincode administrators and govern the business logic used by the channel.	これにより、選択した数の組織がチェーンコード管理者として機能し、チャネルで使用されるビジネスロジックを管理するチャネルを作成できます。
You can also use a signature policy if your channel has a large number Idemix organizations, which cannot approve chaincode definitions or endorse chaincode and may prevent the channel from reaching a majority as a result.	チャンネルに多数のIdemix組織があり、それらの組織がチェーンコード定義を承認したりチェーンコードをエンドースしたりできず、結果としてチャンネルが過半数に達しない可能性がある場合にも、Signatureポリシーを使用することができます。
One organization administrator from Org1 or Org2 commits the chaincode definition to the channel.	Org1またはOrg2の1人の組織管理者がチェーンコード定義をチャネルにコミットします。
The definition on the channel does not include the packageID.	チャネル上のチェーンコード定義には、パッケージIDを含みません。
An organization can approve a chaincode definition without installing the chaincode package.	組織は、チェーンコードパッケージをインストールせずにチェーンコード定義を承認できます。
If an organization does not need to use the chaincode, they can approve a chaincode definition without a package identifier to ensure that the Lifecycle Endorsement policy is satisfied.	組織がそのチェーンコードを使用する必要がない場合は、LifecycleEndorsementポリシーが満たされるようにするために、パッケージIDなしでチェーンコード定義を承認することができます。
After the chaincode definition has been committed to the channel, the chaincode container will launch on all of the peers where the chaincode has been installed, allowing channel members to start using the chaincode.	チェーンコード定義がチャネルにコミットされた後、チェーンコードコンテナは、チェーンコードがインストールされているすべてのピア上で起動され、チャネルメンバーがチェーンコードを使い始められるようにします。
It may take a few minutes for the chaincode container to start.	チェーンコードコンテナが起動するまで数分かかる場合があります。
You can use the chaincode definition to require the invocation of the ``Init`` function to initialize the chaincode.	チェーンコード定義を使用して、チェーンコードを初期化するために``Init``関数の呼び出しを要求できます。
If the invocation of the ``Init`` function is requested, the first invoke of the chaincode must be a call to the ``Init`` function.	``Init``関数の呼び出しが要求された場合、チェーンコードの最初の呼び出しは``Init``関数の呼び出しでなければなりません。
The invoke of the ``Init`` function is subject to the chaincode endorsement policy.	``Init``関数の呼び出しは、チェーンコードエンドースメントポリシーの対象となります。
Once MYCC is defined on the channel, Org1 and Org2 can start using the chaincode.	MYCCがチャネルで定義されると、Org1およびOrg2はチェーンコードを使い始めることができます。
The first invoke of the chaincode on each peer starts the chaincode container on that peer.	各ピアでのチェーンコードの最初の呼び出しは、そのピア上でチェーンコードコンテナを開始します。
You can upgrade a chaincode using the same Fabric lifecycle process as you used to install and start the chaincode.	チェーンコードのインストール/開始と同様のFabricライフサイクルプロセスを使用して、チェーンコードをアップグレードできます。
You can upgrade the chaincode binaries, or only update the chaincode policies.	チェーンコードバイナリをアップグレードするか、あるいはチェーンコードポリシーのみを更新できます。
Follow these steps to upgrade a chaincode:	次のステップに従って、チェーンコードをアップグレードします:
1. Repackage the chaincode: You only need to complete this step if you are  upgrading the chaincode binaries.	1. チェーンコードを再パッケージ化する:チェーンコードバイナリをアップグレードする場合のみ、このステップを完了する必要があります。
Org1 and Org2 upgrade the chaincode binaries and repackage the chaincode.	Org1とOrg2はチェーンコードバイナリをアップグレードし、チェーンコードを再パッケージ化します。
Both organizations use a different package label.	どちらの組織も異なるパッケージラベルを使用しています。
2. Install the new chaincode package on your peers: Once again, you only  need to complete this step if you are upgrading the chaincode binaries.	2. ピアに新しいチェーンコードパッケージをインストールする:このステップも、チェーンコードバイナリをアップグレードする場合にのみ、完了する必要があります。
Installing the new chaincode package will generate a package ID, which you will  need to pass to the new chaincode definition.	新しいチェーンコードパッケージをインストールすると、新しいチェーンコード定義に渡す必要のあるパッケージIDが生成されます。
You also need to change the  chaincode version, which is used by the lifecycle process to track if the  chaincode binaries have been upgraded.	また、チェーンコードのバイナリをアップグレードしたかどうかを追跡するためにライフサイクルプロセスで使用されるチェーンコードのバージョンを変更する必要があります。
Org1 and Org2 install the new package on their peers.	Org1とOrg2はそれぞれのピアに新しいパッケージをインストールします。
The installation creates a new packageID.	このインストールでパッケージIDが生成されます。
3. Approve a new chaincode definition: If you are upgrading the chaincode  binaries, you need to update the chaincode version and the package ID in the  chaincode definition.	3. 新しいチェーンコード定義を承認する:チェーンコードバイナリをアップグレードする場合は、チェーンコード定義のチェーンコードバージョンとパッケージIDを更新する必要があります。
You can also update your chaincode endorsement policy  without having to repackage your chaincode binaries.	チェーンコードバイナリを再パッケージ化せずに、チェーンコードエンドースメントポリシーを更新することもできます。
Channel members simply  need to approve a definition with the new policy.	チャネルメンバーは、新しいポリシーを設定したチェーンコード定義を承認するだけです。
The new definition needs to  increment the sequence variable in the definition by one.	新しい定義では、定義内のシーケンス変数を1つインクリメントする必要があります。
Organization administrators from Org1 and Org2 approve the new chaincode definition for their respective organizations.	Org1とOrg2の組織管理者は、それぞれの組織の新しいチェーンコード定義を承認します。
The new definition references the new packageID and changes the chaincode version.	新しい定義は新しいパッケージIDを参照し、チェーンコードのバージョンを変更します。
Since this is the first update of the chaincode, the sequence is incremented from one to two.	これはチェーンコードの最初の更新なので、シーケンスは1から2にインクリメントされます。
4. Commit the definition to the channel: When a sufficient number of channel  members have approved the new chaincode definition, one organization can  commit the new definition to upgrade the chaincode definition to the channel.	4. 定義をチャネルにコミットする:十分な数のチャネルメンバーが新しいチェーンコード定義を承認したら、1つの組織が新しい定義をコミットすることでチェーンコード定義をチャネルにアップグレードできます。
There is no separate upgrade command as part of the lifecycle process.	ライフサイクルプロセスの一部として個別のアップグレードコマンドはありません。
An organization administrator from Org1 or Org2 commits the new chaincode definition to the channel.	Org1またはOrg2の組織管理者が、新しいチェーンコード定義をチャネルにコミットします。
After you commit the chaincode definition, a new chaincode container will launch with the code from the upgraded chaincode binaries.	チェーンコード定義をコミットすると、アップグレードされたチェーンコードバイナリのコードを使用して新しいチェーンコードコンテナが起動します。
If you requested the execution of the ``Init`` function in the chaincode definition, you need to initialize the upgraded chaincode by invoking the ``Init`` function again after the new definition is successfully committed.	チェーンコード定義で ``Init``関数の実行を要求した場合、新しい定義が正常にコミットされた後で ``Init``関数を再度呼び出して、アップグレードされたチェーンコードを初期化する必要があります。
If you updated the chaincode definition without changing the chaincode version, the chaincode container will remain the same and you do not need to invoke ``Init`` function.	チェーンコードのバージョンを変更せずにチェーンコード定義を更新した場合、チェーンコードコンテナは同じままであり、``Init``関数を呼び出す必要はありません。
Once the new definition has been committed to the channel, each peer will automatically start the new chaincode container.	新しい定義がチャネルにコミットされると、各ピアは自動的に新しいチェーンコードコンテナを開始します。
The Fabric chaincode lifecycle uses the sequence in the chaincode definition to keep track of upgrades.	Fabricのチェーンコードライフサイクルでは、チェーンコード定義のシーケンスを使用して、アップグレードを追跡します。
All channel members need to increment the sequence number by one and approve a new definition to upgrade the chaincode.	すべてのチャネルメンバーは、シーケンス番号を1つインクリメントし、新しい定義を承認してチェーンコードをアップグレードする必要があります。
The version parameter is used to track the chaincode binaries, and needs to be changed only when you upgrade the chaincode binaries.	バージョンパラメータは、チェーンコードバイナリを追跡するために使用され、チェーンコードバイナリをアップグレードする場合にのみ変更する必要があります。
The following examples illustrate how you can use the Fabric chaincode lifecycle to manage channels and chaincode.	次の例は、Fabricのチェーンコードライフサイクルを使用してチャネルとチェーンコードを管理する方法を示しています。
A new organization can join a channel with a chaincode already defined, and start using the chaincode after installing the chaincode package and approving the chaincode definition that has already been committed to the channel.	新しい組織は、すでにチェーンコードが定義されているチャネルに参加し、チェーンコードパッケージをインストールし、チャネルにコミット済みのチェーンコード定義を承認した後に、そのチェーンコードを使い始めることができます。
Org3 joins the channel and approves the same chaincode definition that was previously committed to the channel by Org1 and Org2.	Org3はチャネルに参加し、Org1およびOrg2によって以前にチャネルにコミットされたものと同じチェーンコード定義を承認します。
After approving the chaincode definition, the new organization can start using the chaincode after the package has been installed on their peers.	チェーンコード定義を承認した後、新しい組織は、パッケージがピアにインストールされた後にチェーンコードの使用を開始できます。
The definition does not need to be committed again.	定義を再度コミットする必要はありません。
If the endorsement policy is set the default policy that requires endorsements from a majority of channel members, then the endorsement policy will be updated automatically to include the new organization.	エンドースメントポリシーが、過半数のチャネルメンバーからのエンドースを必要とするデフォルトのポリシーに設定されている場合、エンドースメントポリシーは新しい組織を含むように自動的に更新されます。
The chaincode container will start after the first invoke of the chaincode on the Org3 peer.	チェーンコードコンテナは、Org3のピアでチェーンコードが最初に呼び出された後に開始されます。
You can use the chaincode definition to update an endorsement policy without having to repackage or re-install the chaincode.	チェーンコード定義を使用することで、チェーンコードを再パッケージ化または再インストールしなくても、エンドースメントポリシーを更新できます。
Channel members can approve a chaincode definition with a new endorsement policy and commit it to the channel.	チャネルメンバーは、新しいエンドースメントポリシーを使用してチェーンコード定義を承認し、それをチャネルにコミットできます。
Org1, Org2, and Org3 approve a new endorsement policy requiring that all three organizations endorse a transaction.	Org1、Org2、およびOrg3は、3つの組織すべてがトランザクションにエンドースすることを要求する新しいエンドースメントポリシーを承認します。
They increment the definition sequence from one to two, but do not need to update the chaincode version.	定義のシーケンスを1から2に増やしますが、チェーンコードのバージョンを更新する必要はありません。
The new endorsement policy will take effect after the new definition is committed to the channel.	新しいエンドースメントポリシーは、新しい定義がチャネルにコミットされた後に有効になります。
Channel members do not have to restart the chaincode container by invoking the chaincode or executing the `Init` function in order to update the endorsement policy.	エンドースメントポリシーを更新するために、チャネルメンバーはチェーンコードを呼び出したり`Init`関数を実行したりしてチェーンコードコンテナを再起動する必要はありません。
One organization commits the new chaincode definition to the channel to update the endorsement policy.	1つの組織が新しいチェーンコード定義をチャネルにコミットして、エンドースメントポリシーを更新します。
You can approve a chaincode definition without installing the chaincode package.	チェーンコードパッケージをインストールしなくても、チェーンコード定義を承認できます。
This allows you to endorse a chaincode definition before it is committed to the channel, even if you do not want to use the chaincode to endorse transactions or query the ledger.	これにより、チェーンコードを使用してトランザクションのエンドースや台帳のクエリをしたくない場合にも、チャネルにコミットする前にチェーンコード定義を承認できます。
You need to approve the same parameters as other members of the channel, but not need to include the packageID as part of the chaincode definition.	チャネルの他のメンバーと同じパラメータで承認する必要がありますが、チェーンコード定義の一部としてパッケージIDを含める必要はありません。
Org3 does not install the chaincode package.	Org3はチェーンコードパッケージをインストールしません。
As a result, they do not need to provide a packageID as part of chaincode definition.	そしてOrg3はチェーンコード定義の一部としてパッケージIDを提供する必要はありません。
However, Org3 can still endorse the definition of MYCC that has been committed to the channel.	ただし、Org3は、チャネルにコミットされたMYCCの定義を引き続き承認することはできます。
An organization that does not approve a chaincode definition that has been committed to the channel cannot use the chaincode.	チャネルにコミットされたチェーンコード定義を承認しない組織は、そのチェーンコードを使用できません。
Organizations that have either not approved a chaincode definition, or approved a different chaincode definition will not be able to execute the chaincode on their peers.	チェーンコード定義を承認していないか、別のチェーンコード定義を承認している組織は、その組織のピアでチェーンコードを実行できません。
Org3 approves a chaincode definition with a different endorsement policy than Org1 and Org2.	Org3は、Org1およびOrg2とは異なるエンドースメントポリシーを持つチェーンコード定義を承認します。
As a result, Org3 cannot use the MYCC chaincode on the channel.	その結果、Org3はチャネルでMYCCチェーンコードを使用できません。
However, Org1 or Org2 can still get enough endorsements to commit the definition to the channel and use the chaincode.	ただし、Org1またはOrg2は、チャネルに定義をコミットしてチェーンコードを使用するのに十分なエンドースメントを引き続き取得できます。
Transactions from the chaincode will still be added to the ledger and stored on the Org3 peer.	チェーンコードのトランザクションは台帳に追加され、Org3のピアにも保存されます。
However, the Org3 will not be able to endorse transactions.	ただし、Org3はトランザクションをエンドースできません。
An organization can approve a new chaincode definition with any sequence number or version.	組織は、任意のシーケンス番号またはバージョンの新しいチェーンコード定義を承認できます。
This allows you to approve the definition that has been committed to the channel and start using the chaincode.	これにより、チャネルにコミットされた定義を承認し、チェーンコードを使い始めることができます。
You can also approve a new chaincode definition in order to correct any mistakes made in the process of approving or packaging a chaincode.	また、チェーンコードの承認またはパッケージ化のプロセスで発生した間違いを修正するために、新しいチェーンコード定義を承認することもできます。
If the organizations on a channel do not agree on a chaincode definition, the definition cannot be committed to the channel.	チャネル上の組織がチェーンコード定義に同意しない場合、定義をチャネルにコミットできません。
None of the channel members will be able to use the chaincode.	どのチャネルメンバーもそのチェーンコードを使用できなくなります。
Org1, Org2, and Org3 all approve different chaincode definitions.	Org1、Org2、およびOrg3はすべて、異なるチェーンコード定義を承認しています。
As a result, no member of the channel can get enough endorsements to commit a chaincode definition to the channel.	その結果、チャネルのメンバーは、チェーンコード定義をチャネルにコミットするのに十分な承認を得ることができません。
No channel member will be able to use the chaincode.	チャネルメンバーはそのチェーンコードを使用できません。
Each organization can use a different packageID when they approve a chaincode definition.	各組織は、チェーンコード定義を承認するときに、異なるパッケージIDを使用できます。
This allows channel members to install different chaincode binaries that use the same endorsement policy and read and write to data in the same chaincode namespace.	これにより、チャネルメンバーは、同じエンドースメントポリシーを使用して同じチェーンコード名前空間でデータの読み取りと書き込みを行う、異なるチェーンコードバイナリをインストールすることができます。
Organizations can use this capability to install smart contracts that contain business logic that is specific to their organization.	組織はこの機能を使用して、組織に固有のビジネスロジックを含むスマートコントラクトをインストールできます。
Each organization's smart contract could contain additional validation that the organization requires before their peers endorse a transaction.	各組織のスマートコントラクトには、ピアがトランザクションをエンドースする前に組織が必要とする追加の検証を含めることができます。
Each organization can also write code that helps integrate the smart contract with data from their existing systems.	各組織は、スマートコントラクトを既存のシステムのデータと統合するのに役立つコードを記述することもできます。
Org1 and Org2 each install versions of the MYCC chaincode containing business logic that is specific to their organization.	Org1とOrg2はそれぞれ、組織に固有のビジネスロジックを含むMYCCチェーンコードのバージョンをインストールしています。
You can use one chaincode package to create multiple chaincode instances on a channel by approving and committing multiple chaincode definitions.	1つのチェーンコードパッケージを使用して、複数のチェーンコード定義を承認およびコミットすることにより、チャネル上に複数のチェーンコードインスタンスを作成できます。
Each definition needs to specify a different chaincode name.	各定義では、異なるチェーンコード名を指定する必要があります。
This allows you to run multiple instances of a smart contract on a channel, but have the contract be subject to different endorsement policies.	これにより、1つのチャネル上で1つのスマートコントラクトについて複数のインスタンスを実行することができますが、コントラクト (の各インスタンス) には異なるエンドースメントポリシーが適用されます。
Org1 and Org2 use the MYCC_1 chaincode package to approve and commit two different chaincode definitions.	Org1とOrg2は、MYCC_1チェーンコードパッケージを使用して、2つの異なるチェーンコード定義を承認およびコミットします。
As a result, both peers have two chaincode containers running on their peers.	その結果、両方のピアには、ピアで実行されている2つのチェーンコードコンテナがあります。
MYCC1 has an endorsement policy of 1 out of 2, while MYCC2 has an endorsement policy of 2 out of 2.	MYCC1には2分の1のエンドースメントポリシーがあり、一方、MYCC2には2分の2のエンドースメントポリシーがあります。
For information about migrating to the new lifecycle, check out [Considerations for getting to v2.0](./upgrade_to_newest_version.html#chaincode-lifecycle).	新しいライフサイクルへの移行についての情報は、[Considerations for getting to v2.0](./upgrade_to_newest_version.html#chaincode-lifecycle)を確認してください。
If you need to update your channel configurations to enable the new lifecycle, check out [Enabling the new chaincode lifecycle](./enable_cc_lifecycle.html).	新しいライフサイクルを有効にするためにチャネル設定を更新する必要がある場合は、[Enabling the new chaincode lifecycle](./enable_cc_lifecycle.html)を確認してください。
You can watch video below to learn more about the motivation of the new Fabric chaincode lifecycle and how it is implemented.	新しいFabricチェーンコードライフサイクルのモチベーションとその実装方法について詳しくは、以下のビデオを参照してください。
The peer and the orderer host an HTTP server that offers a RESTful "operations" API.	ピアとOrdererは、RESTfulな「運用 (Operations)」APIを提供するHTTPサーバーをホストします。
This API is unrelated to the Fabric network services and is intended to be used by operators, not administrators or "users" of the network.	このAPIはFabricネットワークサービスとは無関係であり、ネットワークの管理者や「ユーザー」ではなく、運用者が使用することを意図しています。
The API exposes the following capabilities:	API は以下の機能を公開しています。
Log level management	ログレベル管理
Health checks	ヘルスチェック
Prometheus target for operational metrics (when configured)	運用メトリクスのPrometheusのターゲット (設定されている場合)
Endpoint for retrieving version information	バージョン情報を取得するためのエンドポイント
The operations service requires two basic pieces of configuration:	運用サービスには、次の2つの基本設定が必要です。
The address and port to listen on.	Listenするアドレスおよびポート。
The TLS certificates and keys to use for authentication and encryption.	認証と暗号化に使用するTLS証明書と鍵。
Note, these certificates should be generated by a separate and dedicated CA.	注：これらの証明書は、個別の専用のCAによって生成される必要があります。
Do not use a CA that has generated certificates for any organizations in any channels.	すべてのチャネル・組織のための証明書を発行するような (単一の) CAを使わないでください。
For each peer, the operations server can be configured in the ``operations`` section of ``core.yaml``:	ピアごとに、運用 (API) サーバーは  ``core.yaml`` の ``operations`` セクションで設定することができます:
host and port for the operations server	運用サーバーのホストとポート
TLS configuration for the operations endpoint	運用サービスエンドポイントのTLS設定
TLS enabled	TLSが有効かどうか
path to PEM encoded server certificate for the operations server	運用サーバー用のPEMエンコードされたサーバー証明書へのパス
path to PEM encoded server key for the operations server	運用サーバのPEMエンコードされたサーバ秘密鍵へのパス
most operations service endpoints require client authentication when TLS is enabled.	TLSが有効になっている場合、ほとんどの運用サービスエンドポイントではクライアント認証が必要です。
clientAuthRequired requires client certificate authentication at the TLS layer to access all resources.	clientAuthRequiredを有効にすると、すべてのリソースにアクセスするためにTLS層でクライアント証明書認証を必要とするようになります。
paths to PEM encoded ca certificates to trust for client authentication	クライアント認証のために信頼する、PEMエンコードされたCA証明書へのパス
The ``listenAddress`` key defines the host and port that the operation server will listen on.	``listenAddress`` キーは、運用サーバーがListenするホストとポートを定義します。
If the server should listen on all addresses, the host portion can be omitted.	サーバーがすべてのアドレスをListenする必要がある場合は、ホスト部分を省略できます。
The ``tls`` section is used to indicate whether or not TLS is enabled for the operations service, the location of the service's certificate and private key, and the locations of certificate authority root certificates that should be trusted for client authentication.	``tls`` セクションは、運用サービスでTLSが有効になっているかどうか、サービスの証明書と秘密鍵の場所、およびクライアント認証で信頼される認証局のルート証明書の場所を示すために使用されます。
When ``enabled`` is true, most of the operations service endpoints require client authentication, therefore ``clientRootCAs.files`` must be set.	``enabled`` がtrueの場合、ほとんどの運用サービスエンドポイントはクライアント認証を必要とするため、``clientRootCAs.files`` を設定する必要があります。
When ``clientAuthRequired`` is ``true``, the TLS layer will require clients to provide a certificate for authentication on every request.	``clientAuthRequired`` が ``true`` の場合、TLS層はクライアントがすべてのリクエストで認証用の証明書を提供することを要求します。
See Operations Security section below for more details.	詳細については、以下のOperations Securityセクションを参照してください。
For each orderer, the operations server can be configured in the `Operations` section of ``orderer.yaml``:	Ordererごとに、運用サーバーは  ``orderer.yaml`` の `Operations` セクションで設定することができます:
host and port for the operations server	運用サーバーのホストとポート
TLS configuration for the operations endpoint	運用サービスエンドポイントのTLS設定
PrivateKey: PEM-encoded tls key for the operations endpoint	PrivateKey: 運用エンドポイントのPEMエンコードされたTLS秘密鍵
TLS enabled	TLSが有効かどうか
Certificate governs the file location of the server TLS certificate.	証明書は、サーバーのTLS証明書のファイルの場所を管理します
Paths to PEM encoded ca certificates to trust for client authentication	クライアント認証のために信頼する、PEMエンコードされたCA証明書へのパス
Most operations service endpoints require client authentication when TLS is enabled.	TLSが有効になっている場合、ほとんどの運用サービスエンドポイントではクライアント認証が必要です。
ClientAuthRequired requires client certificate authentication at the TLS layer to access all resources.	ClientAuthRequiredを有効にすると、すべてのリソースにアクセスするためにTLS層でクライアント証明書認証を必要とするようになります。
The ``ListenAddress`` key defines the host and port that the operations server will listen on.	``listenAddress`` キーは、運用サーバーがListenするホストとポートを定義します。
If the server should listen on all addresses, the host portion can be omitted.	サーバーがすべてのアドレスをListenする必要がある場合は、ホスト部分を省略できます。
The ``TLS`` section is used to indicate whether or not TLS is enabled for the operations service, the location of the service's certificate and private key, and the locations of certificate authority root certificates that should be trusted for client authentication.	``TLS`` セクション は、運用サービスでTLSが有効になっているかどうか、サービスの証明書と秘密鍵の場所、およびクライアント認証で信頼される認証局のルート証明書の場所を示すために使用されます。 
When ``Enabled`` is true, most of the operations service endpoints require client authentication, therefore ``RootCAs`` must be set.	``Enabled`` がtrueの場合、ほとんどの運用サービスエンドポイントはクライアント認証を必要とするため、``RootCAs`` を設定する必要があります。
When ``ClientAuthRequired`` is ``true``, the TLS layer will require clients to provide a certificate for authentication on every request.	``ClientAuthRequired`` が ``true`` の場合、TLS層はクライアントがすべてのリクエストで認証用の証明書を提供することを要求します。
See Operations Security section below for more details.	詳細については、以下のOperations Securityセクションを参照してください。
As the operations service is focused on operations and intentionally unrelated to the Fabric network, it does not use the Membership Services Provider for access control.	運用サービスは運用に特化しており、意図的にFabricネットワークとは無関係であるため、アクセス制御にメンバーシップサービスプロバイダ (MSP) を使用しません。
Instead, the operations service relies entirely on mutual TLS with client certificate authentication.	代わりに、運用サービスはクライアント証明書認証による相互TLSに完全に依存しています。
When TLS is disabled, authorization is bypassed and any client that can connect to the operations endpoint will be able to use the API.	TLSを無効にすると、認証がバイパスされ、運用エンドポイントに接続できるすべてのクライアントがAPIを使用できるようになります。
When TLS is enabled, a valid client certificate must be provided in order to access all resources unless explicitly noted otherwise below.	TLSが有効になっている場合、以下で特に明記がない限りすべてのリソースにアクセスするために、有効なクライアント証明書を提供する必要があります。
When clientAuthRequired is also enabled, the TLS layer will require a valid client certificate regardless of the resource being accessed.	clientAuthRequiredも有効になっている場合、アクセスされるリソースに関係なく、TLS層は有効なクライアント証明書を要求します。
The operations service provides a ``/logspec`` resource that operators can use to manage the active logging spec for a peer or orderer.	運用サービスは、運用者がピアまたはOrdererのアクティブなロギングスペック (logging spec) を管理するために使用できる ``/logspec`` リソースを提供します。
The resource is a conventional REST resource and supports ``GET`` and ``PUT`` requests.	リソースは従来のRESTリソースであり、 ``GET`` および ``PUT`` リクエストをサポートします。
When a ``GET /logspec`` request is received by the operations service, it will respond with a JSON payload that contains the current logging specification:	運用サービスが ``GET /logspec`` リクエストを受け取ると、現在のロギング仕様を含むJSONペイロードを返します:
When a ``PUT /logspec`` request is received by the operations service, it will read the body as a JSON payload.	運用サービスが ``PUT /logspec`` リクエストを受け取ると、ボディをJSONペイロードとして読み取ります。
The payload must consist of a single attribute named ``spec``.	ペイロードは、 ``spec`` という名前の単一の属性で構成されている必要があります。
If the spec is activated successfully, the service will respond with a ``204 "No Content"`` response.	スペックが正常にアクティブ化された場合、サービスは ``204 "No Content"`` レスポンスを返します。
If an error occurs, the service will respond with a ``400 "Bad Request"`` and an error payload:	エラーが発生した場合、サービスは ``400 "Bad Request"`` とエラーペイロードを返します:
The operations service provides a ``/healthz`` resource that operators can use to help determine the liveness and health of peers and orderers.	運用サービスは、運用者がピアやOrdererの生死と健康状態を判断するのに役立つ ``/healthz`` リソースを提供します。
The resource is a conventional REST resource that supports GET requests.	リソースは、GETリクエストをサポートする従来のRESTリソースです。
The implementation is intended to be compatible with the liveness probe model used by Kubernetes but can be used in other contexts.	この実装は、Kubernetesで使用されるliveness probeとの互換性を意図としていますが、他のコンテキストでも使用できます。
When a ``GET /healthz`` request is received, the operations service will call all registered health checkers for the process.	``GET /healthz`` リクエストを受け取ると、運用サービスはプロセスに登録されているすべてのヘルスチェッカーを呼び出します。
When all of the health checkers return successfully, the operations service will respond with a ``200 "OK"`` and a JSON body:	すべてのヘルスチェッカーから成功が返ってきたら、運用サービスは ``200 "OK"`` と以下のようなJSONボディを返します:
If one or more of the health checkers returns an error, the operations service will respond with a ``503 "Service Unavailable"`` and a JSON body that includes information about which health checker failed:	1つ以上のヘルスチェッカーがエラーを返した場合、運用サービスは ``503 "Service Unavailable"`` と、どのヘルスチェッカーが失敗したかに関する情報を含むJSONボディで応答します。
In the current version, the only health check that is registered is for Docker.	現在のバージョンでは、登録されているヘルスチェックはDockerのみです。
Future versions will be enhanced to add additional health checks.	将来のバージョンでは、他のヘルスチェックが追加できるように拡張される予定です。
When TLS is enabled, a valid client certificate is not required to use this service unless ``clientAuthRequired`` is set to ``true``.	TLSが有効な場合、 ``clientAuthRequired`` が ``true`` に設定されていない限り、このサービスを使用するために有効なクライアント証明書は必要ありません。
Some components of the Fabric peer and orderer expose metrics that can help provide insight into the behavior of the system.	FabricのピアおよびOrdererの一部のコンポーネントは、システムの動作に関する洞察を提供するのに役立つメトリクスを公開します。
Operators and administrators can use this information to better understand how the system is performing over time.	運用者と管理者は、この情報を使用して、システムが時間経過とともにどのように動いているかをよりよく理解できます。
Fabric provides two ways to expose metrics: a pull model based on Prometheus and a push model based on StatsD.	Fabricは、Prometheusをベースにしたプル型 (pull)モデルとStatsDをベースにしたプッシュ型 (push)モデルの2つの方法でメトリクスを提供します。
A typical Prometheus deployment scrapes metrics by requesting them from an HTTP endpoint exposed by instrumented targets.	典型的なPrometheusデプロイメントは、インストルメント化されたターゲットによって公開されたHTTPエンドポイントからメトリックスを要求することにより、メトリックスをスクレイピングします。
As Prometheus is responsible for requesting the metrics, it is considered a pull system.	Prometheusがメトリクスの要求をするため、プル型システムと見なされます。
When configured, a Fabric peer or orderer will present a ``/metrics`` resource on the operations service.	設定されている場合、FabricのピアまたはOrdererは運用サービス上に ``/metrics`` リソースを提示します。
A peer can be configured to expose a ``/metrics`` endpoint for Prometheus to scrape by setting the metrics provider to ``prometheus`` in the ``metrics`` section of ``core.yaml``.	ピアは、 ``core.yaml`` の ``metrics`` セクションでメトリックプロバイダを ``prometheus`` に設定することで、Prometheusが ``metrics`` エンドポイントを公開してスクレイピングするように設定できます。
An orderer can be configured to expose a ``/metrics`` endpoint for Prometheus to scrape by setting the metrics provider to ``prometheus`` in the ``Metrics`` section of ``orderer.yaml``.	Ordererは、 ``orderer.yaml`` の ``metrics`` セクションでメトリクスプロバイダを ``prometheus`` に設定することで、Prometheusが ``metrics`` エンドポイントを公開してスクレイピングするように設定できます。
StatsD is a simple statistics aggregation daemon.	StatsDはシンプルな統計情報集約デーモンです。
Metrics are sent to a ``statsd`` daemon where they are collected, aggregated, and pushed to a backend for visualization and alerting.	メトリクスは ``statsd`` デーモンに送信され、そこで収集、集約され、視覚化とアラートのためにバックエンドにプッシュされます。
As this model requires instrumented processes to send metrics data to StatsD, this is considered a push system.	このモデルでは、メトリックスデータをStatsDに送信するためにインストルメント化されたプロセスが必要であるため、これはプッシュ型システムと見なされます。
A peer can be configured to send metrics to StatsD by setting the metrics provider to ``statsd`` in the ``metrics`` section of ``core.yaml``.	ピアは、 ``core.yaml`` の ``metrics`` セクションでメトリクスプロバイダを ``statsd`` に設定することにより、メトリックスをStatsDに送信するように設定できます。
The ``statsd`` subsection must also be configured with the address of the StatsD daemon, the network type to use (``tcp`` or ``udp``), and how often to send the metrics.	``statsd`` サブセクションはStatsDデーモンのアドレス、使用するネットワークタイプ ( ``tcp`` または ``udp``)、およびメトリックスを送信する頻度で構成する必要もあります。
An optional ``prefix`` may be specified to help differentiate the source of the metrics --- for example, differentiating metrics coming from separate peers --- that would be prepended to all generated metrics.	オプションの ``prefix`` を指定して、メトリックスのソースを区別することができます (たとえば、別のピアからのメトリックスと区別)。このプレフィックスは生成されたすべてのメトリックスの前に付加されます。
An orderer can be configured to send metrics to StatsD by setting the metrics provider to ``statsd`` in the ``Metrics`` section of ``orderer.yaml``.	Ordererは、 ``orderer.yaml`` の ``metrics`` セクションでメトリクスプロバイダを ``statsd`` に設定することにより、メトリックスをStatsDに送信するように設定できます。
The ``Statsd`` subsection must also be configured with the address of the StatsD daemon, the network type to use (``tcp`` or ``udp``), and how often to send the metrics.	``statsd`` サブセクションはStatsDデーモンのアドレス、使用するネットワークタイプ ( ``tcp`` または ``udp``)、およびメトリックスを送信する頻度で構成する必要もあります。
An optional ``prefix`` may be specified to help differentiate the source of the metrics.	オプションの ``prefix`` を指定して、メトリックスのソースを区別することができます。
For a look at the different metrics that are generated, check out :doc:`metrics_reference`.	生成されるさまざまなメトリックスについては、 :doc:`metrics_reference` を参照してください。
The orderer and peer both expose a ``/version`` endpoint.	Ordererとピアの両方が ``/version`` エンドポイントを公開します。
This endpoint serves a JSON document containing the orderer or peer version and the commit SHA on which the release was created.	このエンドポイントは、Ordererまたはピアのバージョンと、リリースが作成されたコミットSHAを含むJSONドキュメントを提供します。
**Audience**: Architects, application and smart contract developers, administrators	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者、管理者
From an application developer's perspective, a smart contract, together with the [ledger](../ledger/ledger.html), form the heart of a Hyperledger Fabric blockchain system.	アプリケーション開発者の観点からみると、[台帳](../ledger/ledger.html)と合わせて、スマートコントラクトはHyperledger Fabricによるブロックチェーンシステムのコアを形成するものです。
Whereas a ledger holds facts about the current and historical state of a set of business objects, a smart contract defines the executable logic that generates new facts that are added to the ledger.	台帳はビジネスデータの集合の現在および過去の正しい状態をもっているもので、スマートコントラクトは、台帳に新しく追加される正しいデータを生成する実行可能なロジックを定義するものです。
A chaincode is typically used by administrators to group related smart contracts for deployment, but can also be used for low level system programming of Fabric.	チェーンコードは、通常、管理者が関連するスマートコントラクトをデプロイするためにひとまとめにするのに使われるものですが、Fabricの低レベルのシステムプログラミングの用途にも使用することができます。
In this topic, we'll focus on why both smart contracts and chaincode exist, and how and when to use them.	このトピックでは、スマートコントラクトとチェーンコードがそれぞれなぜ存在するのか、そして、どのようにいつ使うのかについて注目していきます。
In this topic, we'll cover:	このトピックでは、次のことを扱います。
[What is a smart contract](#smart-contract)	[スマートコントラクトとは何か](#smart-contract)
[A note on terminology](#terminology)	[用語に関する注意](#terminology)
[Smart contracts and the ledger](#ledger)	[スマートコントラクトと台帳](#ledger)
[How to develop a smart contract](#developing)	[スマートコントラクトの開発の仕方](#developing)
[The importance of endorsement policies](#endorsement)	[エンドースメントポリシーの重要性](#endorsement)
[Valid transactions](#valid-transactions)	[正当なトランザクション](#valid-transactions)
[Channels and chaincode definitions](#channels)	[チャネルとチェーンコード定義](#channels)
[Communicating between smart contracts](#intercommunication)	[スマートコントラクト間でのやりとり](#intercommunication)
[What is system chaincode?](#system-chaincode)	[システムチェーンコードとは?](#system-chaincode)
Before businesses can transact with each other, they must define a common set of contracts covering common terms, data, rules, concept definitions, and processes.	企業などが互いに取引を行う際には、まず共通の用語、データ、規則、概念の定義、プロセスを含んでいる共有される契約を結ばなければなりません。
Taken together, these contracts lay out the business model that govern all of the interactions between transacting parties.	これらの契約は、全体として、取引を行う関係者の間のすべてのやり取りを管理するビジネスモデルを設計することになります。
A smart contract defines the rules between different organizations in executable code.	スマートコントラクトは、異なる組織の間の規則を、実行可能なコードによって定義します。
Applications invoke a smart contract to generate transactions that are recorded on the ledger.	アプリケーションは、台帳に記録されるトランザクションを生成するために、スマートコントラクトを呼び出します。
Using a blockchain network, we can turn these contracts into executable programs -- known in the industry as smart contracts -- to open up a wide variety of new possibilities.	ブロックチェーンネットワークを使うことで、これらの契約を実行可能なプログラム(この業界ではスマートコントラクトとして知られています)にすることができ、幅広い新しい可能性を開くことができます。
That's because a smart contract can implement the governance rules for any type of business object, so that they can be automatically enforced when the smart contract is executed.	これは、スマートコントラクトが、いかなる種類のビジネスデータに対する管理ルールでも実装することができるためで、スマートコントラクトが実行される際には、そのルールを自動的に強制することができるためです。
For example, a smart contract might ensure that a new car delivery is made within a specified timeframe, or that funds are released according to prearranged terms, improving the flow of goods or capital respectively.	例えば、スマートコントラクトは、新車の納車が決められた期間内に行われることを保証するものかもしれませんし、事前に合意した規定に従って資金が放出されることを保証するものかもしれません。これらは、それぞれ、モノと資本のフローを改善する例です。
Most importantly however, the execution of a smart contract is much more efficient than a manual human business process.	しかし、一番重要なのは、スマートコントラクトの実行は、人間が人手で行うビジネスプロセスと比較してはるかに効率的なことです。
In the [diagram above](#smart-contract), we can see how two organizations, `ORG1` and `ORG2` have defined a `car` smart contract to `query`, `transfer` and `update` cars.	[上記の図](#smart-contract)では、二つの組織(`ORG1`と`ORG2`)が、車のクエリ(`query`)、譲渡(`transfer`)、情報の更新(`update`)のために、`car`というスマートコントラクトをどのように定義しているかがわかります。
Applications from these organizations invoke this smart contract to perform an agreed step in a business process, for example to transfer ownership of a specific car from `ORG1` to `ORG2`.	ビジネスプロセスで合意した手続きを実行するためには、これらの組織のアプリケーションがこのスマートコントラクトを呼び出します。例えば、ある車の所有権を`ORG1`から`ORG2`へ譲渡するときなどです。
Hyperledger Fabric users often use the terms smart contract and chaincode interchangeably.	Hyperledger Fabricのユーザーは、よくスマートコントラクトとチェーンコードを同じ意味で使っています。
In general, a smart contract defines the transaction logic that controls the lifecycle of a business object contained in the world state.	一般的には、スマートコントラクトは、ワールドステートに格納されているビジネスデータのライフサイクルをコントロールするトランザクションのロジックを定義するものです。
It is then packaged into a chaincode which is then deployed to a blockchain network.	そして、ブロックチェーンネットワークにデプロイされるときには、スマートコントラクトはチェーンコードとしてパッケージ化されます。
Think of smart contracts as governing transactions, whereas chaincode governs how smart contracts are packaged for deployment.	スマートコントラクトはトランザクションを管理するもの、チェーンコードは、スマートコントラクトがデプロイのためにどのようにパッケージされるかを管理するものと考えてください。
A smart contract is defined within a chaincode.	スマートコントラクトは、チェーンコード内で定義されます。
Multiple smart contracts can be defined within the same chaincode.	一つのチェーンコードの中に複数のスマートコントラクトを定義することもできます。
When a chaincode is deployed, all smart contracts within it are made available to applications.	チェーンコードがデプロイされると、アプリケーションは、そのチェーンコードに含まれるスマートコントラクト全てを利用することができるようになります。
In the diagram, we can see a `vehicle` chaincode that contains three smart contracts: `cars`, `boats` and `trucks`.	この図では、`vehicle`(乗り物)というチェーンコードには、`car`・`boat`・`truck`という3つのスマートコントラクトが含まれていることがわかります。
We can also see an `insurance` chaincode that contains four smart contracts: `policy`, `liability`, `syndication` and `securitization`.	また、`insurance`(保険)というチェーンコードには、`policy`・`liability`・`syndication`・`securitization`という4つのスマートコントラクトが含まれていることがわかります。
In both cases these contracts cover key aspects of the business process relating to vehicles and insurance.	どちらのスマートコントラクトも、乗り物と保険に関するビジネスプロセスの重要な側面を扱っています。
In this topic, we will use the `car` contract as an example.	このトピックでは、例として、`car`スマートコントラクトを用いていきます。
We can see that a smart contract is a domain specific program which relates to specific business processes, whereas a chaincode is a technical container of a group of related smart contracts.	スマートコントラクトは、あるビジネスプロセスに関連した、ある分野特有のプログラムであり、チェーンコードは、関連するスマートコントラクト群を、技術的に格納するものであることがわかります。
At the simplest level, a blockchain immutably records transactions which update states in a ledger.	最も単純にいうと、ブロックチェーンは、台帳のステートを更新するトランザクションをイミュータブルに記録するものです。
A smart contract programmatically accesses two distinct pieces of the ledger -- a blockchain, which immutably records the history of all transactions, and a world state that holds a cache of the current value of these states, as it's the current value of an object that is usually required.	スマートコントラクトは、台帳の二つの異なる部分にプログラム的にアクセスします。一つは、全てのトランザクションの履歴をイミュータブルに記録するブロックチェーン。もう一つは、ステートの現在の値のキャッシュを保持するワールドステートです。これは、あるデータの現在値が普通は必要になるためです。
Smart contracts primarily put, get and delete states in the world state, and can also query the immutable blockchain record of transactions.	スマートコントラクトは、主に、ワールドステートを設定(put)、取得(get)、削除(delete)し、また、トランザクションのイミュータブルなブロックチェーンの記録をクエリすることもあります。
A get typically represents a query to retrieve information about the current state of a business object.	getは、あるビジネスデータの現在のステートについての情報を取得するクエリを通常表します。
A put typically creates a new business object or modifies an existing one in the ledger world state.	putは、新しいビジネスデータを作成したり、台帳のワールドステートにある既存のデータの変更を通常行います。
A delete typically represents the removal of a business object from the current state of the ledger, but not its history.	deleteは、台帳の現在のステートからビジネスデータを削除することを通常表します。ただし、履歴は削除されません。
Smart contracts have many [APIs](../developapps/transactioncontext.html#structure) available to them.	スマートコントラクトは多くの[API](../developapps/transactioncontext.html#structure)を利用できます。
Critically, in all cases, whether transactions create, read, update or delete business objects in the world state, the blockchain contains an [immutable record](../ledger/ledger.html) of these changes.	トランザクションが、ワールドステートにビジネスデータを作る・読む・更新する・削除する、いずれの場合でも極めて重要なことは、ブロックチェーンは、それらの変更の[イミュータブルな記録](../ledger/ledger.html)を持っているということです。
Smart contracts are the focus of application development, and as we've seen, one or more smart contracts can be defined within a single chaincode.	スマートコントラクトは、アプリケーション開発の中心であり、今まで見てきたように、一つのチェーンコードの中に一つあるいは複数のスマートコントラクトを定義することができます。
Deploying a chaincode to a network makes all its smart contracts available to the organizations in that network.	チェーンコードをネットワークにデプロイすると、そのネットワーク内の組織が、そのチェーンコード内の全てのスマートコントラクトを利用可能になります。
It means that only administrators need to worry about chaincode; everyone else can think in terms of smart contracts.	すなわち、管理者だけがチェーンコードについて注意する必要があり、管理者以外はスマートコントラクトとして考えることができるということです。
At the heart of a smart contract is a set of `transaction` definitions.	スマートコントラクトの中心にあるのは、トランザクション(`transaction`)の定義の集合です。
For example, look at fabcar.js [here](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/fabcar/javascript/lib/fabcar.js#L93), where you can see a smart contract transaction that creates a new car: You can learn more about the Fabcar smart contract in the [Writing your first application](../write_first_app.html) tutorial.	例えば、[この](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/fabcar/javascript/lib/fabcar.js#L93)fabcar.jsを見てみると、FabCarスマートコントラクトの詳細については、チュートリアルの[Writing your first application](../write_first_app.html)を参照してください。
A smart contract can describe an almost infinite array of business use cases relating to immutability of data in multi-organizational decision making.	スマートコントラクトによって、複数の組織の意思決定のデータのイミュータビリティに関わる、ほぼ無限のビジネスユースケースを記述することができます。
The job of a smart contract developer is to take an existing business process that might govern financial prices or delivery conditions, and express it as a smart contract in a programming language such as JavaScript, Go, or Java.	スマートコントラクト開発者の役割は、価格や運送条件を決定するといった既存のビジネスプロセスを取り上げ、それをJavaScript・Go・Javaといったプログラミング言語でスマートコントラクトとして記述することです。
The legal and technical skills required to convert centuries of legal language into programming language is increasingly practiced by smart contract auditors.	スマートコントラクトの作者の間では、多くの法律用語をプログラミング言語に変換するのに必要な、法的および技術的なスキルが使われることが増えています。
You can learn about how to design and develop a smart contract in the [Developing applications topic](../developapps/developing_applications.html).	スマートコントラクトをどのように設計し開発するかについては、[Developing applicationsのトピック](../developapps/developing_applications.html)を参照してください。
Associated with every chaincode is an endorsement policy that applies to all of the smart contracts defined within it.	エンドースメントポリシーは、各チェーンコードに結びついており、そのチェーンコード内で定義されたスマートコントラクト全てに適用されます。
An endorsement policy is very important;	エンドースメントポリシーは非常に重要です。
it indicates which organizations in a blockchain network must sign a transaction generated by a given smart contract in order for that transaction to be declared valid.	これは、ブロックチェーンネットワークのどの組織が、そのスマートコントラクトによって生成されたトランザクションに署名しなければならないかを示しています。これにより、そのトランザクションが正当である(valid)といえるかを規定します。
Every smart contract has an endorsement policy associated with it.	各スマートコントラクトには、エンドースメントポリシーが結びついています。
This endorsement policy identifies which organizations must approve transactions generated by the smart contract before those transactions can be identified as valid.	このエンドースメントポリシーは、スマートコントラクトによって生成されたトランザクションが、正当と認識されるために、どの組織が承認しなければいけないかを示しています。
An example endorsement policy might define that three of the four organizations participating in a blockchain network must sign a transaction before it is considered valid.	エンドースメントポリシーの例としては、トランザクションが正当とみなされるために、ブロックチェーンのネットワークに参加している4組織のうち3組織が署名しなければならない、という定義があるでしょう。
All transactions, whether valid or invalid are added to a distributed ledger, but only valid transactions update the world state.	全てのトランザクションは、それが正当である(valid)か正当でない(invalid)かにかかわらず、分散台帳に加えられますが、正当なトランザクションのみがワールドステートを更新します。
If an endorsement policy specifies that more than one organization must sign a transaction, then the smart contract must be executed by a sufficient set of organizations in order for a valid transaction to be generated.	もし、エンドースメントポリシーが、複数の組織が署名しなければならないと規定していた場合、スマートコントラクトは、正当なトランザクションが生成されるのに十分な組織の集合によって実行されなければなりません。
In the example [above](#endorsement), a smart contract transaction to `transfer` a car would need to be executed and signed by both `ORG1` and `ORG2` for it to be valid.	[上記の](#endorsement)例では、車を譲渡(`transfer`)するトランザクションは、正当とされるためには、`ORG1`と`ORG2`の両方によって実行され、署名されなければならないでしょう。
Endorsement policies are what make Hyperledger Fabric different to other blockchains like Ethereum or Bitcoin.	Hyperledger FabricがEthereumやBitcoinといった他のブロックチェーンと違うところは、このエンドースメントポリシーです。
In these systems valid transactions can be generated by any node in the network.	他のブロックチェーンでは、ネットワークのどのノードでも正当なトランザクションを生成することができます。
Hyperledger Fabric more realistically models the real world;	Hyperledger Fabricは、より現実的に実際の世界をモデル化しています。
transactions must be validated by trusted organizations in a network.	つまり、トランザクションは、信頼された組織によって検証されなければならない、ということです。
For example, a government organization must sign a valid `issueIdentity` transaction, or both the `buyer` and `seller` of a car must sign a `car` transfer transaction.	例えば、アイデンティティ発行(`issueIdentity`)の正当なトランザクションには、政府組織が署名していなければなりませんし、`car`スマートコントラクトの譲渡のトランザクションには、その車の買い手(`buyer`)と売り手(`seller`)の両方が署名していなければなりません。
Endorsement policies are designed to allow Hyperledger Fabric to better model these types of real-world interactions.	エンドースメントポリシーによって、Hyperledger Fabricは、このような種類の実際の世界でのやりとりを、よりよくモデル化することができます。
Finally, endorsement policies are just one example of [policy](../access_control.html#policies) in Hyperledger Fabric.	最後に、エンドースメントポリシーは、Hyperledger Fabricにおける[ポリシー](../access_control.html#policies)の一例にすぎません。
Other policies can be defined to identify who can query or update the ledger, or add or remove participants from the network.	他のポリシーには、誰が台帳にクエリあるいは更新ができるのか、あるいはネットワークの参加者を追加・削除できるのか、といったことを定義できるものがあります。
In general, policies should be agreed in advance by the consortium of organizations in a blockchain network, although they are not set in stone.	一般的に、ポリシーはブロックチェーンネットワークにおいて、組織のコンソーシアムによって事前に合意しておくべきものですが、これは不変のものではありません。
Indeed, policies themselves can define the rules by which they can be changed.	実際、ポリシーは誰によってポリシー自身を変更できるかの規則を定義することができます。
And although an advanced topic, it is also possible to define [custom endorsement policy](../pluggable_endorsement_and_validation.html) rules over and above those provided by Fabric.	そして、これは高度なトピックになりますが、Fabricの提供するものを上書きして[エンドースメントポリシーをカスタマイズ](../pluggable_endorsement_and_validation.html)することも可能です。
When a smart contract executes, it runs on a peer node owned by an organization in the blockchain network.	スマートコントラクトの実行は、ブロックチェーンネットワークのある組織が所有するピアノード上で行われます。
The contract takes a set of input parameters called the transaction proposal and uses them in combination with its program logic to read and write the ledger.	スマートコントラクトは、トランザクション提案と呼ばれる入力パラメータのセットをとり、それをプログラムロジックと合わせて使うことで、台帳の読み書きを行います。
Changes to the world state are captured as a transaction proposal response (or just transaction response) which contains a read-write set with both the states that have been read, and the new states that are to be written if the transaction is valid.	ワールドステートへの変更はトランザクション提案応答(もしくは単純にトランザクション応答)という形でとらえれます。提案応答は、トランザクションが読んだステートと、トランザクションが正当となった場合に書き込まれる新しいステートからなる読み書きセット(read-write set)を含んでいます。
Notice that the world state is not updated when the smart contract is executed!	ワールドステートは、スマートコントラクトが実行された時点では更新されないということに注意してください。
All transactions have an identifier, a proposal, and a response signed by a set of organizations.	全てのトランザクションは、識別子、提案、組織の集合によって署名された応答を含んでいます。
All transactions are recorded on the blockchain, whether valid or invalid, but only valid transactions contribute to the world state.	全てのトランザクションは正当かどうかにかかわらず、全てブロックチェーンに記録されますが、正当なトランザクションのみがワールドステートに反映されます。
Examine the `car transfer` transaction.	車の譲渡(`car transfer`)トランザクションを見てみましょう。
You can see a transaction `t3` for a car transfer between `ORG1` and `ORG2`.	トランザクション`t3`は、`ORG1`と`ORG2`の間で車の譲渡をおこなうものであることがわかります。
See how the transaction has input `{CAR1, ORG1, ORG2}` and output `{CAR1.owner=ORG1, CAR1.owner=ORG2}`, representing the change of owner from `ORG1` to `ORG2`.	このトランザクションは、入力として`{CAR1, ORG1, ORG2}`を持ち、出力として`{CAR1.owner=ORG1, CAR1.owner=ORG2}`を持っており、これは、`ORG1`から`ORG2`への所有者の変更を表しています。
Notice how the input is signed by the application's organization `ORG1`, and the output is signed by both organizations identified by the endorsement policy, `ORG1` and `ORG2`.	この入力は、アプリケーションの組織である`ORG1`によって署名されていますが、出力は、エンドースメントポリシーで指定されている組織`ORG1`と`ORG2`の両方によって署名されていることに注意してください。
These signatures were generated by using each actor's private key, and mean that anyone in the network can verify that all actors in the network are in agreement about the transaction details.	これらの署名は、それぞれのアクターの秘密鍵によって生成されたもので、このトランザクションの内容がネットワーク上のすべてのアクターによって合意されたものであることを、ネットワーク上の誰でも確認することができることを意味します。
A transaction that is distributed to all peer nodes in the network is validated in two phases by each peer.	ネットワーク上のすべてのピアノードに配布されたトランザクションは、各ピアで2フェーズで検証されます。
Firstly, the transaction is checked to ensure it has been signed by sufficient organizations according to the endorsement policy.	最初に、トランザクションがエンドースメントポリシーに従って十分な組織によって署名されているかをチェックします。
Secondly, it is checked to ensure that the current value of the world state matches the read set of the transaction when it was signed by the endorsing peer nodes; that there has been no intermediate update.	次に、ワールドステートの現在の値が、エンドーシングピアノードが署名した時点のトランザクションの読み込みセットと一致しており、その間に更新がないことをチェックします。
If a transaction passes both these tests, it is marked as valid.	トランザクションが両方のテストに通ると、そのトランザクションは正当であるとしてマークされます。
All transactions are added to the blockchain history, whether valid or invalid, but only valid transactions result in an update to the world state.	全てのトランザクションは、それが正当であるか正当でないかにかかわらず、ブロックチェーンの履歴に追加されますが、正当であるトランザクションの結果のみが、ワールドステートを更新します。
In our example, `t3` is a valid transaction, so the owner of `CAR1` has been updated to `ORG2`.	この例では、`t3`は正当なトランザクションなので、`CAR1`の所有者は`ORG2`に更新されます。
However, `t4` (not shown) is an invalid transaction, so while it was recorded in the ledger, the world state was not updated, and `CAR2` remains owned by `ORG2`.	しかし、正当ではないトランザクションの`t4`(図にはありません)は、台帳には記録されますがワールドステートは更新されず、`CAR2`の所有者は`ORG2`のままです。
Finally, to understand how to use a smart contract or chaincode with world state, read the [chaincode namespace topic](../developapps/chaincodenamespace.html).	最後に、スマートコントラクトあるいはチェーンコードとワールドステートの使い方については、[chaincode namespaceのトピック](../developapps/chaincodenamespace.html)を参照してください。
Hyperledger Fabric allows an organization to simultaneously participate in multiple, separate blockchain networks via channels.	Hyperledger Fabricでは、一つの組織は、複数の別のブロックチェーンネットワークにチャネルを通して同時に参加することができます。
By joining multiple channels, an organization can participate in a so-called network of networks.	複数のチャネルに参加することで、組織は、いわゆるネットワークのネットワークに参加することができます。
Channels provide an efficient sharing of infrastructure while maintaining data and communications privacy.	チャネルによって、データとやりとりのプライバシーを保持しつつ、インフラを効率的に共有することができます。
They are independent enough to help organizations separate their work traffic with different counterparties, but integrated enough to allow them to coordinate independent activities when necessary.	チャネルは、組織が別の取引相手とのトラフィックの分離に役立つのに十分なほど独立でありつつ、必要があればそれぞれの活動を協調することができるほどには統合されているものです。
A channel provides a completely separate communication mechanism between a set of organizations.	チャネルは、組織の集合の間での完全に分離した通信メカニズムを提供します。
When a chaincode definition is committed to a channel, all the smart contracts within the chaincode are made available to the applications on that channel.	チェーンコード定義がチャネルにコミットされると、そのチェーンコードのスマートコントラクトはすべてそのチャネルのアプリケーションが利用可能になります。
While the smart contract code is installed inside a chaincode package on an organizations peers, channel members can only execute a smart contract after the chaincode has been defined on a channel.	スマートコントラクトのコードは、チェーンコードパッケージの中という形で組織のピアにインストールされますが、チャネルのメンバーがスマートコントラクトの実行が可能なのは、チャネルで定義された後のみです。
The chaincode definition is a struct that contains the parameters that govern how a chaincode operates.	チェーンコード定義は、チェーンコードがどのように運用されるかを管理するパラメータを含む構造体です。
These parameters include the chaincode name, version, and the endorsement policy.	このパラメータには、チェーンコードの名前、バージョン、エンドースメントポリシーを含みます。
Each channel member agrees to the parameters of a chaincode by approving a chaincode definition for their organization.	各チャネルメンバーは、それぞれの組織でチェーンコード定義を承認することで、チェーンコードのパラメータに同意します。
When a sufficient number of organizations (a majority by default) have approved to the same chaincode definition, the definition can be committed to the channel.	十分な数の組織(デフォルトでは過半数)が同じチェーンコード定義を承認すると、その定義がチャネルにコミットできるようになります。
The smart contracts inside the chaincode can then be executed by channel members, subject to the endorsement policy specified in the chaincode definition.	そののち、チェーンコードに含まれるスマートコントラクトは、チェーンコード定義に規定されたエンドースメントポリシーに従って、チャネルのメンバーにより実行可能になります。
The endorsement policy applies equally to all smart contracts defined within the same chaincode.	エンドースメントポリシーは、同じチェーンコードに含まれるすべてのスマートコントラクトに対して同じものが適用されます。
In the example [above](#channels), a `car` contract is defined on the `VEHICLE` channel, and an `insurance` contract is defined on the `INSURANCE` channel.	[上記の](#channels)例では、`car`スマートコントラクトは、`VEHICLE`チャネルで定義されており、`insurance`スマートコントラクトは、`INSURANCE`チャネルで定義されています。
The chaincode definition of `car` specifies an endorsement policy that requires both `ORG1` and `ORG2` to sign transactions before they can be considered valid.	`car`のチェーンコード定義のエンドースメントポリシーは、トランザクションが正当とみなされるには、`ORG1`と`ORG2`の両方により署名されなければならないというものです。
The chaincode definition of the `insurance` contract specifies that only `ORG3` is required to endorse a transaction.	`insurance`スマートコントラクトのチェーンコード定義は、トランザクションのエンドースには`ORG3`のみが必要と指定しています。
`ORG1` participates in two networks, the `VEHICLE` channel and the `INSURANCE` network, and can coordinate activity with `ORG2` and `ORG3` across these two networks.	`ORG1`は`VEHICLE`チャネルと`INSURACE`ネットワークの両方に参加しており、これら二つのネットワークを通して`ORG2`と`ORG3`と協調した活動を行うことができます。
The chaincode definition provides a way for channel members to agree on the governance of a chaincode before they start using the smart contract to transact on the channel.	チェーンコード定義は、チャネルメンバーが、チャネルでトランザクションを発行するためにスマートコントラクトを使いはじめる前に、チェーンコードの管理について合意する方法を提供しています。
Building on the example above, both `ORG1` and `ORG2` want to endorse transactions that invoke the `car` contract.	上記の例において、`ORG1`と`ORG2`の両方が`car`スマートコントラクトを呼び出すトランザクションをエンドースしたいとします。
Because the default policy requires that a majority of organizations approve a chaincode definition, both organizations need to approve an endorsement policy of `AND{ORG1,ORG2}`.	デフォルトのポリシーではチェーンコード定義は、過半数の組織によって承認されなければならないので、`AND{ORG1,ORG2}`というエンドースメントポリシーを両方の組織が承認する必要があります。
Otherwise, `ORG1` and `ORG2` would approve different chaincode definitions and would be unable to commit the chaincode definition to the channel as a result.	そうでなく、`ORG1`と`ORG2`が別のチェーンコード定義を承認したとすると、結果としてそのチェーンコード定義をチャネルにコミットすることができなくなるでしょう。
This process guarantees that a transaction from the `car` smart contract needs to be approved by both organizations.	このプロセスによって、`car`スマートコントラクトのトランザクションは、二つの組織によって承認されなければらないということを保証しています。
A Smart Contract can call other smart contracts both within the same channel and across different channels.	スマートコントラクトは、同じチャネルや異なるチャネルの他のスマートコントラクトを呼び出すことができます。
It this way, they can read and write world state data to which they would not otherwise have access due to smart contract namespaces.	このようにして、スマートコントラクトのネームスペースの問題で、通常はアクセスできないワールドステートに対して読み書きを行うことができます。
There are limitations to this inter-contract communication, which are described fully in the [chaincode namespace](../developapps/chaincodenamespace.html#cross-chaincode-access) topic.	このスマートコントラクト間のやりとりについては制限があり、[chaincode namespace](../developapps/chaincodenamespace.html#cross-chaincode-access)トピックで十分に解説されています。
The smart contracts defined within a chaincode encode the domain dependent rules for a business process agreed between a set of blockchain organizations.	チェーンコード内で定義されたスマートコントラクトは、ブロックチェーンの組織の集合の間で合意されたビジネスプロセスについて分野依存のルールをエンコードしたものです。
However, a chaincode can also define low-level program code which corresponds to domain independent system interactions, unrelated to these smart contracts for business processes.	しかし、チェーンコードは、分野に依存しない、ビジネスプロセスのためのスマートコントラクトとは関係のない、システムのやりとりに対応する低レベルなプログラムコードを定義することができます。
The following are the different types of system chaincodes and their associated abbreviations:	システムチェーンコードの種類とその略語は、下記の通りです。
`_lifecycle` runs in all peers and manages the installation of chaincode on your peers, the approval of chaincode definitions for your organization, and the committing of chaincode definitions to channels.	`_lifecycle` は、すべてのピアで実行され、ピアでのチェーンコードのインストール、チェーンコード定義の組織での承認、チャネルへのチェーンコード定義のコミットを管理します。
You can read more about how `_lifecycle` implements the Fabric chaincode lifecycle [process](../chaincode_lifecycle.html).	`_lifecycle`がどのようにFabricのチェーンコードライフサイクルを実装しているかの詳細については、[process](../chaincode_lifecycle.html)を参照してください。
Lifecycle system chaincode (LSCC) manages the chaincode lifecycle for the 1.x releases of Fabric.	ライフサイクル・システムチェーンコード(LSCC)は、Fabricの1.xリリースでのチェーンコードライフサイクルを管理します。
This version of lifecycle required that chaincode be instantiated or upgraded on channels.	このバージョンのライフサイクルは、チェーンコードをチャネルでインスタンス化(instantiate)・アップグレードする必要がありました。
You can still use LSCC to manage your chaincode if you have the channel application capability set to V1_4_x or below.	チャネルのアプリケーションケーパビリティがV1_4_x以下に設定されている場合は、まだLSCCをチェーンコードの管理に使い続けることができます。
Configuration system chaincode (CSCC) runs in all peers to handle changes to a channel configuration, such as a policy update.	コンフィギュレーション・システムチェーンコード(CSCC)は、すべてのピアで実行され、ポリシーの更新といったチャネルのコンフィギュレーションを管理します。
You can read more about this process in the following chaincode [topic](../configtx.html#configuration-updates).	このプロセスについては、このチェーンコードの[トピック](../configtx.html#configuration-updates)を参照してください。
Query system chaincode (QSCC) runs in all peers to provide ledger APIs which include block query, transaction query etc.	クエリ・システムチェーンコード(QSCC)は、すべてのピアで実行され、ブロックのクエリやトランザクションのクエリを含む台帳のAPIを提供します。
You can read more about these ledger APIs in the transaction context [topic](../developapps/transactioncontext.html).	台帳のAPIについては、トランザクション・コンテキストの[トピック](../developapps/transactioncontext.html)を参照してください。
Endorsement system chaincode (ESCC) runs in endorsing peers to cryptographically sign a transaction response.	エンドースメント・システムチェーンコード(ESCC)は、エンドーシングピアで実行され、トランザクション応答に対して暗号的に署名を行います。
You can read more about how the ESCC implements this [process](../peers/peers.html#phase-1-proposal).	ESCCのこのプロセスの実装については、[こちら](../peers/peers.html#phase-1-proposal)を参照してください。
Validation system chaincode (VSCC) validates a transaction, including checking endorsement policy and read-write set versioning.	検証システムチェーンコード(VSCC)は、エンドースメントポリシーのチェックや読み書きセットのバージョンのチェックを含むトランザクションの検証を行います。
You can read more about the VSCC implements this [process](../peers/peers.html#phase-3-validation).	VSCCのこのプロセスの実装については、[こちら](../peers/peers.html#phase-3-validation)を参照してください。
It is possible for low level Fabric developers and administrators to modify these system chaincodes for their own uses.	低レベルのFabric開発者や管理者は、これらのシステムチェーンコードを自分の用途のために変更することができます。
However, the development and management of system chaincodes is a specialized activity, quite separate from the development of smart contracts, and is not normally necessary.	しかし、システムチェーンコードの開発と管理は、非常に特化した作業であり、スマートコントラクトの開発とはきわめて異なるもので、通常必要となるものではありません。
Changes to system chaincodes must be handled with extreme care as they are fundamental to the correct functioning of a Hyperledger Fabric network.	システムチェーンコード、Hyperledger Fabricのネットワークの正しい動作の基礎となるものなので、変更は細心の注意をもって行わなければなりません。
For example, if a system chaincode is not developed correctly, one peer node may update its copy of the world state or blockchain differently compared to another peer node.	例えば、もしシステムチェーンコードが正しく開発されなかった場合、ワールドステートやブロックチェーンに対して、あるピアノードは他のピアのノードとは異なる更新を行ってしまうかもしれません。
This lack of consensus is one form of a ledger fork, a very undesirable situation.	この合意形成が失われている状態は、台帳のフォークの一種であり、非常に好ましくない状況です。
Hyperledger Fabric Model	Hyperledger Fabric モデル
This section outlines the key design features woven into Hyperledger Fabric that fulfill its promise of a comprehensive, yet customizable, enterprise blockchain solution:	このセクションでは、Hyperledger Fabricに組み込まれた、包括的でありながらカスタマイズ可能なエンタープライズブロックチェーンソリューションとしての役割を果たす主要な設計機能の概要を説明します:
`Assets`_ --- Asset definitions enable the exchange of almost anything with monetary value over the network, from whole foods to antique cars to currency futures.	`資産`_ --- 資産の定義によって、自然食品からクラシックカーや通貨先物まで、ネットワークを介して金銭的価値を持つほぼすべてのものを交換できます。
`Chaincode`_ --- Chaincode execution is partitioned from transaction ordering, limiting the required levels of trust and verification across node types, and optimizing network scalability and performance.	`チェーンコード`_ --- チェーンコードの実行は、トランザクションの順序付け、ノードタイプ間で必要な信頼と検証のレベルの制限、およびネットワークのスケーラビリティとパフォーマンスの最適化から分離されています。
`Ledger Features`_ --- The immutable, shared ledger encodes the entire transaction history for each channel, and includes SQL-like query capability for efficient auditing and dispute resolution.	`台帳機能`_ --- イミュータブルな共有台帳は、各チャネルのトランザクション履歴全体をエンコードし、効率的な監査と係争解決のためにSQLに似たクエリ機能を備えています(訳注:台帳は後から第三者が参照・検証可能で、干渉したトランザクションがどのように解決されたかチェックできる機能を備えています)。
`Privacy`_ --- Channels and private data collections enable private and confidential multi-lateral transactions that are usually required by competing businesses and regulated industries that exchange assets on a common network.	`プライバシー`_ --- チャネルとプライベートデータコレクションによって、共通のネットワーク上で資産を交換する競合企業や規制された業界が通常必要とする、プライベートおよび機密の多組織間のトランザクションが可能になります。
`Security & Membership Services`_ --- Permissioned membership provides a trusted blockchain network, where participants know that all transactions can be detected and traced by authorized regulators and auditors.	`セキュリティおよびメンバーシップサービス`_ --- 許可型のメンバーシップは、信頼されたブロックチェーンネットワークを提供します。このネットワークでは、承認された規制機関や監査機関がすべてのトランザクションを検出し、トレースできることが参加者に知らされます。
`Consensus`_ --- A unique approach to consensus enables the flexibility and scalability needed for the enterprise.	`合意形成`_ --- 合意形成に対するユニークなアプローチは、企業にとって必要な柔軟性と拡張性をもたらします。
Assets	資産
Assets can range from the tangible (real estate and hardware) to the intangible (contracts and intellectual property).	資産は、有形資産(不動産およびハードウェア)から無形資産(契約および知的財産)まで多岐にわたります。
Hyperledger Fabric provides the ability to modify assets using chaincode transactions.	Hyperledger Fabricは、チェーンコード取引を使用して資産を変更できます。
Assets are represented in Hyperledger Fabric as a collection of key-value pairs, with state changes recorded as transactions on a :ref:`Channel` ledger.	資産は、キーと値のペアの集合としてHyperledger Fabricで表現され、状態の変更は、:ref:`Channel` の台帳上にトランザクションとして記録されます。
Assets can be represented in binary and/or JSON form.	資産は、バイナリ形式またはJSON形式、あるいはその両方で表現できます。
Chaincode	チェーンコード
Chaincode is software defining an asset or assets, and the transaction instructions for modifying the asset(s);	チェーンコードは、資産を定義するソフトウェアであり、資産を変更するための取引指示です。
in other words, it's the business logic.	つまり、ビジネスロジックです。
Chaincode enforces the rules for reading or altering key-value pairs or other state database information.	チェーンコードは、キーと値のペアまたはその他のステートデータベース情報の読み取りまたは変更に対して、その規則を強制します。
Chaincode functions execute against the ledger's current state database and are initiated through a transaction proposal.	チェーンコード関数は、台帳の現在のステートデータベースに対して実行され、トランザクション提案を通じて開始されます。
Chaincode execution results in a set of key-value writes (write set) that can be submitted to the network and applied to the ledger on all peers.	チェーンコードの実行によって作成されるキーと値の書き込みの集合(書き込みセット)は、ネットワークに送信され、すべてのピアの台帳に適用されます。
Ledger Features	台帳機能
The ledger is the sequenced, tamper-resistant record of all state transitions in the fabric.	台帳は、 Fabric内のすべての状態遷移に関する、順序付けられた改ざん防止レコードです。
State transitions are a result of chaincode invocations ('transactions') submitted by participating parties.	状態遷移は、参加当事者によって提出されたチェーンコード呼び出し('トランザクション')の結果です。
Each transaction results in a set of asset key-value pairs that are committed to the ledger as creates, updates, or deletes.	各トランザクションでは、資産に関するキーと値のペアのセットを作成、更新または削除という形で台帳に記録します。
The ledger is comprised of a blockchain ('chain') to store the immutable, sequenced record in blocks, as well as a state database to maintain current fabric state.	この台帳は、ブロックチェーン('チェーン')で構成され、イミュータブルで順序付けられたレコードをブロックに格納します。また、現在の Fabric状態を維持するためのステートデータベースもあります。
There is one ledger per channel.	チャネルごとに1つの台帳があります。
Each peer maintains a copy of the ledger for each channel of which they are a member.	各ピアは、メンバーであるチャネルごとに台帳のコピーを保持します。
Some features of a Fabric ledger:	Fabric台帳には以下のような機能があります:
Query and update ledger using key-based lookups, range queries, and composite key queries	キーベースでの参照、範囲クエリおよび複合キークエリを使用した台帳のクエリおよび更新
Read-only queries using a rich query language (if using CouchDB as state database)	リッチなクエリ言語を使用した読み取り専用クエリ(ステートデータベースとしてCouchDBを使用している場合)
Read-only history queries --- Query ledger history for a key, enabling data provenance scenarios	読取り専用履歴クエリ --- キーの台帳履歴のクエリにより、データの来歴を追うことが可能
Transactions consist of the versions of keys/values that were read in chaincode (read set) and keys/values that were written in chaincode (write set)	トランザクションは、チェーンコードで読み取られたキー/値のバージョン(読み取りセット)とチェーンコードで書き込まれたキー/値のバージョン(書き込みセット)で構成されます
Transactions contain signatures of every endorsing peer and are submitted to ordering service	トランザクションには、すべてのエンドーシングピアの署名が含まれ、オーダリングサービスに送信されます
Transactions are ordered into blocks and are "delivered" from an ordering service to peers on a channel	トランザクションはブロック内で順序付けられ、オーダリングサービスからチャネル上のピアに"配信"されます
Peers validate transactions against endorsement policies and enforce the policies	ピアは、トランザクションをエンドースメントポリシーと照合して検証し、ポリシーを強制します
Prior to appending a block, a versioning check is performed to ensure that states for assets that were read have not changed since chaincode execution time	ブロックを追加する前に、バージョンチェックを実行して、読み込まれたアセットの状態がチェーンコードの実行時以降に変更されていないことを確認します
There is immutability once a transaction is validated and committed	トランザクションが検証されコミットされて、イミュータビリティが生じます
A channel's ledger contains a configuration block defining policies, access control lists, and other pertinent information	チャネルの台帳には、ポリシー、アクセスコントロールリスト、他の関連情報を定義するコンフィギュレーションブロックが含まれます
Channels contain :ref:`MSP` instances allowing for crypto materials to be derived from different certificate authorities	チャネルには :ref:`MSP` インスタンスが含まれ、これにより暗号資料を異なる認証局から取得できます
See the :doc:`ledger` topic for a deeper dive on the databases, storage structure, and "query-ability."	データベース、ストレージ構造、"クエリ機能"の詳細については、 :doc:`ledger` のトピックを参照してください。
Privacy	プライバシー
Hyperledger Fabric employs an immutable ledger on a per-channel basis, as well as chaincode that can manipulate and modify the current state of assets (i.e. update key-value pairs).	Hyperledger Fabricは、チャネル単位でイミュータブルな台帳を使用するとともに、資産の現在の状態を操作および変更できるチェーンコード(キーと値のペアを更新)を使用します。
A ledger exists in the scope of a channel ---	台帳は、チャネルの単位で存在します。
it can be shared across the entire network (assuming every participant is operating on one common channel) --- or it can be privatized to include only a specific set of participants.	台帳は、ネットワーク全体で共有することも(すべての参加者が1つの共通チャネルで動作していると仮定)、特定の参加者のセットのみを含めるように私有化することもできます。
In the latter scenario, these participants would create a separate channel and thereby isolate/segregate their transactions and ledger.	後者のシナリオでは、これらの参加者は別のチャネルを作成し、それによってトランザクションと台帳を隔離/分離します。
In order to solve scenarios that want to bridge the gap between total transparency and privacy, chaincode can be installed only on peers that need to access the asset states to perform reads and writes (in other words, if a chaincode is not installed on a peer, it will not be able to properly interface with the ledger).	完全な透過性とプライバシーの間のギャップを埋めたいというシナリオを解決するために、チェーンコードは、読み取りと書き込みを実行するために資産状態にアクセスする必要があるピアにのみインストールできます(つまりチェーンコードがピアにインストールされていない場合、そのピアは台帳のインターフェースに適切に接続することができません)。
When a subset of organizations on that channel need to keep their transaction data confidential, a private data collection (collection) is used to segregate this data in a private database, logically separate from the channel ledger, accessible only to the authorized subset of organizations.	そのチャネル上の組織のサブセットが取引データの機密を保持する必要がある場合、プライベートデータコレクション(コレクション)を使用して、チャネル台帳から論理的に分離されたプライベートデータベース内にこのデータを分離し、承認された組織のサブセットのみがアクセスできるようにします。
Thus, channels keep transactions private from the broader network whereas collections keep data private between subsets of organizations on the channel.	したがって、チャネルは、より広いネットワークからトランザクションをプライベートに保つ一方で、コレクションは、チャネル上の組織のサブセット間においてデータをプライベートに保ちます。
To further obfuscate the data, values within chaincode can be encrypted (in part or in total) using common cryptographic algorithms such as AES before sending transactions to the ordering service and appending blocks to the ledger.	データをさらに難読化するには、AESなどの一般的な暗号化アルゴリズムを使用してチェーンコード内の値を(部分的または全体的に)暗号化してから、オーダリングサービスにトランザクションを送信し、台帳にブロックを追加します。
Once encrypted data has been written to the ledger, it can be decrypted only by a user in possession of the corresponding key that was used to generate the cipher text.	暗号化されたデータは、台帳に書き込まれた後、暗号テキストの生成に使用された対応するキーを持つユーザーだけが復号できます。
See the :doc:`private-data-arch` topic for more details on how to achieve privacy on your blockchain network.	ブロックチェーンネットワークでプライバシーを実現する方法の詳細については、:doc:`private-data-arch` のトピックを参照してください。
Security & Membership Services	セキュリティおよびメンバーシップサービス
Hyperledger Fabric underpins a transactional network where all participants have known identities.	Hyperledger Fabricは、すべての参加者が既知のアイデンティティを持つトランザクションネットワークをサポートします。
Public Key Infrastructure is used to generate cryptographic certificates which are tied to organizations, network components, and end users or client applications.	公開鍵インフラストラクチャは、組織、ネットワークコンポーネント、およびエンドユーザもしくはクライアントアプリケーションに関連付けられた暗号化証明書を生成するために使用されます。
As a result, data access control can be manipulated and governed on the broader network and on channel levels.	その結果、データアクセス制御は、より広範なネットワークおよびチャネルレベルで操作および管理できます。
This "permissioned" notion of Hyperledger Fabric, coupled with the existence and capabilities of channels, helps address scenarios where privacy and confidentiality are paramount concerns.	Hyperledger Fabricのこの"許可型"概念は、チャネルの存在と機能と相まって、プライバシーと機密性が最も重要な関心事であるシナリオに対処するのに役立ちます。
See the :doc:`msp` topic to better understand cryptographic implementations, and the sign, verify, authenticate approach used in Hyperledger Fabric.	暗号化の実装をよりよく理解するには :doc:`msp` のトピックを参照してください。また、Hyperledger Fabricで使用される署名、検証、認証のアプローチを参照してください。
Consensus	合意形成
In distributed ledger technology, consensus has recently become synonymous with a specific algorithm, within a single function.	分散台帳技術では、合意形成は単一機能内における特定のアルゴリズムを表す言葉として近年では捉えられています。
However, consensus encompasses more than simply agreeing upon the order of transactions, and this differentiation is highlighted in Hyperledger Fabric through its fundamental role in the entire transaction flow, from proposal and endorsement, to ordering, validation and commitment.	しかしながら、合意形成は単にトランザクションの順序に合意するためだけではありません。Hyperledger Fabricでは、提案およびエンドースメントから、オーダリング、検証およびコミットに至るまで、トランザクションフロー全体における基本的な役割を通じて、この合意形成の役割の違いが強調されています。
In a nutshell, consensus is defined as the full-circle verification of the correctness of a set of transactions comprising a block.	簡単に言うと、コンセンサスは、ブロックを構成する一連のトランザクションの正確さを完全に検証する一連のプロセスとして定義されます。
Consensus is achieved ultimately when the order and results of a block's transactions have met the explicit policy criteria checks.	ブロックのトランザクションの順序と結果が明示的なポリシー基準のチェックを満たすことによって、合意形成は最終的に達成されます。
These checks and balances take place during the lifecycle of a transaction, and include the usage of endorsement policies to dictate which specific members must endorse a certain transaction class, as well as system chaincodes to ensure that these policies are enforced and upheld.	これらの抑制と均衡は、トランザクションのライフサイクルの間に行われ、特定のトランザクションクラスをどの特定のメンバーが承認する必要があるかを決定するためのエンドースメントポリシーの使用と、これらのポリシーが確実に強制および維持されるようにするためのシステムチェーンコードを含みます。
Prior to commitment, the peers will employ these system chaincodes to make sure that enough endorsements are present, and that they were derived from the appropriate entities.	コミットの前に、ピアは、十分なエンドースメントが存在し、それらが適切なエンティティから得られたものであることを確認するために、これらのシステムチェーンコードを利用します。
Moreover, a versioning check will take place during which the current state of the ledger is agreed or consented upon, before any blocks containing transactions are appended to the ledger.	さらに、トランザクションを含むブロックが台帳に追加される前に、台帳の現在の状態が合意または同意されているバージョンであるかチェックをします。
This final check provides protection against double spend operations and other threats that might compromise data integrity, and allows for functions to be executed against non-static variables.	この最終チェックにより、データの整合性を損なう可能性のある重複支出操作およびその他の脅威から保護され、静的ではない変数に対して関数を実行できます。
In addition to the multitude of endorsement, validity and versioning checks that take place, there are also ongoing identity verifications happening in all directions of the transaction flow.	エンドースメントの数、妥当性、バージョン管理のチェックが行われるだけでなく、トランザクションフローにおけるすべての通信間でアイデンティティの検証が行われています。
Access control lists are implemented on hierarchical layers of the network (ordering service down to channels), and payloads are repeatedly signed, verified and authenticated as a transaction proposal passes through the different architectural components.	アクセスコントロールリストは、(オーダリングサービスからチャネルまでの)ネットワークの階層レイヤで実装され、トランザクション提案がさまざまなアーキテクチャコンポーネントを通過するときに、ペイロードが繰り返し署名、検証、および認証されます。
To conclude, consensus is not merely limited to the agreed upon order of a batch of transactions; rather, it is an overarching characterization that is achieved as a byproduct of the ongoing verifications that take place during a transaction's journey from proposal to commitment.	結論として、合意形成は、一連のトランザクションの順序に関して合意する役割に限定されるのではなく、提案からコミットまでのトランザクションの過程で繰り返し行われる検証の副産物として達成される包括的な役割を持っています。
Check out the :doc:`txflow` diagram for a visual representation of consensus.	合意形成を視覚的に表現するには、 :doc:`txflow` の図を見てください。
Before you begin, you should confirm that you have installed all the prerequisites below on the platform where you will be running Hyperledger Fabric.	始める前に、Hyperledger Fabricを実行するプラットフォームに以下のすべての前提条件がインストールされていることを確認する必要があります。
..note:: These prerequisites are recommended for Fabric users.	.. note:: これらの前提条件は、Fabricのユーザーに推奨されます。
If you are a Fabric developer you should refer to the instructions for :doc:`dev-setup/devenv`.	もしあなたがFabricの開発者なら、 :doc:`dev-setup/devenv` の説明を参照するべきです。
Download the latest version of `git <https://git-scm.com/downloads>`_ if it is not already installed, or if you have problems running the curl commands.	`git <https://git-scm.com/downloads>`_ がまだインストールされていない場合や、curlコマンドの実行に問題がある場合には、gitの最新バージョンをダウンロードしてください。
Download the latest version of the `cURL <https://curl.haxx.se/download.html>`__ tool if it is not already installed or if you get errors running the curl commands from the documentation.	`cURL <https://curl.haxx.se/download.html>`_ ツールがまだインストールされていない場合、またはドキュメント内のcurlコマンドの実行中にエラーが発生した場合は、最新バージョンのcURLツールをダウンロードしてください。
..note:: If you're on Windows please see the specific note on `Windows extras`_ below.	.. note:: Windowsを使用している場合には、後述の `Windows extras`_ に記述している注意事項を参照してください。
You will need the following installed on the platform on which you will be operating, or developing on (or for), Hyperledger Fabric:	Hyperledger Fabricを運用する、Hyperledger Fabric上で開発する（またはHyperledger Fabricのために開発する）プラットフォームには以下がインストールされている必要があります:
MacOSX, \*nix, or Windows 10: `Docker <https://www.docker.com/get-docker>`__ Docker version 17.06.2-ce or greater is required.	MacOSX、\*nix、 またはWindows 10: `Docker <https://www.docker.com/get-docker>`__Dockerのバージョン「Docker 17.06.2-ce」以降が必要です。
Older versions of Windows: `Docker Toolbox <https://docs.docker.com/toolbox/toolbox_install_windows/>`__ - again, Docker version Docker 17.06.2-ce or greater is required.	古いバージョンのWindows: `Docker Toolbox <https://docs.docker.com/toolbox/toolbox_install_windows/>`__ と、Dockerのバージョン「Docker 17.06.2-ce」以降が必要です。
You can check the version of Docker you have installed with the following command from a terminal prompt: ..	ターミナルのプロンプトから次のコマンドを使用して、インストールしたDockerのバージョンを確認することができます:
note:: The following applies to linux systems running systemd.	.. note:: 以下は、systemdを実行しているLinuxシステムに適用されます。
Make sure the docker daemon is running.	dockerデーモンが実行されていることを確認してください。
Optional: If you want the docker daemon to start when the system starts, use the following:	オプション: システムの起動時にdockerデーモンを起動する場合は、以下を使用します:
Add your user to the docker group.	ユーザーをdockerグループに追加します。
..note:: Installing Docker for Mac or Windows, or Docker Toolbox will also install Docker Compose.	.. note:: MacまたはWindows用のDocker、またはDocker Toolboxをインストールすると、Docker Composeもインストールされます。
If you already had Docker installed, you should check that you have Docker Compose version 1.14.0 or greater installed.	すでにDockerがインストールされている場合は、Docker Composeのバージョン1.14.0以降がインストールされていることを確認してください。
If not, we recommend that you install a more recent version of Docker.	そうでない場合は、より新しいバージョンのDockerをインストールすることをお勧めします。
You can check the version of Docker Compose you have installed with the following command from a terminal prompt:	ターミナルのプロンプトから次のコマンドを使用して、インストールしたDocker Composeのバージョンを確認できます:
On Windows 10 you should use the native Docker distribution and you may use the Windows PowerShell.	Windows 10では、WindowsネイティブのDockerディストリビューションを使用する必要があり、Windows PowerShellを使用できます。
However, for the ``binaries`` command to succeed you will still need to have the ``uname`` command available.	ただし、 ``binaries`` コマンドを成功させるには、 ``uname`` コマンドを使用できるようにする必要があります。
You can get it as part of Git but beware that only the 64bit version is supported.	それはGitの一部として入手できますが、64ビット版のみがサポートされていることに注意してください。
Before running any ``git clone`` commands, run the following commands:	``git clone`` コマンドを実行する前に、次のコマンドを実行してください:
You can check the setting of these parameters with the following commands:	これらのパラメータの設定値は、次のコマンドで確認できます:
These need to be ``false`` and ``true`` respectively.	これらはそれぞれ ``false`` と ``true`` である必要があります。
The ``curl`` command that comes with Git and Docker Toolbox is old and does not handle properly the redirect used in :doc:`getting_started`.	GitとDocker Toolboxに付属している ``curl`` コマンドは古く、:doc:`getting_started` で使用されているリダイレクトを適切に処理しません。
Make sure you have and use a newer version which can be downloaded from the `cURL downloads page <https://curl.haxx.se/download.html>`__ ..	`cURLダウンロードページ <https://curl.haxx.se/download.html>`__ からダウンロード可能な、より新しいバージョンを使用していることを確認してください
note:: If you have questions not addressed by this documentation, or run into issues with any of the tutorials, please visit the :doc:`questions` page for some tips on where to find additional help.	.. note:: このドキュメントで説明されていない質問がある場合、またはいずれかのチュートリアルで問題が発生した場合は、:doc:`questions` ページにアクセスして、追加のヘルプを見つけるためのヒントを見つけてください。
**Audience**: Architects, Application and smart contract developers, administrators	**対象読者**: アーキテクト、アプリケーション・スマートコントラクト開発者、管理者
A ledger is a key concept in Hyperledger Fabric;	台帳は、Hyperledger Fabricにおける重要な概念の一つです。
it stores important factual information about business objects; both the current value of the attributes of the objects, and the history of transactions that resulted in these current values.	台帳は、ビジネスデータに関する重要な事実に関する情報、すなわち、データの属性の現在値およびその現在値に至るまでのトランザクションの履歴を格納します。
In this topic, we're going to cover:	このトピックでは、次の項目について扱います。
[What is a Ledger?](#what-is-a-ledger)	[台帳とは何か?](#what-is-a-ledger)
[Storing facts about business objects](#ledgers-facts-and-states)	[ビジネスデータに関する事実の格納](#ledgers-facts-and-states)
[A blockchain ledger](#the-ledger)	[ブロックチェーン台帳](#the-ledger)
[The world state](#world-state)	[ワールドステート](#world-state)
[The blockchain data structure](#blockchain)	[ブロックチェーンのデータ構造](#blockchain)
[How blocks are stored in a blockchain](#blocks)	[ブロックチェーンのブロックの格納方法](#blocks)
[Transactions](#transactions)	[トランザクション](#transactions)
[World state database options](#world-state-database-options)	[ワールドステートデータベースのオプション](#world-state-database-options)
[The Fabcar example ledger](#example-ledger-fabcar)	[台帳の例 Fabcar](#example-ledger-fabcar)
[Ledgers and namespaces](#namespaces)	[台帳とネームスペース](#namespaces)
[Ledgers and channels](#channels)	[台帳とチャネル](#channels)
A ledger contains the current state of a business as a journal of transactions.	台帳は、取引(transaction)の記録という形で、ビジネスの現在の状況を表しています。
The earliest European and Chinese ledgers date from almost 1000 years ago, and the Sumerians had [stone ledgers](http://www.sciencephoto.com/media/686227/view/accounting-ledger-sumerian-cuneiform) 4000 years ago --	ヨーロッパや中国での最古の台帳はおよそ1000年前にまでさかのぼり、シュメール人は4000年も前に[石の台帳](http://www.sciencephoto.com/media/686227/view/accounting-ledger-sumerian-cuneiform)を使っていました。
but let's start with a more up-to-date example!	しかし、今は最新の例から見ていくことにしましょう！
You're probably used to looking at your bank account.	皆さんは、たぶん銀行口座を見ることには慣れ親しんでいるでしょう。
What's most important to you is the available balance --	そこで一番重要なのは、残高です。
it's what you're able to spend at the current moment in time.	これは、今現在、どれだけ使うことができるかを表しているものです。
If you want to see how your balance was derived, then you can look through the transaction credits and debits that determined it.	もし、この残高がどのように得られたかを知りたければ、預け入れと引き出しをたどっていくことができます。
This is a real life example of a ledger -- a state (your bank balance), and a set of ordered transactions (credits and debits) that determine it.	これが台帳の実生活での例の一つで、ステート(銀行の残高)とそれに至る順序付けられたトランザクション(預け入れと引き出し)から成っています。
Hyperledger Fabric is motivated by these same two concerns -- to present the current value of a set of ledger states, and to capture the history of the transactions that determined these states.	Hyperledge Fabricは、この二つの同じ関心ごとに動機付けられています。台帳のステートの現在値を示すことと、そのステートに至るトランザクションの歴史をとらえることです。
A ledger doesn't literally store business objects -- instead it stores facts about those objects.	台帳は、実際にはビジネスデータそのものを格納するわけではなく、それらのデータに関する事実を格納しています。
When we say "we store a business object in a ledger" what we really mean is that we're recording the facts about the current state of an object, and the facts about the history of transactions that led to the current state.	「ビジネスデータを台帳に格納する」というときには、実際には、そのデータの現在の値に関する事実、そして、その現在のステートに至るトランザクションの履歴に関する事実を記録しているのです。
In an increasingly digital world, it can feel like we're looking at an object, rather than facts about an object.	デジタル化の進む世界においては、データに関する事実というよりも、データそのものを扱っているように感じるでしょう。
In the case of a digital object, it's likely that it lives in an external datastore; the facts we store in the ledger allow us to identify its location along with other key information about it.	デジタルデータの場合には、データそのものは外部のデータストアに格納されていることが多いでしょう。台帳に格納されている事実によって、その格納先を識別し、データに関する重要な情報を知ることができます。
While the facts about the current state of a business object may change, the history of facts about it is immutable, it can be added to, but it cannot be retrospectively changed.	ビジネスデータの現在値に関する事実は変化するかもしれませんが、その事実の歴史はイミュータブルです。追記することはできますが、過去にさかのぼって変更することはできません。
We're going to see how thinking of a blockchain as an immutable history of facts about business objects is a simple yet powerful way to understand it.	これから、ブロックチェーンを、ビジネスデータに関する事実のイミュータブルな履歴としてとらえることが、いかに単純ながら、理解するのに強力であるかを見ていくことになります。
Let's now take a closer look at the Hyperledger Fabric ledger structure!	では、Hyperledger Fabricの台帳の構造について、詳しくみていきましょう!
In Hyperledger Fabric, a ledger consists of two distinct, though related, parts -- a world state and a blockchain.	Hyperledger Fabricでは、台帳は、別々であると同時に関連する二つの部品からなっています。ワールドステートとブロックチェーンです。
Each of these represents a set of facts about a set of business objects.	それぞれがビジネスデータに関する事実を表現しています。
Firstly, there's a world state -- a database that holds current values of a set of ledger states.	まず、ワールドステートですが、これは台帳のステートの現在値を保持するデータベースです。
The world state makes it easy for a program to directly access the current value of a state rather than having to calculate it by traversing the entire transaction log.	ワールドステートによって、プログラムはステートの現在値に直接アクセスすることが容易になり、トランザクションのログ全体をたどって計算する必要がなくなります。
Ledger states are, by default, expressed as key-value pairs, and we'll see later how Hyperledger Fabric provides flexibility in this regard.	台帳のステートは、デフォルトでは、キーと値(キーバリュー)のペアとして表現されます。なお、後で述べますが、Hyperledger Fabricは、この点についても柔軟に変更することができます。
The world state can change frequently, as states can be created, updated and deleted.	ステートが新たに作成されたり更新されたり削除されることで、ワールドステートは頻繁に更新される可能性があります。
Secondly, there's a blockchain -- a transaction log that records all the changes that have resulted in the current the world state.	次に、ブロックチェーンですが、これは、現在のワールドステートに至るすべての変化を記録するトランザクションログです。
Transactions are collected inside blocks that are appended to the blockchain -- enabling you to understand the history of changes that have resulted in the current world state.	トランザクションはブロックに集められ、ブロックはブロックチェーンに追記されます。これにより、現在のワールドステートに至る変化の履歴を理解することができます。
The blockchain data structure is very different to the world state because once written, it cannot be modified; it is immutable.	ブロックチェーンのデータ構造は、ワールドステートとは大きく異なります。これは、ブロックチェーンは一度書かれたら変更することができない、すなわち、イミュータブルであるからです。
A Ledger L comprises blockchain B and world state W, where blockchain B determines world state W.	台帳LはブロックチェーンBとワールドステートWからなっており、ブロックチェーンBによりワールドステートWが決まります。
We can also say that world state W is derived from blockchain B.	ワールドステートWは、ブロックチェーンBから得られたものということもできます。
It's helpful to think of there being one logical ledger in a Hyperledger Fabric network.	Hyperledger Fabricネットワークにおいては、一つの論理的な台帳が存在すると考えるのがわかりやすいでしょう。
In reality, the network maintains multiple copies of a ledger -- which are kept consistent with every other copy through a process called consensus.	実際には、ネットワークは台帳の複数のコピーを維持しており、それらは合意形成と呼ばれるプロセスによって一貫性が保たれています。
The term Distributed Ledger Technology (DLT) is often associated with this kind of ledger -- one that is logically singular, but has many consistent copies distributed throughout a network.	分散台帳技術(DLT, Distributed Ledger Technology)という単語は、よくこのような台帳について使われています。すなわち、論理的には単一のものではあるが、一貫性ある複数のコピーがネットワークに分散している種類のものです。
Let's now examine the world state and blockchain data structures in more detail.	では、ワールドステートとブロックチェーンのデータ構造についてより詳細に見ていきましょう。
The world state holds the current value of the attributes of a business object as a unique ledger state.	ワールドステートは、あるビジネスデータの属性の現在値を、ユニークな台帳のステートとして保持しています。
That's useful because programs usually require the current value of an object; it would be cumbersome to traverse the entire blockchain to calculate an object's current value -- you just get it directly from the world state.	プログラムが通常必要とするのはデータの現在値であるため、これは有用です。データの現在値を得るために、ブロックチェーン全体をたどるのは煩雑でしょう。これならば、ワールドステートから直接値を取得するだけですみます。
A ledger world state containing two states.	台帳のワールドステートは、二つのステートを持っています。
The first state is: key=CAR1 and value=Audi. The second state has a more complex value: key=CAR2 and value={model:BMW, color=red, owner=Jane}.	一つは、キーがCAR1で値がAudi、もう一つはより複雑で、キーがCAR2で、値が{model:BMW, color=red, owner=Jane}です。
Both states are at version 0.	ステートのバージョンは、両方とも0です。
A ledger state records a set of facts about a particular business object.	台帳のステートは、あるビジネスデータに対するいくつかの事実を記録しています。
Our example shows ledger states for two cars, CAR1 and CAR2, each having a key and a value.	この例では、CAR1とCAR2という二つの車についての台帳ステートを示しており、それぞれのステートは、キーと値を持っています。
An application program can invoke a smart contract which uses simple ledger APIs to get, put and delete states.	アプリケーションプログラムは、スマートコントラクトを呼び出すことができ、スマートコントラクトは、ステートを読み(get)、書き(put)、削除する(delete)、単純な台帳APIを使用します。
Notice how a state value can be simple (Audi...) or compound (type:BMW...).	ステートの値は、単純な値(Audi)でも、複合値(type:BMW...)でもよいことに注意してください。
The world state is often queried to retrieve objects with certain attributes, for example to find all red BMWs.	ワールドステートに対しては、例えば、すべての赤のBMWといった、特定の属性をもつデータを取得するクエリがよく行われます。
The world state is implemented as a database.	ワールドステートは、データベースとして実装されています。
This makes a lot of sense because a database provides a rich set of operators for the efficient storage and retrieval of states.	これは、非常に理にかなったもので、データベースは、効率的な保存やステートの取得のための豊富な機能を提供しているからです。
We'll see later that Hyperledger Fabric can be configured to use different world state databases to address the needs of different types of state values and the access patterns required by applications, for example in complex queries.	後述しますが、Hyperledger Fabricは異なるワールドステートデータベースを使うように設定することができます。これは、例えば、複雑なクエリというような、アプリケーションが必要とするアクセスパターンや、ステートの値の種類の違いに対応するためです。
Applications submit transactions which capture changes to the world state, and these transactions end up being committed to the ledger blockchain.	アプリケーションは、ワールドステートに対する変更を行うトランザクションを発行し、このトランザクションが台帳のブロックチェーンに最終的にコミットされます。
Applications are insulated from the details of this [consensus](../txflow.html) mechanism by the Hyperledger Fabric SDK; they merely invoke a smart contract, and are notified when the transaction has been included in the blockchain (whether valid or invalid).	Hyperledger Fabric SDKは、アプリケーションを、ここにあるような[合意形成](../txflow.html)の仕組みの詳細から隔離しており、アプリケーションは、ただスマートコントラクトを実行し、ブロックチェーンに(それが正当であるかどうかにかかわらず)トランザクションが加わったときに通知を受け取ります。
The key design point is that only transactions that are signed by the required set of endorsing organizations will result in an update to the world state.	この設計の重要なポイントは、エンドースを行う組織の必須とされる集合によって署名されたトランザクションだけが、ワールドステートを更新することになるということです。
If a transaction is not signed by sufficient endorsers, it will not result in a change of world state.	もしトランザクションが十分なエンドーサーから署名されていなかった場合には、ワールドステートの変更は起こりません。
You can read more about how applications use [smart contracts](../smartcontract/smartcontract.html), and how to [develop applications](../developapps/developing_applications.html).	アプリケーションがどのように[スマートコントラクト](../smartcontract/smartcontract.html)を使うか、どのように[アプリケーションを開発するか](../developapps/developing_applications.html)の詳細はそれぞれのトピックを参照してください。
You'll also notice that a state has a version number, and in the diagram above, states CAR1 and CAR2 are at their starting versions, 0.	また、ステートにはバージョン番号があり、上の図では、ステートCAR1とCAR2は、最初のバージョンの0であることに気づくかもしれません。
The version number is for internal use by Hyperledger Fabric, and is incremented every time the state changes.	バージョン番号は、Hyperledger Fabricが内部的に使用するもので、ステートが変更されるたびにインクリメントされるものです。
The version is checked whenever the state is updated to make sure the current states matches the version at the time of endorsement.	バージョン番号は、ステートがアップデートされるたびにチェックされ、エンドースメントの時点のバージョンと一致することを確認するために使われます。
This ensures that the world state is changing as expected; that there has not been a concurrent update.	これによって、ワールドステートが予期した通りに変更されることを保証され、同時に更新されなかったことを保証しています。
Finally, when a ledger is first created, the world state is empty.	最後に、台帳が最初に作られる際には、ワールドステートは空の状態です。
Because any transaction which represents a valid change to world state is recorded on the blockchain, it means that the world state can be re-generated from the blockchain at any time.	ワールドステートに対する正当な更新を表すトランザクションはすべてブロックチェーンに記録されているため、どの時点でも、ワールドステートはブロックチェーンから再生成することが可能です。
This can be very convenient -- for example, the world state is automatically generated when a peer is created.	例えば、ピアが作られた際にワールドステートを自動的に生成するときなどに、これは非常に便利です。
Moreover, if a peer fails abnormally, the world state can be regenerated on peer restart, before transactions are accepted.	さらに、もしピアが異常終了した際にも、ピアが再起動した際にワールドステートは再生成することができ、そののちトランザクションを受け入れることになります。
Let's now turn our attention from the world state to the blockchain.	では、ワールドステートからブロックチェーンに注意を移しましょう。
Whereas the world state contains a set of facts relating to the current state of a set of business objects, the blockchain is an historical record of the facts about how these objects arrived at their current states.	ワールドステートは、ビジネスデータの現在のステートに関する事実を保持しているのに対し、ブロックチェーンは、どのようにそのデータが現在のステートに至ったかに関する事実の履歴の記録です。
The blockchain has recorded every previous version of each ledger state and how it has been changed.	ブロックチェーンは、台帳の各ステートの直前のバージョンと、それがどのように変更されたかを記録しています。
The blockchain is structured as sequential log of interlinked blocks, where each block contains a sequence of transactions, each transaction representing a query or update to the world state.	ブロックチェーンの構造は、互いにリンクされたブロックのシーケンシャルなログで、各ブロックはトランザクションのシーケンスを含み、各トランザクションは、ワールドステートへのクエリか更新を表しています。
The exact mechanism by which transactions are ordered is discussed [elsewhere](../peers/peers.html#peers-and-orderers); what's important is that block sequencing, as well as transaction sequencing within blocks, is established when blocks are first created by a Hyperledger Fabric component called the ordering service.	トランザクションを順序付ける仕組みは、正確には[別のトピック](../peers/peers.html#peers-and-orderers)で議論されていますが、重要なのは、ブロックのシーケンス、そしてブロック内のトランザクションのシーケンスは、ブロックがオーダリングサービスと呼ばれるHyperledger Fabricのコンポーネントによって最初に作られたときに、確立されているということです。
Each block's header includes a hash of the block's transactions, as well a hash of the prior block's header.	各ブロックのヘッダは、ブロックのトランザクションのハッシュ値と、直前のブロックのヘッダーのハッシュ値を含んでいます。
In this way, all transactions on the ledger are sequenced and cryptographically linked together.	このようにして、台帳上のすべてのトランザクションは、シーケンスとなっており、互いに暗号的にリンクしています。
This hashing and linking makes the ledger data very secure. Even if one node hosting the ledger was tampered with, it would not be able to convince all the other nodes that it has the 'correct' blockchain because the ledger is distributed throughout a network of independent nodes.	このハッシュとリンクによって、台帳のデータは非常にセキュアなものとなっています、もし、台帳を持っている一つのノードが改ざんされたとしても、他のすべてのノードに対して、それが「正しい」ブロックチェーンであると納得させることはできないでしょう。台帳は、独立したノードからなるネットワークに分散されているためです。
The blockchain is always implemented as a file, in contrast to the world state, which uses a database.	データベースを使用するワールドステートと対照的に、ブロックチェーンの実装は常にファイルです。
This is a sensible design choice as the blockchain data structure is heavily biased towards a very small set of simple operations.	これは、非常に限られた種類の操作に対してよく適したデータ構造なので、道理にかなったデザインチョイスです。
Appending to the end of the blockchain is the primary operation, and query is currently a relatively infrequent operation.	主な操作はブロックチェーンの最後に追記することであり、クエリは今のところ比較的頻度の高くない操作です。
Let's have a look at the structure of a blockchain in a little more detail.	ブロックチェーンの構造について、もう少し詳細に見ていきましょう。
A blockchain B containing blocks B0, B1, B2, B3.	ブロックチェーンBは、B0, B1, B2, B3というブロックを含んでいます。
B0 is the first block in the blockchain, the genesis block.	B0はブロックチェーンの最初のブロックであり、ジェネシスブロックです。
In the above diagram, we can see that block B2 has a block data D2 which contains all its transactions: T5, T6, T7.	上の図からは、ブロックB2がブロックデータD2をもち、D2にはT5,T6,T7というそのブロックのトランザクションが含まれていることがわかります。
Most importantly, B2 has a block header H2, which contains a cryptographic hash of all the transactions in D2 as well as a hash of H1.	より重要なのは、B2は、ブロックヘッダーH2をもち、そこにはD2のすべてのトランザクションと、H1の暗号的なハッシュ値を含んでいることです。
In this way, blocks are inextricably and immutably linked to each other, which the term blockchain so neatly captures!	このようにして、ブロックは互いに密接に、そしてイミュータブルにリンクしており、まさにブロックチェーンという単語がきれいに表す通りです!
Finally, as you can see in the diagram, the first block in the blockchain is called the genesis block.	最後に、図でもわかるように、ブロックチェーンの最初のブロックは、ジェネシスブロックと呼ばれています。
It's the starting point for the ledger, though it does not contain any user transactions.	これは台帳の開始点ですが、ユーザーのトランザクションを何も含んでいません。
Instead, it contains a configuration transaction containing the initial state of the network channel (not shown).	代わりに、ネットワークチャネル(図示されていません)の初期状態を含むコンフィグトランザクションを含んでいます。
We discuss the genesis block in more detail when we discuss the blockchain network and [channels](../channels.html) in the documentation.	ジェネシスブロックの詳細については、ドキュメントのブロックチェーンネットワークと[チャネル](../channels.html)についての議論で扱います。
Let's have a closer look at the structure of a block.	ブロックの構造について、より細かく見ていきましょう。
It consists of three sections	ブロックは、3つのセクションからなります。
Block Header	ブロックヘッダー
This section comprises three fields, written when a block is created.	このセクションは、3つのフィールドからなり、ブロックが作成された時点で書かれます。
Block number: An integer starting at 0 (the genesis block), and increased by 1 for every new block appended to the blockchain.	ブロック番号: 0(ジェネシスブロック)からはじまる整数で、ブロックチェーンに新しいブロックが追記されるたびに1ずつ増加します。
Current Block Hash: The hash of all the transactions contained in the current block.	現在のブロックのハッシュ: 現在のブロックのすべてのトランザクションに対するハッシュ値です。
Previous Block Header Hash: The hash from the previous block header.	直前のブロックのヘッダーのハッシュ: 直前のブロックのヘッダーのハッシュ値です。
These fields are internally derived by cryptographically hashing the block data.	これらのフィールドは、内部的には、ブロックデータを暗号的にハッシュ化することで得られています。
They ensure that each and every block is inextricably linked to its neighbour, leading to an immutable ledger.	各ブロックが隣接するブロックと密接にリンクされ、これによってイミュータブルな台帳となることを保証しています。
Block header details.	ブロックヘッダーの詳細。
The header H2 of block B2 consists of block number 2, the hash CH2 of the current block data D2, and the hash of the prior block header H1.	ブロックB2のヘッダーH2は、ブロック番号2、現在のブロックデータD2のハッシュ値CH2、そして、直前のブロックヘッダーH1のハッシュ値を含んでいます。
Block Data	ブロックデータ
This section contains a list of transactions arranged in order.	このセクションは、順序通りに並んだトランザクションのリストを含んでいます。
It is written when the block is created by the ordering service.	オーダリングサービスによってブロックが作成された時点で書かれます。
These transactions have a rich but straightforward structure, which we describe [later](#Transactions) in this topic.	トランザクションは、豊富ですが簡単な構造を持っており、このトピックで[後ほど](#Transactions)述べます。
Block Metadata	ブロックメタデータ
This section contains the certificate and signature of the block creator which is used to verify the block by network nodes.	このセクションは、ブロックの作成者の証明書と署名を含んでおり、ネットワークノードがブロックを検証するときに使用します。
Subsequently, the block committer adds a valid/invalid indicator for every transaction into a bitmap that also resides in the block metadata, as well as a hash of the cumulative state updates up until and including that block, in order to detect a state fork.	続いて、ブロックのコミッターは、ブロックメタデータに各トランザクションが正当であるか(valid)・正当でないか(invalid)を示したビットマップを加えます。また、ステートのフォークを検知するために、そのブロックまでとそのブロックによる累積のステートの更新のハッシュ値も追加します。
Unlike the block data and header fields, this section is not an input to the block hash computation.	ブロックデータとヘッダーのフィールドと異なり、このセクションは、ブロックのハッシュ値計算の入力には含まれません。
As we've seen, a transaction captures changes to the world state.	ここまで見てきたように、トランザクションはワールドステートへの更新を表すものでした。
Let's have a look at the detailed blockdata structure which contains the transactions in a block.	ブロックの中で、トランザクションを含んでいるブロックデータの詳細な構造を見ていきましょう。
Transaction details.	トランザクションの詳細。
Transaction T4 in blockdata D1 of block B1 consists of transaction header, H4, a transaction signature, S4, a transaction proposal P4, a transaction response, R4, and a list of endorsements, E4.	ブロックB1のブロックデータD1内のトランザクションT4は、トランザクションヘッダーH4、トランザクションの署名S4、トランザクション提案P4、トランザクション応答R4、エンドースメントのリストE4からなっています。
In the above example, we can see the following fields:	上の例から、次のようなフィールドがあることがわかります。
Header	ヘッダー
This section, illustrated by H4, captures some essential metadata about the transaction -- for example, the name of the relevant chaincode, and its version.	H4として図示されているこのセクションは、トランザクションに関する重要なメタデータを含んでいます。たとえば、関係するチェーンコードの名前とバージョンなどです。
Signature	署名
This section, illustrated by S4, contains a cryptographic signature, created by the client application.	S4として図示されているこのセクションは、クライアントアプリケーションによって作成された暗号的署名を含んでいます。
This field is used to check that the transaction details have not been tampered with, as it requires the application's private key to generate it.	このフィールドは、生成にアプリケーションの秘密鍵が必要なため、トランザクションの詳細が改ざんされていないことを確認するために使われます。
Proposal	提案
This field, illustrated by P4, encodes the input parameters supplied by an application to the smart contract which creates the proposed ledger update.	P4として図示されているこのセクションは、アプリケーションから、台帳の更新を作成するスマートコントラクトへ渡される入力パラメータをエンコードしています。
When the smart contract runs, this proposal provides a set of input parameters, which, in combination with the current world state, determines the new world state.	スマートコントラクトが実行されるときには、この提案は入力値のセットを提供し、現在のワールドステートと合わせて、新しいワールドステートを決定します。
Response	応答
This section, illustrated by R4, captures the before and after values of the world state, as a Read Write set (RW-set).	R4として図示されているこのセクションは、ワールドステートの前と後の値を読み書きセット(RW-set)の形で含んでいます。
It's the output of a smart contract, and if the transaction is successfully validated, it will be applied to the ledger to update the world state.	これは、スマートコントラクトの出力であり、トランザクションの検証が成功したときに、台帳に適用されワールドステートが更新されます。
Endorsements	エンドースメント
As shown in E4, this is a list of signed transaction responses from each required organization sufficient to satisfy the endorsement policy.	E4として図示されているこれは、エンドースメントポリシーを満たすのに十分な、各組織からの署名付きのトランザクション応答のリストです。
You'll notice that, whereas only one transaction response is included in the transaction, there are multiple endorsements.	トランザクションには、トランザクション応答は一つしかないのに、エンドースメントが複数あることに気づくと思います。
That's because each endorsement effectively encodes its organization's particular transaction response -- meaning that there's no need to include any transaction response that doesn't match sufficient endorsements as it will be rejected as invalid, and not update the world state.	これは、各エンドースメントが各組織のトランザクション応答を実際にエンコードするものとなっているからです。すなわち、十分なエンドースメントと一致しないトランザクション応答を含める必要がないことを意味しています。そのような応答は、正当でないとして拒否され、ワールドステートの更新が行われないためです。
That concludes the major fields of the transaction -- there are others, but these are the essential ones that you need to understand to have a solid understanding of the ledger data structure.	これでトランザクションの主要なフィールドはおわりです。他にもフィールドはありますが、これらが、台帳のデータ構造への確かな理解を得るのに欠かせないフィールドでした。
The world state is physically implemented as a database, to provide simple and efficient storage and retrieval of ledger states.	ワールドステートは、台帳のステートの単純かつ効率的な保存と取得が行えるように、物理的にはデータベースとして実装されています。
As we've seen, ledger states can have simple or compound values, and to accommodate this, the world state database implementation can vary, allowing these values to be efficiently implemented.	ここまで見てきたように、台帳のステートは、単純な値も複合値もとることができ、これを実現するために、ワールドステートのデータベースの実装を変えることができます。そしてこれにより、そのような値を効率的に実装することができます。
Options for the world state database currently include LevelDB and CouchDB.	ワールドステートのデータベースのオプションには、現在、LevelDBとCouchDBがあります。
LevelDB is the default and is particularly appropriate when ledger states are simple key-value pairs.	LevelDBはデフォルトで、台帳のステートが単純なキー・値のペアであるときに特に適しています。
A LevelDB database is co-located with the peer node -- it is embedded within the same operating system process.	LevelDBのデータベースは、ピアノードと同じ場所に置かれており、同じOSのプロセス内に組み込まれています。
CouchDB is a particularly appropriate choice when ledger states are structured as JSON documents because CouchDB supports the rich queries and update of richer data types often found in business transactions.	CouchDBは、台帳のステートの構造がJSONドキュメントであるときに特に適しています。CouchDBは、ビジネストランザクションによく存在する、リッチなクエリや、リッチなデータ型の更新をサポートしているためです。
Implementation-wise, CouchDB runs in a separate operating system process, but there is still a 1:1 relation between a peer node and a CouchDB instance.	実装の観点からいいますと、CouchDBは別のOSのプロセスとして動作しますが、ピアノードとCouchDBのインスタンスには1:1の関係が依然あります。
All of this is invisible to a smart contract.	これらはすべて、スマートコントラクトからは見えません。
See [CouchDB as the StateDatabase](../couchdb_as_state_database.html) for more information on CouchDB.	CouchDBについての詳細は、[CouchDB as the State Database](../couchdb_as_state_database.html)を参照してください。
In LevelDB and CouchDB, we see an important aspect of Hyperledger Fabric -- it is pluggable.	LevelDBとCouchDBからは、Hyperledger Fabricの重要な側面を見ることができます。すなわち、プラグ可能であることです。
The world state database could be a relational data store, or a graph store, or a temporal database.	ワールドステートデータベースは、リレーショナルなデータストアや、グラフストア、あるいは一時的なデータベースであってもかまいません。
This provides great flexibility in the types of ledger states that can be efficiently accessed, allowing Hyperledger Fabric to address many different types of problems.	これによって、効率的にアクセスできる台帳のステートの種類に大きな柔軟性をもたらし、Hyperledger Fabricが多くの異なる種類の問題に対応することができます。
As we end this topic on the ledger, let's have a look at a sample ledger.	このトピックの終わりにあたって、とあるサンプルの台帳を見てみましょう。
If you've run the [fabcar sample application](../write_first_app.html), then you've created this ledger.	もし、[fabcar サンプルアプリケーション](../write_first_app.html)を実行したことがあるならば、この台帳を作ったことがあることになります。
The fabcar sample app creates a set of 10 cars each with a unique identity; a different color, make, model and owner.	fabcarのサンプルアプリケーションは、それぞれ異なる識別子、色、メーカー、モデル、所有者をもつ10台の車を作成します。
Here's what the ledger looks like after the first four cars have been created.	これが、最初の4つの車が作られた後に台帳がどうなっているかです。
The ledger, L, comprises a world state, W and a blockchain, B.	台帳Lは、ワールドステートWとブロックチェーンBから構成されています。
W contains four states with keys: CAR0, CAR1, CAR2 and CAR3.	Wは、CAR0、CAR1、CAR2、CAR3というキーの4つのステートを含んでいます。
B contains two blocks, 0 and 1. Block 1 contains four transactions: T1, T2, T3, T4.	Bは、0と1という2つのブロックを含んでおり、ブロック1は、T1、T2、T3、T4という4つのトランザクションを含んでいます。
We can see that the world state contains states that correspond to CAR0, CAR1, CAR2 and CAR3.	ワールドステートには、CAR0、CAR1、CAR2、CAR3に対応するステートが存在していることがわかります。
CAR0 has a value which indicates that it is a blue Toyota Prius, currently owned by Tomoko, and we can see similar states and values for the other cars.	CAR0は、青い(blue)トヨタ(Toyota)のプリウス(Prius)で、現在トモコ(Tomoko)によって所有されていることを表す値を持っており、他の車についても似たようなステートと値を見ることができます。
Moreover, we can see that all car states are at version number 0, indicating that this is their starting version number -- they have not been updated since they were created.	さらに、すべての車のステートは、バージョンが、最初のバージョン番号を意味する0であり、これらのステートが作成されてから一度も更新されていないことがわかります。
We can also see that the blockchain contains two blocks.	また、ブロックチェーンが2つのブロックを含んでいることもわかります。
Block 0 is the genesis block, though it does not contain any transactions that relate to cars.	ブロック0はジェネシスブロックですが、車に関係するトランザクションは含んでいません。
Block 1 however, contains transactions T1, T2, T3, T4 and these correspond to transactions that created the initial states for CAR0 to CAR3 in the world state.	しかし、ブロック1は、T1、T2、T3、T4というトランザクションを含んでおり、これらがワールドステートのCAR0からCAR3までの初期ステートを作成したトランザクションに対応するものです。
We can see that block 1 is linked to block 0.	ブロック1がブロック0にリンクされていることがわかります。
We have not shown the other fields in the blocks or transactions, specifically headers and hashes.	ブロックやトランザクションの他のフィールド、具体的にはヘッダーやハッシュについては示してきませんでした。
If you're interested in the precise details of these, you will find a dedicated reference topic elsewhere in the documentation.	もしこれらについて正確な詳細について興味があるときは、ドキュメントの他のそれぞれのリファレンストピックで見ることができます。
It gives you a fully worked example of an entire block with its transactions in glorious detail --	そのトピックは、ブロック全体とそのトランザクションの素晴らしい詳細について、ステップ・バイ・ステップで説明しています。
but for now, you have achieved a solid conceptual understanding of a Hyperledger Fabric ledger.	しかし、今のところは、Hyperledger Fabricの台帳についての、確かな概念的な理解を得ることができたでしょう。
Well done!	よくできました！
Even though we have presented the ledger as though it were a single world state and single blockchain, that's a little bit of an over-simplification.	台帳を、単一のワールドステート、単一のブロックチェーンであるかのように説明してきましたが、少し単純化しすぎたところがあります。
In reality, each chaincode has its own world state that is separate from all other chaincodes.	実際には、各チェーンコードは、他のチェーンコードとは切り離された自分のワールドステートをもっています。
World states are in a namespace so that only smart contracts within the same chaincode can access a given namespace.	ワールドステートは、ネームスペースの中にあり、同じチェーンコードのスマートコントラクトのみがネームスペースにアクセスできます。
A blockchain is not namespaced.	ブロックチェーンはネームスペースに分かれていません。
It contains transactions from many different smart contract namespaces.	多くの異なるスマートコントラクトのネームスペースからのトランザクションを含んでいます。
You can read more about chaincode namespaces in this [topic](../developapps/chaincodenamespace.html).	チェーンコードのネームスペースについては、この[トピック](../developapps/chaincodenamespace.html)を参照してください。
Let's now look at how the concept of a namespace is applied within a Hyperledger Fabric channel.	では、ネームスペースの概念が、Hyperledger Fabricのチャネルの中でどのように適用されているかを見てみましょう。
In Hyperledger Fabric, each [channel](../channels.html) has a completely separate ledger.	Hyperledger Fabricでは、各[チャネル](../channels.html)は、完全に分かれた台帳を持っています。
This means a completely separate blockchain, and completely separate world states, including namespaces.	これはすなわち、完全に分かれたブロックチェーン、ネームスペースも含めて完全に分かれたワールドステートを意味します。
It is possible for applications and smart contracts to communicate between channels so that ledger information can be accessed between them.	アプリケーションやスマートコントラクトが、チャネル間で台帳の情報にアクセスするために、チャネル間で通信することは可能です。
You can read more about how ledgers work with channels in this [topic](../developapps/chaincodenamespace.html#channels).	チャネルと台帳がどう動くかについては、この[トピック](../developapps/chaincodenamespace.html#channels)を参照してください。
See the [Transaction Flow](../txflow.html), [Read-Write set semantics](../readwrite.html) and [CouchDB as the StateDatabase](../couchdb_as_state_database.html) topics for a deeper dive on transaction flow, concurrency control, and the world state database.	トランザクションフロー、同時実行制御、ワールドステートデータベースのより詳細については、[Transaction Flow](../txflow.html)、[Read-Write set semantics](../readwrite.html)、[CouchDB as the StateDatabase](../couchdb_as_state_database.html)のトピックをそれぞれ参照してください。
While we work on developing real installers for the Hyperledger Fabric binaries, we provide a script that will download and install samples and binaries to your system.	我々はHyperledger Fabricバイナリの実際のインストーラの開発に取り組んでいますが、サンプルとバイナリをダウンロードしてあなたのシステムにインストールするスクリプトを提供します。
We think that you'll find the sample applications installed useful to learn more about the capabilities and operations of Hyperledger Fabric.	インストールされるサンプルアプリケーションは、Hyperledger Fabricの能力と運用の詳細を学習するのに役立つと思います。
..note:: If you are running on Windows you will want to make use of the Docker Quickstart Terminal for the upcoming terminal commands.	.. note::Windowsで実行している場合には、以降のターミナルコマンドのために Docker Quickstart Terminalを使うことをお勧めします。
Please visit the :doc:`prereqs` if you haven't previously installed it.	まだインストールしていない場合には、 :doc:`prereqs` にアクセスしてください。
If you are using Docker Toolbox or macOS, you will need to use a location under ``/Users`` (macOS) when installing and running the samples.	Docker Toolbox または macOS を使用している場合には、サンプルをインストールして実行するときに、 ``/Users`` (macOS) 以下の場所を使用する必要があります。
If you are using Docker for Mac, you will need to use a location under ``/Users``, ``/Volumes``, ``/private``, or ``/tmp``.	Docker for Mac を使用している場合には、 ``/Users`` 、 ``/Volumes`` 、 ``/private`` または ``/tmp``以下の場所を使用する必要があります。
To use a different location, please consult the Docker documentation for `file sharing <https://docs.docker.com/docker-for-mac/#file-sharing>`__.	その他の場所を使用したい場合には、Dockerドキュメントの`file sharing <https://docs.docker.com/docker-for-mac/#file-sharing>`__ を参照してください。
If you are using Docker for Windows, please consult the Docker documentation for `shared drives <https://docs.docker.com/docker-for-windows/#shared-drives>`__ and use a location under one of the shared drives.	Docker for Windows を利用している場合には、Dockerドキュメントの`shared drives <https://docs.docker.com/docker-for-windows/#shared-drives>`__ を参照して、共有ドライブの1つの中の場所を使用してください。
Determine a location on your machine where you want to place the `fabric-samples` repository and enter that directory in a terminal window.	マシン上で `fabric-samples` リポジトリを配置したい場所を決定し、ターミナルウィンドウにそのディレクトリを入力します。
The command that follows will perform the following steps:	以降のコマンドは、次の手順を実行します:
If needed, clone the `hyperledger/fabric-samples <https://github.com/hyperledger/fabric-samples>`_ repository	必要に応じて `hyperledger/fabric-samples <https://github.com/hyperledger/fabric-samples>`_ リポジトリをクローン
Checkout the appropriate version tag	適切なバージョンタグをチェックアウト
Install the Hyperledger Fabric platform-specific binaries and config files for the version specified into the /bin and /config directories of fabric-samples	指定されたバージョンのHyperledger Fabricのプラットフォーム固有のバイナリと設定ファイルをfabric-samplesの/binおよび/configディレクトリにインストール
Download the Hyperledger Fabric docker images for the version specified	指定されたバージョンのHyperledger FabricのDockerイメージをダウンロード
Once you are ready, and in the directory into which you will install the Fabric Samples and binaries, go ahead and execute the command to pull down the binaries and images.	準備ができたら、Fabricのサンプルとバイナリをインストールしたいディレクトリで、以下に示すバイナリとイメージをプルダウンするコマンドを実行してください。
..note:: If you want the latest production release, omit all version identifiers.	.. note:: 最新のプロダクションリリースが必要な場合は、すべてのバージョン識別子を省略してください。
..note:: If you want a specific release, pass a version identifier for Fabric and Fabric-CA docker images.	.. note:: 特定のリリースが必要な場合は、FabricとFabric CAの各Dockerイメージのバージョン識別子を渡します。
The command below demonstrates how to download the latest production releases - Fabric v2.2.0 and Fabric CA v1.4.7	以下のコマンドは、最新のプロダクションリリースFabric v2.2.0とFabric CA v1.4.7をダウンロードする方法を示しています。
curl -sSL https://bit.ly/2ysbOFE | bash -s -- <fabric_version> <fabric-ca_version>	curl -sSL https://bit.ly/2ysbOFE | bash -s -- <Fabricのバージョン> <Fabric CAのバージョン>
..note:: If you get an error running the above curl command, you may have too old a version of curl that does not handle redirects or an unsupported environment.	.. note:: 上記のcurlコマンドを実行してエラーが発生した場合、curlのバージョンが古すぎてリダイレクトを処理できないか、あるいはサポートされていない環境になっている可能性があります。
Please visit the :doc:`prereqs` page for additional information on where to find the latest version of curl and get the right environment.	curlの最新バージョンを見つけて適切な環境を取得するための情報の詳細は :doc:`prereqs` ページを参照してください。
Alternately, you can substitute the un-shortened URL: https://raw.githubusercontent.com/hyperledger/fabric/{BRANCH}/scripts/bootstrap.sh The command above downloads and executes a bash script that will download and extract all of the platform-specific binaries you will need to set up your network and place them into the cloned repo you created above.	あるいは、短縮されていないURLを代用することもできます(https://raw.githubusercontent.com/hyperledger/fabric/{BRANCH}/scripts/bootstrap.sh)。
The command above downloads and executes a bash script that will download and extract all of the platform-specific binaries you will need to set up your network and place them into the cloned repo you created above. It retrieves the following platform-specific binaries:	上記のコマンドは、ネットワークをセットアップするために必要なプラットフォーム固有のすべてのバイナリををダウンロードおよび解凍してクローンリポジトリ以下に配置するBashスクリプトをダウンロードして実行します。
It retrieves the following platform-specific binaries: and places them in the ``bin`` sub-directory of the current working directory.	スクリプトは以下のプラットフォーム固有のバイナリを取得します:そしてこれらを現在の作業ディレクトリ以下の ``bin`` サブディレクトリに配置します。
You may want to add that to your PATH environment variable so that these can be picked up without fully qualifying the path to each binary.	上記のパスをPATH環境変数に追加すると、各バイナリへのパスを完全修飾せずにこれらを使用することができます。
e.g.:	例えば、以下の通りです。:
export PATH=<path to download location>/bin:$PATH	export PATH=<ダウンロード場所へのパス>/bin:$PATH
Finally, the script will download the Hyperledger Fabric docker images from `Docker Hub <https://hub.docker.com/u/hyperledger/>`__ into your local Docker registry and tag them as 'latest'.	最後に、スクリプトはHyperledger FabricのDockerイメージを`Docker Hub <https://hub.docker.com/u/hyperledger/>`__ からローカルのDockerレジストリにダウンロードし、それらに「latest」のタグを付けます。
The script lists out the Docker images installed upon conclusion.	スクリプトは、終了時にインストールされたDockerイメージの一覧を表示します。
Look at the names for each image;	各イメージの名前を見てください。
these are the components that will ultimately comprise our Hyperledger Fabric network.	これらは、つまるところ、Hyperledger Fabricネットワークを構成するコンポーネントです。
You will also notice that you have two instances of the same image ID - one tagged as "amd64-1.x.x" and one tagged as "latest".	また、同じイメージIDのインスタンスが2つあることに気付くでしょう。1つは「amd64-1.x.x」のタグが付けられ、もう1つは「latest」のタグが付けられていると思います。
Prior to 1.2.0, the image being downloaded was determined by ``uname -m`` and showed as "x86_64-1.x.x".	1.2.0より前のバージョンでは、ダウンロードされるイメージは ``uname -m`` によって決定され、「x86_64-1.x.x」と表示されていました。
..note:: On different architectures, the x86_64/amd64 would be replaced with the string identifying your architecture.	.. note:: 別のアーキテクチャでは、x86_64/amd64 はアーキテクチャを識別する文字列に置き換えられます。
..note:: If you have questions not addressed by this documentation, or run into issues with any of the tutorials, please visit the :doc:`questions` page for some tips on where to find additional help.	.. note:: このドキュメントで扱われていない質問がある場合や、チュートリアルで問題が発生した場合は、追加のヘルプを見つけるためのヒントを得るために :doc:`questions` のページをご覧ください。
This topic covers how to develop a client application and smart contract to solve a business problem using Hyperledger Fabric.	このトピックでは、ビジネス上の問題をHyperledger Fabricを用いて解決するために、どのようにクライアントアプリケーションとスマートコントラクトを作成するのかを扱います。
In a real world Commercial Paper scenario, involving multiple organizations, you'll learn about all the concepts and tasks required to accomplish this goal.	現実世界のコマーシャルペーパー(訳注:短期の無担保手形)のシナリオでは、複数の組織が関係し、この目標を実現するために必要な概念とタスクのすべてを学ぶことになるでしょう。
We assume that the blockchain network is already available.	ここでは、ブロックチェーンネットワークはすでに利用可能であると仮定します。
The topic is designed for multiple audiences:	このトピックは、下記の複数の対象読者に向けたものです。
Solution and application architect	ソリューションおよびアプリケーション・アーキテクト
Client application developer	クライアントアプリケーション開発者
Smart contract developer	スマートコントラクト開発者
Business professional	ビジネスの専門家
You can choose to read the topic in order, or you can select individual sections as appropriate.	このトピックを順番に読んでいくのもよいですし、適切な各セクションを選んで読んでいくのもよいでしょう。
Individual topic sections are marked according to reader relevance, so whether you're looking for business or technical information it'll be clear when a topic is for you.	トピックの各セクションは、どのような読者に関係あるかを記していますので、ビジネス的な情報を探しているにしろ技術的な情報を探しているにしろ、どれが自分向けのトピックであるかは明らかでしょう。
The topic follows a typical software development lifecycle.	このトピックは、典型的なソフトウェア開発のライフサイクルに従っています。
It starts with business requirements, and then covers all the major technical activities required to develop an application and smart contract to meet these requirements.	最初にビジネス要件から始まり、これらの要件を満たすアプリケーションとスマートコントラクトを開発するのに必要な、技術的な取り組みの主なものをすべて含みます。
If you'd prefer, you can try out the commercial paper scenario immediately, following an abbreviated explanation, by running the commercial paper `tutorial <../tutorial/commercial_paper.html>`_.	もしお望みならば、概要説明の後に、コマーシャルペーパーの `チュートリアル <../tutorial/commercial_paper.html>`_ を動かして、すぐにコマーシャルペーパーのシナリオを試すことができます。
You can return to this topic when you need fuller explanations of the concepts introduced in the tutorial.	チュートリアルで登場した概念について、より詳細な説明が必要であれば、このトピックに戻ってくることもできます。
**Audience**: Architects, Application and smart contract developers, Business professionals	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者、ビジネス専門家
In this topic, we're going to describe a business scenario involving six organizations who use PaperNet, a commercial paper network built on Hyperledger Fabric, to issue, buy and redeem commercial paper.	このトピックでは、6つの組織が関係するビジネスシナリオについて説明をします。これらの組織は、Hyperledger Fabricで作られたコマーシャルペーパーのネットワークであるPaperNetを用い、コマーシャルペーパーの発行、購入、現金化を行います。
We're going to use the scenario to outline requirements for the development of commercial paper applications and smart contracts used by the participant organizations.	ここでは、このシナリオを用いて、各組織が用いるコマーシャルペーパーのアプリケーションとスマートコントラクトに対する要件の概要を説明していきます。
PaperNet is a commercial paper network that allows suitably authorized participants to issue, trade, redeem and rate commercial paper.	PaperNetは、コマーシャルペーパーのネットワークで、適切に認められた参加者が、コマーシャルペーパーの発行、取引、現金化、評価をここで行うことができます。
The PaperNet commercial paper network.	コマーシャルペーパー・ネットワーク PaperNet。
Six organizations currently use PaperNet network to issue, buy, sell, redeem and rate commercial paper.	現在、6つの組織が、コマーシャルペーパーの発行(Issue)、購入(Buy)、売却(Sell)、現金化(Redeem)、評価(Rate)に、PaperNetネットワークを使っています。
MagentoCorp issues and redeems commercial paper.	MagnetoCorpがコマーシャルペーパーを発行し現金化を行います。
DigiBank, BigFund, BrokerHouse and HedgeMatic all trade commercial paper with each other.	DigiBank、BigFund、BrokerHouse、HedgeMaticはすべて互いにコマーシャルペーパーの取引を行います。
RateM provides various measures of risk for commercial paper.	RateMは、コマーシャルペーパーに対する様々なリスク計算を提供します。
Let's see how MagnetoCorp uses PaperNet and commercial paper to help its business.	MagnetoCorpが、自社のビジネスのために、PaperNetとコマーシャルペーパーをどのように用いるかを見ていきましょう。
MagnetoCorp is a well-respected company that makes self-driving electric vehicles.	MagnetoCorpは、自動運転の電気自動車を製造している高く評価された企業です。
In early April 2020, MagnetoCorp won a large order to manufacture 10,000 Model D cars for Daintree, a new entrant in the personal transport market.	2020年4月の初めに、MagnetoCorpは、個人向けの輸送市場に新しく参入したDaintree向けに、10,000台のModel Dを製造するという大きな注文を獲得しました。
Although the order represents a significant win for MagnetoCorp, Daintree will not have to pay for the vehicles until they start to be delivered on November 1, six months after the deal was formally agreed between MagnetoCorp and Daintree.	この注文は、MagnetoCorpにとって非常に重要な成功を意味していますが、Daintreeは、11月1日に納入が開始されてから自動車の代金を払う予定です。これは、MagnetoCorpとDaintreeが正式に契約に合意してから6ヶ月後です。
To manufacture the vehicles, MagnetoCorp will need to hire 1000 workers for at least 6 months.	自動車を製造するには、MagnetoCorpは少なくとも6ヶ月にわたって、1,000人の労働者を雇用する必要があるでしょう。
This puts a short term strain on its finances --	これは、会社の財政に短期的な負担をもたらします。
it will require an extra 5M USD each month to pay these new employees.	新しい従業員の給料として毎月5M USD(500万ドル)が追加で必要となります。
Commercial paper is designed to help MagnetoCorp overcome its short term financing needs -- to meet payroll every month based on the expectation that it will be cash rich when Daintree starts to pay for its new Model D cars.	コマーシャルペーパーは、MagnetoCorpが、この短期資金の必要を乗り越えるために、計画されたものです。Daintreeが新しいModel Dに対しての支払いが始まれば多くの現金が得られることを見込んで、毎月の給料支払いにあてるためのものです。
At the end of May, MagnetoCorp needs 5M USD to meet payroll for the extra workers it hired on May 1.	5月末の時点で、MagnetoCorpは、5/1に雇用した追加の労働者の給料のために、5M USDが必要です。
To do this, it issues a commercial paper with a face value of 5M USD with a maturity date 6 months in the future -- when it expects to see cash flow from Daintree.	このために、MagnetoCorpは、額面が5M USDであり、Daintreeからの現金フローが見込まれる6ヶ月後を満期とするコマーシャルペーパーを発行します。
DigiBank thinks that MagnetoCorp is creditworthy, and therefore doesn't require much of a premium above the central bank base rate of 2%, which would value 4.95M USD today at 5M USD in 6 months time.	DigiBankは、MagnetoCorpが信用できると考えているので、中央銀行の基準金利である2%(これは、4.95M USDが、6ヶ月後に5M USDとなることを意味します)にあまり上乗せすることは要求しません。
It therefore purchases the MagnetoCorp 6 month commercial paper for 4.94M USD -- a slight discount compared to the 4.95M USD it is worth.	そのため、MagnetoCorpの6ヶ月のコマーシャルペーパーを、本来の価値である4.95Mに対して若干の割引をした4.94M USDで購入します。
DigiBank fully expects that it will be able to redeem 5M USD from MagnetoCorp in 6 months time, making it a profit of 10K USD for bearing the increased risk associated with this commercial paper.	DigiBankは、6ヶ月後にMagneto Corpから5M USDを現金化することができ、このコマーシャルペーパーに関するリスクと引き換えに10K USDの利益を得ることができるに違いないと見込んでいます。
This extra 10K means it receives a 2.4% return on investment -- significantly better than the risk free return of 2%.	この10K USDの利益は、この投資によって2.4%のリターンを得ることができることを意味し、リスクをとらない場合の2%よりは少し良いリターンとなります。
At the end of June, when MagnetoCorp issues a new commercial paper for 5M USD to meet June's payroll, it is purchased by BigFund for 4.94M USD.	6月末、MagnetoCorpが6月分の給料のために新しいコマーシャルペーパーを発行すると、BigFundがこれを4.94M USDで購入します。
That's because the commercial conditions are roughly the same in June as they are in May, resulting in BigFund valuing MagnetoCorp commercial paper at the same price that DigiBank did in May.	5月と6月の取引の条件はほとんど同じであるため、BigFundは、MagnetoCorpのコマーシャルペーパーをDigiBankが5月に行ったのと同じ価格で評価していることになります。
Each subsequent month, MagnetoCorp can issue new commercial paper to meet its payroll obligations, and these may be purchased by DigiBank, or any other participant in the PaperNet commercial paper network -- BigFund, HedgeMatic or BrokerHouse.	その後の毎月、MagnetoCorpは、給料支払いの義務を果たすため、新しいコマーシャルペーパーを発行することができ、DigiBankやあるいはコマーシャルペーパー・ネットワーク PaperNetの他の参加者であるBigFund、HedgeMatic、BrokerHouseが購入するでしょう。
These organizations may pay more or less for the commercial paper depending on two factors -- the central bank base rate, and the risk associated with MagnetoCorp.	これらの組織は、コマーシャルペーパーに対して、二つの要因に従って、購入金額を決定します。中央銀行の基準金利と、MagnetoCorpに関するリスクです。
This latter figure depends on a variety of factors such as the production of Model D cars, and the creditworthiness of MagnetoCorp as assessed by RateM, a ratings agency.	後者の値は、Model Dの生産、格付け機関であるRateMによるMagnetoCorpの信用度評価など、様々な要因に依存します。
The organizations in PaperNet have different roles, MagnetoCorp issues paper, DigiBank, BigFund, HedgeMatic and BrokerHouse trade paper and RateM rates paper.	PaperNetの組織は、別々の役割を持っています。MagnetoCorpはコマーシャルペーパーを発行し、DigiBank、BigFund、HedgeMatic、BrokerHouseはコマーシャルペーパーを取引し、RateMはコマーシャルペーパーを評価します。
Organizations of the same role, such as DigiBank, Bigfund, HedgeMatic and BrokerHouse are competitors.	同じ役割を持つ組織、例えば、DigiBank、BigFund、HedgeMatic、BrokerHouseは競合企業です。
Organizations of different roles are not necessarily competitors, yet might still have opposing business interest, for example MagentoCorp will desire a high rating for its papers to sell them at a high price, while DigiBank would benefit from a low rating, such that it can buy them at a low price.	異なる役割の組織は、必ずしも競合企業ではありませんが、営業上の利益が相反することがあります。たとえば、MagnetoCorpは、自社のコマーシャルペーパーを高く売却するために高い評価を得たいと望んでいますが、DigiBankにとっては、より安い価格で購入することができるため低い評価のほうが利益があります。
As can be seen, even a seemingly simple network such as PaperNet can have complex trust relationships.	このように、PaperNetのように単純に見えるネットワークにおいてさえも、複雑な信頼関係が存在することがあります。
A blockchain can help establish trust among organizations that are competitors or have opposing business interests that might lead to disputes.	ブロックチェーンは、係争に発展することがあるような、競合している、あるいは営業上の利益が相反する組織間で信頼を確立するのに役立つことがあります。
Fabric in particular has the means to capture even fine-grained trust relationships.	特にFabricは、細かい粒度での信頼関係すらも表現する手段を持っています。
Let's pause the MagnetoCorp story for a moment, and develop the client applications and smart contracts that PaperNet uses to issue, buy, sell and redeem commercial paper as well as capture the trust relationships between the organizations.	MagetoCorpの話はいったんここまでにして、PaperNetでコマーシャルペーパーを発行、購入、売却、現金化するのに使うクライアントアプリケーションとスマートコントラクトの開発と、組織間の信頼関係を表現することに移りましょう。
We'll come back to the role of the rating agency, RateM, a little later.	格付け機関であるRateMの役割については、少し後で戻ってくることにしましょう。
**Audience**: Architects, Application and smart contract developers, Business professionals	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者、ビジネス専門家
Let's analyze commercial paper in a little more detail.	コマーシャルペーパーについてもう少し詳細に分析してみましょう。
PaperNet participants such as MagnetoCorp and DigiBank use commercial paper transactions to achieve their business objectives --	MagnetoCorpやDigiBankといったPaperNetの参加者は、コマーシャルペーパーのトランザクションを利用して、それぞれのビジネス上の目的を達成しようとしています。
let's examine the structure of a commercial paper and the transactions that affect it over time.	あるコマーシャルペーパーの構造と、それに変更を与えるトランザクションについて見ていきましょう。
We will also consider which organizations in PaperNet need to sign off on a transaction based on the trust relationships among the organizations in the network.	また、ネットワークの組織間の信頼関係に基づいて、PaperNetのどの組織の署名が、トランザクションに対して必要かについても考えていきます。
Later we'll focus on how money flows between buyers and sellers; for now, let's focus on the first paper issued by MagnetoCorp.	後で、購入する組織と売却する組織間での資金の流れについても着目しますが、まずは、MagnetoCorpによって発行された最初のコマーシャルペーパーに注目しましょう。
A paper 00001 is issued by MagnetoCorp on May 31.	コマーシャルペーパー00001は、MagnetoCorpによって5月31日に発行されています。
Spend a few moments looking at the first state of this paper, with its different properties and values:	このコマーシャルペーパーの最初のステートと、そのプロパティと値について、見てみましょう。
This paper state is a result of the issue transaction and it brings MagnetoCorp's first commercial paper into existence!	このコマーシャルペーパーのステートは、発行(issue)トランザクションの結果で、MagnetoCorpの最初のコマーシャルペーパーを誕生させています。
Notice how this paper has a 5M USD face value for redemption later in the year. See how the `Issuer` and `Owner` are the same when paper 00001 is issued. Notice that this paper could be uniquely identified as `MagnetoCorp00001` -- a composition of the `Issuer` and `Paper` properties. Finally, see how the property `Current state = issued` quickly identifies the stage of MagnetoCorp paper 00001 in its lifecycle.	このステートが以下のことを表していることに注意してください。このコマーシャルペーパーの額面は5M USDで、この年の後半に現金化できること、コマーシャルペーパー00001が発行された時点では、発行者(`Issuer`)と所有者(`Owner`)は同じであること、このコマーシャルペーパーは、`MagnetoCorp00001`(`Issuer`と`Paper`プロパティの組み合わせ)として一意に識別できること、そして最後に、`Current state = issued`(現在の状態 = 発行済み)によって、MagnetoCorpのコマーシャルペーパー0001が、そのライフサイクルにおいてどのステージにあるかが簡単にわかることです。
Shortly after issuance, the paper is bought by DigiBank.	発行後まもなく、DigiBankがこのコマーシャルペーパーを購入します。
Spend a few moments looking at how the same commercial paper has changed as a result of this buy transaction:	この購入(buy)トランザクションの結果、同じコマーシャルペーパーがどのように変化するかを見てみましょう。
The most significant change is that of `Owner` -- see how the paper initially owned by `MagnetoCorp` is now owned by `DigiBank`.	最も大きな違いは、所有者(`Owner`)の変化で、最初に`MagnetoCorp`が所有していたコマーシャルペーパーが、今は`DigiBank`に所有されています。
We could imagine how the paper might be subsequently sold to BrokerHouse or HedgeMatic, and the corresponding change to `Owner`.	このコマーシャルペーパーが、こののちBrokeHouseやHedgeMaticに売却されたなら、`Owner`に対応する変化が起きることは想像できるでしょう。
Note how `Current state` allow us to easily identify that the paper is now `trading`.	現在の状態(`Current state`)によって、このコマーシャルペーパーが取引中(`trading`)の状態にあることが容易にわかります。
After 6 months, if DigiBank still holds the commercial paper, it can redeem it with MagnetoCorp:	6ヶ月後、もしDigiBankがコマーシャルペーパーをまだ保持していたならば、それをMagnetoCorpに対して現金化することができます。
This final redeem transaction has ended the commercial paper's lifecycle -- it can be considered closed.	最後の現金化(redeem)トランザクションによって、コマーシャルペーパーのライフサイクルは終了し、コマーシャルペーパーは役目を終えたものと考えることができます。
It is often mandatory to keep a record of redeemed commercial papers, and the `redeemed` state allows us to quickly identify these.	現金化されたコマーシャルペーパーの記録を保存することはしばしば必須とされ、現金化済み(`redeemed`)という状態によって、すぐにそういったコマーシャルペーパーを識別することができます。
The value of `Owner` of a paper can be used to perform access control on the redeem transaction, by comparing the `Owner` against the identity of the transaction creator.	コマーシャルペーパーの所有者(`Owner`)の値は、現金化(redeem)トランザクションに対するアクセスコントロールを行うのに使うことができ、所有者(`Owner`)の値をトランザクション作成者のアイデンティティと比較することで実現できます。
Fabric supports this through the [`getCreator()` chaincode API](https://github.com/hyperledger/fabric-chaincode-node/blob/{BRANCH}/fabric-shim/lib/stub.js#L293).	Fabricでは、これを[`getCreator()` チェーンコードAPI](https://github.com/hyperledger/fabric-chaincode-node/blob/release-2.x/libraries/fabric-shim/lib/stub.js#L295)によってサポートしています。
If Go is used as a chaincode language, the [client identity chaincode library](https://github.com/hyperledger/fabric-chaincode-go/blob/{BRANCH}/pkg/cid/README.md) can be used to retrieve additional attributes of the transaction creator.	チェーンコードの開発言語としてGoを使う場合は、[クライアントアイデンティティ・チェーンコード・ライブラリ](https://github.com/hyperledger/fabric-chaincode-go/blob/master/pkg/cid/README.md)を使うことで、トランザクションの作成者の追加属性を取得することができます。
We've seen that paper 00001's lifecycle is relatively straightforward -- it moves between `issued`, `trading` and `redeemed` as a result of an issue, buy, or redeem transaction.	コマーシャルペーパー00001のライフサイクルが比較的単純明快であり、発行、購入、現金化トランザクションの結果として、発行済み(`issued`)、取引中(`trading`)、現金化済み(`redeemed`)と、移っていくことがわかりました。
These three transactions are initiated by MagnetoCorp and DigiBank (twice), and drive the state changes of paper 00001.	この3つのトランザクションは、MagnetoCorpとDigiBank(2回)によって開始されており、コマーシャルペーパー00001のステート変化を引き起こしています。
Let's have a look at the transactions that affect this paper in a little more detail:	コマーシャルペーパーに変更を与えるこれらのトランザクションについてもう少し詳細に見ていきましょう。
Examine the first transaction initiated by MagnetoCorp:	MagnetoCorpによって最初に発行されたトランザクションを見てください。
See how the issue transaction has a structure with properties and values.	発行(issue)トランザクションがどのようなプロパティと値の構造をもっているかを見てください。
This transaction structure is different to, but closely matches, the structure of paper 00001.	このトランザクションは、コマーシャルペーパー00001の構造とかなり近いですが、異なるものです。
That's because they are different things -- paper 00001 reflects a state of PaperNet that is a result of the issue transaction.	これは、2つのものは別のものだからで、コマーシャルペーパー00001は、この発行(issue)トランザクションの結果を反映したものだからです。
It's the logic behind the issue transaction (which we cannot see) that takes these properties and creates this paper.	このプロパティを受け取りコマーシャルペーパーを作るのは、発行(issue)トランザクションの裏にあるロジック(ここでは見ることはできませんが)です。
Because the transaction creates the paper, it means there's a very close relationship between these structures.	トランザクションによってコマーシャルペーパーが作られるので、これらの構造の間には非常に近い関係があることになります。
The only organization that is involved in the issue transaction is MagnetoCorp.	発行(issue)トランザクションにおいて関係する唯一の組織は、MagnetoCorpです。
Naturally, MagnetoCorp needs to sign off on the transaction.	当然、MagnetoCorpがこのトランザクションに署名することが必要です。
In general, the issuer of a paper is required to sign off on a transaction that issues a new paper.	一般的に、コマーシャルペーパーの発行者が、それを発行するトランザクションに署名を行うことが必要となります。
Next, examine the buy transaction which transfers ownership of paper 00001 from MagnetoCorp to DigiBank: See how the buy transaction has fewer properties that end up in this paper.	次に、コマーシャルペーパー00001の所有権をMagnetoCorpからDigiBankに移す、購入(buy)トランザクションについて見てみましょう。購入(buy)トランザクションでは、コマーシャルペーパーに反映されるプロパティが少ないことに注目してください。
That's because this transaction only modifies this paper.	これは、このトランザクションが、コマーシャルペーパーを変更するだけだからです。
It's only `New owner = DigiBank` that changes as a result of this transaction; everything else is the same.	このトランザクションの結果として、変更が行われるのは、`New owner = DigiBank`(新所有者 = DigiBank)の部分だけであり、その他は変化ありません。
That's OK -- the most important thing about the buy transaction is the change of ownership, and indeed in this transaction, there's an acknowledgement of the current owner of the paper, MagnetoCorp.	このことは特に問題はなく、購入(buy)トランザクションの最も重要なことは、所有権の変更であり、実際このトランザクションにおいては、元の所有者であるMagnetoCorpの承認があります。
You might ask why the `Purchase time` and `Price` properties are not captured in paper 00001?	コマーシャルペーパー00001に、購入時刻(`Purchase time`)と購入価格(`Price`)が表れないのはなぜかと思うかもしれません。
This comes back to the difference between the transaction and the paper.	これは、トランザクションとコマーシャルペーパーの違いから来ているものです。
The 4.94 M USD price tag is actually a property of the transaction, rather than a property of this paper.	4.94M USDという値札は、コマーシャルペーパーのプロパティというよりも、トランザクションのプロパティであるからです。
Spend a little time thinking about this difference; it is not as obvious as it seems.	この違いについて少し考えてみてください。これは、そんなに自明なものではありません。
We're going to see later that the ledger will record both pieces of information -- the history of all transactions that affect this paper, as well its latest state.	後で、台帳は両方の情報、すなわち、コマーシャルペーパーを変更するすべてのトランザクションの履歴と最新のステートが記録されていることについて述べます。
Being clear on this separation of information is really important.	この情報の分離についてしっかりと理解しておくことは非常に重要です。
It's also worth remembering that paper 00001 may be bought and sold many times.	また、コマーシャルペーパー00001は複数回にわたって購入、売却されるかもしれないということも、考えに入れておくべきです。
Although we're skipping ahead a little in our scenario, let's examine what transactions we might see if paper 00001 changes ownership.	シナリオから少し離れてしまいますが、コマーシャルペーパー00001の所有者が変わった時に、あるかもしれないトランザクションについてみてみましょう。
If we have a purchase by BigFund: Followed by a subsequent purchase by HedgeMatic: See how the paper owners changes, and how in our example, the price changes.	もし、BigFundによる購入があったとします。そして次に、HedgeMaticによる次のような購入があったとします。コマーシャルペーパーの所有者がどのように変化し、そしてこの例でどのように価格が変化したかを見てください。
Can you think of a reason why the price of MagnetoCorp commercial paper might be falling?	MagnetoCorpのコマーシャルペーパーの価格が下落した理由について、何か思いつくでしょうか？
Intuitively, a buy transaction demands that both the selling as well as the buying organization need to sign off on such a transaction such that there is proof of the mutual agreement among the two parties that are part of the deal.	直観的には、購入(buy)トランザクションは、その取引に関わる二者の相互の合意の証拠となるように、購入する組織と同時に売却する組織の両方が、そのトランザクションに署名することが必要です。
The redeem transaction for paper 00001 represents the end of its lifecycle.	コマーシャルペーパー00001の現金化(redeem)のトランザクションは、そのライフサイクルの最後を表しています。
In our relatively simple example, HedgeMatic initiates the transaction which transfers the commercial paper back to MagnetoCorp: Again, notice how the redeem transaction has very few properties; all of the changes to paper 00001 can be calculated data by the redeem transaction logic: the `Issuer` will become the new owner, and the `Current state` will change to `redeemed`.	この比較的単純な例では、HedgeMaticがMagnetoCorpにコマーシャルペーパーを戻すトランザクションを開始します。この現金化(redeem)トランザクションのプロパティが非常に少ないことに注目してください。コマーシャルペーパー00001に対する変更は、現金化のトランザクションのロジックによってすべて計算することができます。発行者(`Issuer`)が新しい所有者となり、現在の状態(`Current state`)は現金化済み(`redeemed`)に変更されます。
The `Current owner` property is specified in our example, so that it can be checked against the current holder of the paper.	現在のコマーシャルペーパーの保持者とチェックをするために、現在の所有者(`Current owner`)プロパティが含まれています。
From a trust perspective, the same reasoning of the buy transaction also applies to the redeem instruction: both organizations involved in the transaction are required to sign off on it.	信頼という観点からすると、購入(buy)トランザクションと同じ理由付けが、現金化(redeem)の指示に対しても適用され、トランザクションに関わる二つの組織の両方がトランザクションに署名することが必要となります。
In this topic, we've seen how transactions and the resultant paper states are the two most important concepts in PaperNet.	このトピックでは、トランザクションとその結果としてのコマーシャルペーパーのステートが、PaperNetにおける二つの最も重要な概念であることをみてきました。
Indeed, we'll see these two fundamental elements in any Hyperledger Fabric distributed [ledger](../ledger/ledger.html) -- a world state, that contains the current value of all objects, and a blockchain that records the history of all transactions that resulted in the current world state.	実際、この二つの基本的な要素は、Hyperledger Fabricのいかなる分散[台帳](../ledger/ledger.html)においても見ることができます。すべてのオブジェクトの現在の値をもつワールドステートと、現在のワールドステートをもたらしているすべてのトランザクションの履歴を記録するブロックチェーンです。
The required sign-offs on transactions are enforced through rules, which are evaluated before appending a transaction to the ledger.	トランザクションに対する必要な署名は、台帳にトランザクションを追加するときに評価されるルールを通じて強制されます。
Only if the required signatures are present, Fabric will accept a transaction as valid.	必要な署名がそろっている場合のみ、Fabricはトランザクションを妥当なもの(valid)として受け入れます。
You're now in a great place translate these ideas into a smart contract.	今このような考えをスマートコントラクトに変換するのにちょうどよいところにいます。
Don't worry if your programming is a little rusty, we'll provide tips and pointers to understand the program code.	プログラムの能力が少し衰えているなと思っていても心配しないでください。プログラムコードを理解するためのヒントや参照すべき場所をお伝えします。
Mastering the commercial paper smart contract is the first big step towards designing your own application.	コマーシャルペーパーのスマートコントラクトをマスターすることは、独自のアプリケーションを設計するうえで大きな一歩となります。
Or, if you're a business analyst who's comfortable with a little programming, don't be afraid to keep dig a little deeper!	もし、あまりプログラムを作らないビジネスアナリストでしたら、ためらわずにより深く見ていきましょう!
The Hyperledger Requirements WG is documenting a number of blockchain use cases and maintaining an inventory `here <https://wiki.hyperledger.org/display/LMDWG/Use+Cases>`__.	Hyperledger Requirements WGは、多くのブロックチェーンのユースケースを文書化し、`こちら <https://wiki.hyperledger.org/display/LMDWG/Use+Cases>`__ で管理しています。
After you have downloaded the Hyperledger Fabric Docker images and samples, you can deploy a test network by using scripts that are provided in the `fabric-samples` repository.	Hyperledger FabricのDockerイメージとサンプルをダウンロードした後、`fabric-samples`リポジトリで提供されているスクリプトを使用してテストネットワークをデプロイできます。
You can use the test network to learn about Fabric by running nodes on your local machine.	テストネットワークを使用して、ローカルマシンでノードを実行することにより、Fabricについて学習できます。
More experienced developers can use the network to test their smart contracts and applications.	より経験豊富な開発者は、このテストネットワークを使用してスマートコントラクトとアプリケーションをテストできます。
The network is meant to be used only as a tool for education and testing.	このテストネットワークは、教育とテストのためのツールとしてのみ使用することを目的としています。
It should not be used as a template for deploying a production network.	本番用ネットワークをデプロイするためのテンプレートとして使用しないでください。
The test network is being introduced in Fabric v2.0 as the long term replacement for the `first-network` sample.	テストネットワークは、`first-network`サンプルの長期的な代替としてFabric v2.0に導入されています。
The sample network deploys a Fabric network with Docker Compose.	このサンプルネットワークでは、Docker Composeを使用してFabricネットワークをデプロイします。
Because the nodes are isolated within a Docker Compose network, the test network is not configured to connect to other running fabric nodes.	ノードはDocker Composeネットワーク内で分離されているため、テストネットワークは他の実行中のFabricのノードに接続するようには設定されていません。
Note: These instructions have been verified to work against the latest stable Docker images and the pre-compiled setup utilities within the supplied tar file.	注: これらの手順は、最新の安定版Dockerイメージと、提供されるtarファイル内のコンパイル済みセットアップユーティリティに対して動作することが確認されています。
If you run these commands with images or tools from the current master branch, it is possible that you will encounter errors.	現在のmasterブランチのイメージまたはツールを使用してこれらのコマンドを実行すると、エラーが発生する可能性があります。
Before you can run the test network, you need to clone the `fabric-samples` repository and download the Fabric images.	テストネットワークを実行する前に、`fabric-samples`リポジトリのクローンを作成し、Fabricのイメージをダウンロードする必要があります。
Make sure that you have installed the [Prerequisites](prereqs.html) and [Installed the Samples, Binaries and Docker Images](install.html).	その準備をするためには、[前提条件](prereqs.html) と[サンプル、バイナリ、Dockerイメージのインストール](install.html) を確認してください。
You can find the scripts to bring up the network in the `test-network` directory of the ``fabric-samples`` repository.	ネットワークを起動するためのスクリプトは、``fabric-samples``リポジトリの`test-network`ディレクトリにあります。
Navigate to the test network directory by using the following command:	次のコマンドを使用して、テストネットワークディレクトリに移動します:
In this directory, you can find an annotated script, ``network.sh``, that stands up a Fabric network using the Docker images on your local machine.	このディレクトリには、ローカルマシン上のDockerイメージを使用してFabricネットワークを立ち上げる注釈付きスクリプト``network.sh``があります。
You can run ``./network.sh -h`` to print the script help text:	``./network.sh -h``を実行して、スクリプトのヘルプテキストを表示できます:
'up' - bring up fabric orderer and peer nodes.	'up' - FabricのOrdererとピアノードを起動します。
No channel is created	チャネルは作成されません。
'up createChannel' - bring up fabric network with one channel	'up createChannel' - 1つのチャネルを持つFabricネットワークを起動します。
'createChannel' - create and join a channel after the network is created	'createChannel' - ネットワークが作られた後に、チャネルを作成して参加します。
'deployCC' - deploy the fabcar chaincode on the channel	'deployCC' - fabcarチェーンコードをチャネル上にデプロイします。
'down' - clear the network with docker-compose down	'down' - docker-compose downを用いてネットワークをクリアします。
'restart' - restart the network	'restart' - ネットワークを再起動します。
-ca <use CAs> -  create Certificate Authorities to generate the crypto material	-ca <use CAs> - 暗号マテリアル (crypto material) を生成するための認証局(CA)を作成します。
-c <channel name> - channel name to use (defaults to "mychannel")	-c <channel name> - 使用するチャネル名 (デフォルトは"mychannel")
-s <dbtype> - the database backend to use: goleveldb (default) or couchdb	-s <dbtype> - 使用するデータベースのバックエンド: goleveldb (デフォルト) or couchdb
-r <max retry> - CLI times out after certain number of attempts (defaults to 5)	-r <max retry> - CLIは指定した回数の試行後にタイムアウトします (デフォルトは5)
-d <delay> - delay duration in seconds (defaults to 3)	-d <delay> - 遅延時間 (秒単位で指定) (デフォルトは3)
-l <language> - the programming language of the chaincode to deploy: go (default), java, javascript, typescript	-l <language> - デプロイするチェーンコードのプログラミング言語: go (デフォルト), java, javascript, typescript
-v <version>  - chaincode version.	-v <version>  - チェーンコードのバージョン。
Must be a round number, 1, 2, 3, etc	1, 2, 3などの整数でなければいけません。
-i <imagetag> - the tag to be used to launch the network (defaults to "latest")	-i <imagetag> - ネットワークの起動に利用されるDockerイメージタグ (デフォルトは"latest")
-cai <ca_imagetag> - the image tag to be used for CA (defaults to "1.4.6")	-cai <ca_imagetag> - CAに利用されるDockerイメージタグ (デフォルトは"1.4.6")
-verbose - verbose mode network.sh -h (print this message)	-verbose - verboseモードnetwork.sh -h (このメッセージを表示)
From inside the `test-network` directory, run the following command to remove any containers or artifacts from any previous runs:	`test-network`ディレクトリ内で、次のコマンドを実行して、以前に実行したコンテナやアーティファクトを削除します:
You can then bring up the network by issuing the following command.	そして、次のコマンドを発行することでネットワークを立ち上げることができます。
You will experience problems if you try to run the script from another directory:	もし別のディレクトリからスクリプトを実行しようとすると問題が発生します:
This command creates a Fabric network that consists of two peer nodes, one ordering node.	このコマンドは、2つのピアノードと1つのOrdererノードからなるFabricネットワークを作成します。
No channel is created when you run `./network.sh up`, though we will get there in a [future step](#creating-a-channel).	`./network.sh up`を実行してもチャネルは作成されませんが、これについては[後のステップ](#creating-a-channel) で説明します。
If the command completes successfully, you will see the logs of the nodes being created:	コマンドが正常に完了すると、作成されたノードのログが表示されます:
If you don't get this result, jump down to [Troubleshooting](#troubleshooting) for help on what might have gone wrong.	上記のような結果が得られない場合は、[トラブルシューティング](#troubleshooting) に移動して、何が間違っているのかを確認してください。
By default, the network uses the cryptogen tool to bring up the network.	デフォルトでは、ネットワークはcryptogenツールを使用してネットワークを起動します。
However, you can also [bring up the network with Certificate Authorities](#bring-up-the-network-with-certificate-authorities).	しかし、CAを使用することもできます ([認証局を使ったネットワークを立ち上げる](#bring-up-the-network-with-certificate-authorities) 参照)。
After your test network is deployed, you can take some time to examine its components.	テストネットワークがデプロイされたら、しばらく時間をかけてそのコンポーネントを調べることができます。
Run the following command to list all of Docker containers that are running on your machine.	次のコマンドを実行して、マシンで実行されているすべてのDockerコンテナを一覧表示します。
You should see the three nodes that were created by the `network.sh` script:	`network.sh`スクリプトによって作成された3つのノードが表示されます:
Each node and user that interacts with a Fabric network needs to belong to an organization that is a network member.	Fabricネットワーク上でやりとりする各ノードおよびユーザーは、ネットワークメンバーである組織に所属する必要があります。
The group of organizations that are members of a Fabric network are often referred to as the consortium.	Fabricネットワークのメンバーである組織のグループは、しばしばコンソーシアムと呼ばれます。
The test network has two consortium members, Org1 and Org2.	テストネットワークには、Org1とOrg2の2つのコンソーシアムメンバーがいます。
The network also includes one orderer organization that maintains the ordering service of the network.	また、ネットワークのオーダリングサービスを維持するオーダリング組織 (orderer organization) が1つ含まれています。
[Peers](peers/peers.html) are the fundamental components of any Fabric network.	[ピア](peers/peers.html) は、あらゆるFabricネットワークの基本的なコンポーネントです。
Peers store the blockchain ledger and validate transactions before they are committed to the ledger.	ピアはブロックチェーン台帳を保存し、台帳にコミットする前にトランザクションを検証します。
Peers run the smart contracts that contain the business logic that is used to manage the assets on the blockchain ledger.	ピアは、ブロックチェーン台帳上の資産を管理するために使用されるビジネスロジックを含むスマートコントラクトを実行します。
Every peer in the network needs to belong to a member of the consortium.	ネットワーク内のすべてのピアは、コンソーシアムのメンバーに属している必要があります。
In the test network, each organization operates one peer each, `peer0.org1.example.com` and `peer0.org2.example.com`.	テストネットワークでは、各組織がそれぞれ1つのピア`peer0.org1.example.com`と`peer0.org2.example.com`を動かしています。
Every Fabric network also includes an [ordering service](orderer/ordering_service.html).	すべてのFabricネットワークには、[オーダリングサービス](orderer/ordering_service.html) も含まれています。
While peers validate transactions and add blocks of transactions to the blockchain ledger, they do not decide on the order of transactions or include them into new blocks.	ピアはトランザクションを検証し、トランザクションのブロックをブロックチェーン台帳に追加しますが、トランザクションの順序を決定したり、トランザクションを新しいブロックに追加したりすることはありません。
On a distributed network, peers may be running far away from each other and not have a common view of when a transaction was created.	分散ネットワークでは、ピアはお互いに離れた場所にあって、トランザクションがいつ作成されたかについて共通の見解を持っていないかもしれません。
Coming to consensus on the order of transactions is a costly process that would create overhead for the peers.	トランザクションの順序について合意を得ることは、ピアのオーバーヘッドを生み出すコストのかかるプロセスです。
An ordering service allows peers to focus on validating transactions and committing them to the ledger.	オーダリングサービスにより、ピアはトランザクションの検証と台帳へのコミットに集中できます。
After ordering nodes receive endorsed transactions from clients, they come to consensus on the order of transactions and then add them to blocks.	オーダリングノードは、クライアントからエンドースされたトランザクションを受信した後、トランザクションの順序について合意に至り、ブロックに追加します。
The blocks are then distributed to peer nodes, which add the blocks the blockchain ledger.	その後、ブロックはピアノードに配布され、ピアノードがブロックチェーン台帳にブロックを追加します。
Ordering nodes also operate the system channel that defines the capabilities of a Fabric network, such as how blocks are made and which version of Fabric that nodes can use.	オーダリングノードは、ブロックの作成方法やノードが使用できるFabricのバージョンなど、Fabricネットワークのケーパビリティを定義するシステムチャネルも操作します。
The system channel defines which organizations are members of the consortium.	システムチャネルは、どの組織がコンソーシアムのメンバーであるかを定義します。
The sample network uses a single node Raft ordering service that is operated by the ordering organization.	今回のサンプルネットワークは、オーダリング組織によって運用されている単一ノードによるRaftオーダリングサービスを使用しています。
You can see the ordering node running on your machine as `orderer.example.com`.	マシン上で実行されているオーダリングノードは`orderer.example.com`と表示されます。
While the test network only uses a single node ordering service, a real network would have multiple ordering nodes, operated by one or multiple orderer organizations.	テストネットワークは単一ノードのオーダリングサービスのみを使用しますが、実際のネットワークには複数のオーダリングノードがあり、1つまたは複数のオーダリング組織によって運用されます。
The different ordering nodes would use the Raft consensus algorithm to come to agreement on the order of transactions across the network.	複数のオーダリングノードは、Raft合意形成アルゴリズムを使用して、ネットワーク全体のトランザクションの順序について合意します。
Now that we have peer and orderer nodes running on our machine, we can use the script to create a Fabric channel for transactions between Org1 and Org2.	マシン上ではピアノードとOrdererノードが実行されているので、本スクリプトを使用して、Org1とOrg2の間のトランザクションを行うためのFabricのチャネルを作成できます。
Channels are a private layer of communication between specific network members.	チャネルは、特定のネットワークメンバー間の通信のプライベートレイヤーです。
Channels can be used only by organizations that are invited to the channel, and are invisible to other members of the network.	チャネルは、チャネルに招待された組織のみが使用でき、ネットワークのその他のメンバーには見えません。
Each channel has a separate blockchain ledger.	各チャネルには、個別のブロックチェーン台帳があります。
Organizations that have been invited "join" their peers to the channel to store the channel ledger and validate the transactions on the channel.	招待された組織は、ピアをチャネルに「参加」させて、チャネル台帳にデータを保存したり、チャネル上でのトランザクションを検証したりします。
You can use the `network.sh` script to create a channel between Org1 and Org2 and join their peers to the channel.	`network.sh`スクリプトを使用して、Org1とOrg2間のチャネルを作成し、それらのピアをチャネルに参加させることができます。
Run the following command to create a channel with the default name of `mychannel`:	次のコマンドを実行して、`mychannel`というデフォルトの名前でチャネルを作成します:
If the command was successful, you can see the following message printed in your logs:	コマンドが成功した場合、コンソールログに以下のようなメッセージが表示されます:
========= Channel successfully joined ===========	========= Channel successfully joined ===========
You can also use the channel flag to create a channel with custom name.	チャネルフラグを使用して、名前をカスタマイズしたチャネルを作成することもできます。
As an example, the following command would create a channel named `channel1`:	例として、次のコマンドは`channel1`という名前のチャネルを作成します:
The channel flag also allows you to create multiple channels by specifying different channel names.	チャネルフラグを使用すると、異なるチャネル名を指定して複数のチャネルを作成することもできます。
After you create `mychannel` or `channel1`, you can use the command below to create a second channel named `channel2`:	`mychannel`または`channel1`を作成した後、以下のコマンドを使用して、`channel2`という名前の2番目のチャネルを作成できます:
If you want to bring up the network and create a channel in a single step, you can use the `up` and `createChannel` modes together:	1つのステップでネットワークを立ち上げてチャネルを作成したい場合は、`up`モードと`createChannel`モードを一緒に使用できます:
After you have created a channel, you can start using [smart contracts](smartcontract/smartcontract.html) to interact with the channel ledger.	チャネルを作成したら、[スマートコントラクト](smartcontract/smartcontract.html) を使用してチャネル台帳とやり取りできるようになります。
Smart contracts contain the business logic that governs assets on the blockchain ledger.	スマートコントラクトには、ブロックチェーン台帳上の資産を管理するビジネスロジックが含まれています。
Applications run by members of the network can invoke smart contracts to create assets on the ledger, as well as change and transfer those assets.	ネットワークメンバーによって実行されるアプリケーションは、スマートコントラクトを呼び出して、台帳上に資産を作成したり、それらの資産を変更および譲渡したりできます。
Applications also query smart contracts to read data on the ledger.	アプリケーションはまた、スマートコントラクトを参照して、台帳上のデータを読み取ります。
To ensure that transactions are valid, transactions created using smart contracts typically need to be signed by multiple organizations to be committed to the channel ledger.	トランザクションが有効であることを保証するために、スマートコントラクトを使用して作成されたトランザクションは、通常、チャネル台帳にコミットするために複数の組織によって署名される必要があります。
Multiple signatures are integral to the trust model of Fabric.	複数の署名は、Fabricの信頼モデルに不可欠です。
Requiring multiple endorsements for a transaction prevents one organization on a channel from tampering with the ledger on their peer or using business logic that was not agreed to.	トランザクションに複数のエンドースメントを要求することで、チャネル上の1つの組織が台帳を改ざんしたり、合意されていないビジネスロジックを使用したりするのを防ぎます。
To sign a transaction, each organization needs to invoke and execute the smart contract on their peer, which then signs the output of the transaction.	トランザクションに署名するには、各組織がピア上でスマートコントラクトを呼び出して実行する必要があり、ピアがトランザクションの出力に署名します。
If the output is consistent and has been signed by enough organizations, the transaction can be committed to the ledger.	出力に一貫性があり、十分な組織によって署名されている場合、トランザクションは台帳にコミットできます。
The policy that specifies the set organizations on the channel that need to execute the smart contract is referred to as the endorsement policy, which is set for each chaincode as part of the chaincode definition.	スマートコントラクトを実行する必要がある、チャネル上の設定された組織を指定するポリシーは、エンドースメントポリシーと呼ばれ、チェーンコード定義の一部としてチェーンコードごとに設定されます。
In Fabric, smart contracts are deployed on the network in packages referred to as chaincode.	Fabricでは、スマートコントラクトはチェーンコードと呼ばれるパッケージでネットワークにデプロイされます。
A Chaincode is installed on the peers of an organization and then deployed to a channel, where it can then be used to endorse transactions and interact with the blockchain ledger.	チェーンコードは組織のピアにインストールされてからチャネルにデプロイされ、その後トランザクションをエンドースしてブロックチェーン台帳とやり取りするために使用できます。
Before a chaincode can be deployed to a channel, the members of the channel need to agree on a chaincode definition that establishes chaincode governance.	チェーンコードをチャネルにデプロイする前に、チャネルのメンバーは、チェーンコードのガバナンスを確立するチェーンコード定義について合意する必要があります。
When the required number of organizations agree, the chaincode definition can be committed to the channel, and the chaincode is ready to be used.	必要な数の組織が同意すると、チェーンコード定義をチャネルにコミットでき、チェーンコードを使用できるようになります。
After you have used the `network.sh` to create a channel, you can start a chaincode on the channel using the following command:	`network.sh`を使用してチャネルを作成した後、次のコマンドを使用してチャネル上でチェーンコードを開始することができます:
The `deployCC` subcommand will install the fabcar chaincode on ``peer0.org1.example.com`` and ``peer0.org2.example.com`` and then deploy the chaincode on the channel specified using the channel flag (or `mychannel` if no channel is specified).	`deployCC`サブコマンドは、 fabcar チェーンコードを``peer0.org1.example.com``と``peer0.org2.example.com``にインストールし、チャネルフラグを使用して指定されたチャネルにチェーンコードをデプロイします (チャネルが指定されていない場合は`mychannel`)。
If you are deploying a chaincode for the first time, the script will install the chaincode dependencies.	チェーンコードを初めてデプロイする場合、本スクリプトはチェーンコードの依存関係をインストールします。
By default, The script installs the Go version of the fabcar chaincode.	デフォルトでは、本スクリプトはfabcarチェーンコードのGo版をインストールします。
However, you can use the language flag, `-l`, to install the Java or javascript versions of the chaincode.	ただし、言語フラグ `-l`を使用して、Javaまたはjavascript版のチェーンコードをインストールできます。
You can find the Fabcar chaincode in the `chaincode` folder of the `fabric-samples` directory.	fabcarチェーンコードは、`fabric-samples`ディレクトリの`chaincode`フォルダにあります。
This folder contains sample chaincode that are provided as examples and used by tutorials to highlight Fabric features.	このフォルダには、例として提供され、チュートリアル内でFabricの機能を強調するために使用されるサンプルチェーンコードが含まれています。
After the fabcar chaincode definition has been committed to the channel, the script initializes the chaincode by invoking the `init` function and then invokes the chaincode to put an initial list of cars on the ledger.	fabcarのチェーンコード定義がチャネルにコミットされた後、本スクリプトは`init`関数を呼び出してチェーンコードを初期化し、チェーンコードを呼び出して車の初期リストを台帳に格納します。
The script then queries the chaincode to verify that the data was added.	次に、本スクリプトはチェーンコードを参照して、データが追加されたことを確認します。
If the chaincode was installed, deployed, and invoked correctly, you should see the following list of cars printed in your logs:	チェーンコードが正しくインストール、デプロイ、呼び出しされた場合、ログに以下のような車のリストが表示されているはずです:
After you bring up the test network, you can use the `peer` CLI to interact with your network.	テストネットワークを起動したら、`peer` CLIを使用してそのネットワークとやり取りできます。
The `peer` CLI allows you to invoke deployed smart contracts, update channels, or install and deploy new smart contracts from the CLI.	`peer` CLIを使用すると、デプロイされたスマートコントラクトを呼び出したり、チャネルを更新したり、CLIから新しいスマートコントラクトをインストールしてデプロイしたりできます。
Make sure that you are operating from the `test-network` directory.	`test-network`ディレクトリから操作していることを確認してください。
If you followed the instructions to [install the Samples, Binaries and Docker Images](install.html), You can find the `peer` binaries in the `bin` folder of the `fabric-samples` repository.	[サンプル、バイナリ、Dockerイメージのインストール](install.html) の手順に従った場合、`fabric-samples`リポジトリの`bin`フォルダに`peer`バイナリがあります。
Use the following command to add those binaries to your CLI Path:	次のコマンドを使用して、これらのバイナリをパスに追加します:
You also need to set the `FABRIC_CFG_PATH` to point to the `core.yaml` file in the `fabric-samples` repository:	また、`fabric-samples`リポジトリ内の`core.yaml`ファイルを指すように`FABRIC_CFG_PATH`を設定する必要があります:
You can now set the environment variables that allow you to operate the `peer` CLI as Org1:	以下で、`peer` CLIをOrg1として操作できるようにする環境変数を設定できます:
Environment variables for Org1	Org1用の環境変数
export CORE_PEER_TLS_ENABLED=true	export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"	export CORE_PEER_LOCALMSPID="Org1MSP"
@@ -300,18 +259,15 @@ export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.examp	@@ -300,18 +259,15 @@ export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.examp
export CORE_PEER_ADDRESS=localhost:7051	export CORE_PEER_ADDRESS=localhost:7051
The `CORE_PEER_TLS_ROOTCERT_FILE` and `CORE_PEER_MSPCONFIGPATH` environment variables point to the Org1 crypto material in the `organizations` folder.	`CORE_PEER_TLS_ROOTCERT_FILE` および `CORE_PEER_MSPCONFIGPATH` 環境変数は、`organizations` フォルダ内のOrg1の暗号マテリアルを指しています。
If you used `./network.sh deployCC` to install and start the fabcar chaincode, you can now query the ledger from your CLI.	`./network.sh deployCC`を使用してfabcarチェーンコードをインストールして開始している場合、CLIから台帳にクエリを実行できます。
Run the following command to get the list of cars that were added to your channel ledger:	次のコマンドを実行して、チャネル台帳に追加された車のリストを取得します:
peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryAllCars"]}'	peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryAllCars"]}'
If the command is successful, you can see the same list of cars that were printed in the logs when you ran the script:	このコマンドが成功した場合、スクリプトを実行したときにログに表示されたものと同じ車のリストを確認できるはずです:
[{"Key":"CAR0", "Record":{"make":"Toyota","model":"Prius","colour":"blue","owner":"Tomoko"}},	[{"Key":"CAR0", "Record":{"make":"Toyota","model":"Prius","colour":"blue","owner":"Tomoko"}},
{"Key":"CAR1", "Record":{"make":"Ford","model":"Mustang","colour":"red","owner":"Brad"}},	{"Key":"CAR1", "Record":{"make":"Ford","model":"Mustang","colour":"red","owner":"Brad"}},
@@ -325,35 +281,30 @@ in the logs when you ran the script:	@@ -325,35 +281,30 @@ in the logs when you ran the script:
{"Key":"CAR9", "Record":{"make":"Holden","model":"Barina","colour":"brown","owner":"Shotaro"}}]	{"Key":"CAR9", "Record":{"make":"Holden","model":"Barina","colour":"brown","owner":"Shotaro"}}]
Chaincodes are invoked when a network member wants to transfer or change an asset on the ledger.	チェーンコードは、ネットワークメンバーが台帳の資産を譲渡または変更するときに呼び出されます。
Use the following command to change the owner of a car on the ledger by invoking the fabcar chaincode:	次のコマンドを使用して、fabcarチェーンコードを呼び出して台帳上の車の所有者を変更します:
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n fabcar --peerAddresses localhost:7051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '{"function":"changeCarOwner","Args":["CAR9","Dave"]}'	peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n fabcar --peerAddresses localhost:7051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '{"function":"changeCarOwner","Args":["CAR9","Dave"]}'
If the command is successful, you should see the following response:	このコマンドが成功した場合、以下の応答を確認できると思います:
2019-12-04 17:38:21.048 EST [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 001 Chaincode invoke successful.	2019-12-04 17:38:21.048 EST [chaincodeCmd] chaincodeInvokeOrQuery -> INFO 001 Chaincode invoke successful.
result: status:200	result: status:200
Note: If you deployed the Java chaincode, run the invoke command with the following arguments instead:	注: Javaチェーンコードをデプロイした場合には、上記の代わりに次の引数を指定してinvokeコマンドを実行してください：
`'{"function":"changeCarOwner","Args":["CAR009","Dave"]}'`	`'{"function":"changeCarOwner","Args":["CAR009","Dave"]}'`
The Fabcar chaincode written in Java uses a different index than the chaincode written in Javascipt or Go.	Javaで記述されたfabcarチェーンコードは、JavaScriptまたはGoで記述されたチェーンコードとは異なるインデックスを使用します。
Because the endorsement policy for the fabcar chaincode requires the transaction to be signed by Org1 and Org2, the chaincode invoke command needs to target both `peer0.org1.example.com` and `peer0.org2.example.com` using the `--peerAddresses` flag.	fabcarチェーンコードのエンドースメントポリシーでは、トランザクションがOrg1とOrg2によって署名される必要があるため、chaincode invokeコマンドは、 `--peerAddresses` フラグを用いて `peer0.org1.example.com` と `peer0.org2.example.com` の両方をターゲットにする必要があります。
Because TLS is enabled for the network, the command also needs to reference the TLS certificate for each peer using the `--tlsRootCertFiles` flag.	ネットワークに対してTLSが有効になっているため、本コマンドは `--tlsRootCertFiles` フラグを使用して各ピアのTLS証明書も参照する必要があります。
After we invoke the chaincode, we can use another query to see how the invoke changed the assets on the blockchain ledger.	チェーンコードを呼び出した後、別のクエリを使用して、呼び出しによってブロックチェーン台帳上のアセットがどのように変更されたかを確認できます。
Since we already queried the Org1 peer, we can take this opportunity to query the chaincode running on the Org2 peer.	すでにOrg1のピアにクエリを実行しているので、この機会にOrg2のピアで動いているチェーンコードをクエリしてみます。
Set the following environment variables to operate as Org2:	Org2として動作するように、次のように環境変数を設定します:
Environment variables for Org2	Org2用の環境変数
export CORE_PEER_TLS_ENABLED=true	export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org2MSP"	export CORE_PEER_LOCALMSPID="Org2MSP"
@@ -362,64 +313,53 @@ export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.examp	@@ -362,64 +313,53 @@ export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.examp
export CORE_PEER_ADDRESS=localhost:9051	export CORE_PEER_ADDRESS=localhost:9051
You can now query the fabcar chaincode running on `peer0.org2.example.com`:	ここで、`peer0.org2.example.com`上で動いているfabcarチェーンコードにクエリします:
peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryCar","CAR9"]}'	peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryCar","CAR9"]}'
The result will show that `"CAR9"` was transferred to Dave:	結果は`"CAR9"`がDaveに譲渡されたことを示します:
{"make":"Holden","model":"Barina","colour":"brown","owner":"Dave"}	{"make":"Holden","model":"Barina","colour":"brown","owner":"Dave"}
When you are finished using the test network, you can bring down the network with the following command:	テストネットワークの使用が終了したら、次のコマンドを使用してネットワークを停止できます:
./network.sh down	./network.sh down
The command will stop and remove the node and chaincode containers, delete the organization crypto material, and remove the chaincode images from your Docker Registry.	このコマンドは、ノードとチェーンコードのコンテナを停止して削除し、組織の暗号マテリアルを削除し、Dockerレジストリからチェーンコードイメージを削除します。
The command also removes the channel artifacts and docker volumes from previous runs, allowing you to run `./network.sh up` again if you encountered any problems.	このコマンドは、以前に実行したときのチャネルアーティファクトとDockerボリュームも削除し、何か問題が発生した場合に`./network.sh up`を再度実行できるようにします。
Now that you have used the test network to deploy Hyperledger Fabric on your local machine, you can use the tutorials to start developing your own solution:	ここまでで、テストネットワークを使用してHyperledgerFabricをローカルマシンにデプロイしたので、チュートリアルを使用してあなた自身のソリューションの開発を開始できます:
Learn how to deploy your own smart contracts to the test network using the [Deploying a smart contract to a channel](deploy_chaincode.html) tutorial.	[スマートコントラクトをチャネルにデプロイする](deploy_chaincode.html) チュートリアルを使用して、あなた自身のスマートコントラクトをテストネットワークにデプロイする方法を学びます。
Visit the [Writing Your First Application](write_first_app.html) tutorial to learn how to use the APIs provided by the Fabric SDKs to invoke smart contracts from your client applications.	[最初のアプリケーションの作成](write_first_app.html) チュートリアルにアクセスして、Fabric SDKが提供するAPIを使用して、クライアントアプリケーションからスマートコントラクトを呼び出す方法を学習してください。
If you are ready to deploy a more complicated smart contract to the network, follow the [commercial paper tutorial](tutorial/commercial_paper.html) to explore a use case in which two organizations use a blockchain network to trade commercial paper.	より複雑なスマートコントラクトをネットワークにデプロイする準備ができている場合は、[コマーシャルペーパーチュートリアル](tutorial/commercial_paper.html)に従って、2つの組織がブロックチェーンネットワークを使用してコマーシャルペーパーを取引するユースケースを探索してください。
You can find the complete list of Fabric tutorials on the [tutorials](tutorials.html) page.	Fabricのチュートリアルの完全なリストは、[チュートリアル](tutorials.html) ページにあります。
Hyperledger Fabric uses public key infrastructure (PKI) to verify the actions of all network participants.	Hyperledger Fabricは、公開鍵基盤 (Public Key Infrastructure, PKI) を使用して、すべてのネットワーク参加者のアクションを検証します。
Every node, network administrator, and user submitting transactions needs to have a public certificate and private key to verify their identity.	トランザクションを送信するすべてのノード、ネットワーク管理者、およびユーザーは、アイデンティティを検証するために公開証明書と秘密鍵を持っている必要があります。
These identities need to have a valid root of trust, establishing that the certificates were issued by an organization that is a member of the network.	これらのアイデンティティには、証明書がネットワークのメンバーである組織によって発行されたことを証明する、有効な信頼のルートが必要です。
The `network.sh` script creates all of the cryptographic material that is required to deploy and operate the network before it creates the peer and ordering nodes.	`network.sh`スクリプトは、ピアノードとオーダリングノードを作成する前に、ネットワークをデプロイして運用するために必要なすべての暗号マテリアルを作成します。
By default, the script uses the cryptogen tool to create the certificates and keys.	デフォルトでは、本スクリプトはcryptogenツールを使用して証明書と鍵を作成します。
The tool is provided for development and testing, and can quickly create the required crypto material for Fabric organizations with a valid root of trust.	このツールは開発およびテスト用に提供されており、有効な信頼のルートを持つFabricの組織に必要な暗号マテリアルをすばやく作成できます。
When you run `./network.sh up`, you can see the cryptogen tool creating the certificates and keys for Org1, Org2, and the Orderer Org.	`./network.sh up`を実行すると、cryptogenツールがOrg1、Org2、およびOrderer Orgの証明書と鍵を作成していることがわかります。
However, the test network script also provides the option to bring up the network using Certificate Authorities (CAs).	ただし、テストネットワークのスクリプトには、認証局 (CA) を使用してネットワークを起動するオプションもあります。
In a production network, each organization operates a CA (or multiple intermediate CAs) that creates the identities that belong to their organization.	本番用ネットワークでは、各組織は、組織に属するアイデンティティを作成するCA (または複数の中間CA) を運用します。
All of the identities created by a CA run by the organization share the same root of trust.	組織が運用する1つのCAが作成したすべてのアイデンティティは、同じ信頼のルートを共有します。
Although it takes more time than using cryptogen, bringing up the test network using CAs provides an introduction to how a network is deployed in production.	cryptogenを使用するよりも時間がかかりますが、CAを使用してテストネットワークを立ち上げると、ネットワークが本番環境にどのようにデプロイされるかがわかります。
Deploying CAs also allows you to enroll client identities with the Fabric SDKs and create a certificate and private key for your applications.	CAをデプロイすると、クライアントのアイデンティティをFabric SDKに登録し、アプリケーションの証明書と秘密鍵を作成することもできます。
If you would like to bring up a network using Fabric CAs, first run the following command to bring down any running networks:	Fabric CAを使用してネットワークを立ち上げたい場合は、まず以下のコマンドを実行して、実行中のネットワークをすべて停止させます:
./network.sh down	./network.sh down
You can then bring up the network with the CA flag:	そうすれば、CAフラグのついたネットワークを立ち上げることができます:
./network.sh up -ca	./network.sh up -ca
After you issue the command, you can see the script bringing up three CAs, one for each organization in the network.	このコマンドを発行すると、ネットワーク内の組織ごとに1つずつ、合計3つのCAが表示されることが確認できます。
It is worth taking time to examine the logs generated by the `./network.sh` script after the CAs have been deployed.	CAがデプロイされた後、`./network.sh`スクリプトによって生成されたログを調べるのに時間をかける価値があります。
The test network uses the Fabric CA client to register node and user identities with the CA of each organization.	テストネットワークは、Fabric CAクライアントを使用して、ノードとユーザーのアイデンティティを各組織のCAに登録します。
The script then uses the enroll command to generate an MSP folder for each identity.	次に、スクリプトはenrollコマンドを使用して、アイデンティティごとにMSPフォルダを生成します。
The MSP folder contains the certificate and private key for each identity, and establishes the identity's role and membership in the organization that operated the CA.	MSPフォルダには、各アイデンティティの証明書と秘密鍵が含まれており、CAを運用していた組織におけるアイデンティティの役割とメンバーシップを確立します。
You can use the following command to examine the MSP folder of the Org1 admin user:	次のコマンドを使用して、Org1の管理者ユーザーのMSPフォルダを調べることができます:
tree organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/	tree organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/
The command will reveal the MSP folder structure and configuration file:	このコマンドは、MSPフォルダの構造と設定ファイルを表示します:
You can find the certificate of the admin user in the `signcerts` folder and the private key in the `keystore` folder.	管理者ユーザーの証明書は`signcerts`フォルダにあり、秘密鍵は`keystore`フォルダにあります。
To learn more about MSPs, see the [Membership Service Provider](membership/membership.html) concept topic.	MSPの詳細については、[メンバーシップサービスプロバイダ](membership/membership.html) のコンセプトトピックを参照してください。
Both cryptogen and the Fabric CAs generate the cryptographic material for each organization in the `organizations` folder.	cryptogenとFabric CAの両方が、`organizations`フォルダ内に各組織の暗号マテリアルを生成します。
You can find the commands that are used to set up the network in the `registerEnroll.sh` script in the `organizations/fabric-ca` directory.	ネットワークのセットアップに使用されるコマンドは、 `organizations/fabric-ca` ディレクトリの `registerEnroll.sh` スクリプト内にあります。
To learn more about how you would use the Fabric CA to deploy a Fabric network, visit the [Fabric CA operations guide](https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html).	Fabric CAを使用してFabricネットワークをデプロイする方法の詳細については、[Fabric CA運用ガイド](https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html) にアクセスしてください。
You can learn more about how Fabric uses PKI by visiting the [identity](identity/identity.html) and [membership](membership/membership.html) concept topics.	[アイデンティティ](identity/identity.html) および[メンバーシップ](membership/membership.html) のコンセプトトピックにアクセスすると、FabricがPKIをどのように使用するかについて詳しく知ることができます。
If you are interested in learning more about the sample network, you can investigate the files and scripts in the `test-network` directory.	サンプルネットワークについて詳しく知りたい場合は、`test-network`ディレクトリにあるファイルとスクリプトを調べることができます。
The steps below provide a guided tour of what happens when you issue the command of `./network.sh up`.	以下の手順は、`./network.sh up`のコマンドを発行したときに何が起こるかについてのガイド付きツアーを提供します。
`./network.sh` creates the certificates and keys for two peer organizations and the orderer organization.	`./network.sh` は、2つのピア組織とOrderer組織の証明書と鍵を作成します。
By default, the script uses the cryptogen tool using the configuration files located in the `organizations/cryptogen` folder.	デフォルトでは、スクリプトは `organizations/cryptogen` フォルダにある設定ファイルを用いてcryptogenツールを使用します。
If you use the `-ca` flag to create Certificate Authorities, the script uses Fabric CA server configuration files and `registerEnroll.sh` script located in the `organizations/fabric-ca` folder.	`-ca`フラグを使用して認証局を作成する場合、本スクリプトは `organizations/fabric-ca` フォルダにあるFabric CAサーバーの設定ファイルと `registerEnroll.sh` スクリプトを使用します。
Both cryptogen and the Fabric CAs create the crypto material and MSP folders for all three organizations in the `organizations` folder.	cryptogenとFabric CAの両方とも、`organizations`フォルダ内に3つの組織すべての暗号マテリアルとMSPフォルダを作成します。
The script uses configtxgen tool to create the system channel genesis block.	本スクリプトはconfigtxgenツールを使用して、システムチャネルジェネシスブロックを作成します。
Configtxgen consumes the `TwoOrgsOrdererGenesis`  channel profile in the `configtx/configtx.yaml` file to create the genesis block.	configtxgenは `configtx/configtx.yaml` ファイルの `configtx/configtx.yaml` チャネルプロファイルを使用して、ジェネシスブロックを作成します。
The block is stored in the `system-genesis-block` folder.	このブロックは `system-genesis-block` フォルダに保存されます。
Once the organization crypto material and the system channel genesis block have been generated, the `network.sh` can bring up the nodes of the network.	組織の暗号マテリアルとシステムチャネルジェネシスブロックが生成されると、`network.sh`はネットワークのノードを起動できます。
The script uses the ``docker-compose-test-net.yaml`` file in the `docker` folder to create the peer and orderer nodes.	本スクリプトは、`docker` フォルダ内の ``docker-compose-test-net.yaml`` ファイルを使用して、ピアノードとOrdererノードを作成します。
The `docker` folder also contains the ``docker-compose-e2e.yaml`` file that brings up the nodes of the network alongside three Fabric CAs.	`docker` フォルダには、3つのFabric CAとともにネットワークのノードを起動する ``docker-compose-e2e.yaml`` ファイルも含まれています。
This file is meant to be used to run end-to-end tests by the Fabric SDK.	このファイルは、Fabric SDKによるエンドツーエンドのテストを実行するために使用することを目的としています。
Refer to the [Node SDK](https://github.com/hyperledger/fabric-sdk-node) repo for details on running these tests.	これらのテストの実行の詳細については、[Node SDK](https://github.com/hyperledger/fabric-sdk-node) リポジトリを参照してください。
If you use the `createChannel` subcommand, `./network.sh` runs the `createChannel.sh` script in the `scripts` folder to create a channel using the supplied channel name.	`createChannel` サブコマンドを使用する場合、 `./network.sh` は `scripts` フォルダー内の `createChannel.sh` スクリプトを実行して、指定されたチャネル名を使用してチャネルを作成します。
The script uses the `configtx.yaml` file to create the channel creation transaction, as well as two anchor peer update transactions.	このスクリプトは `configtx.yaml` ファイルを使用して、チャネル作成トランザクションと2つのアンカーピア更新トランザクションを作成します。
The script uses the peer cli to create the channel, join ``peer0.org1.example.com`` and ``peer0.org2.example.com`` to the channel, and make both of the peers anchor peers.	スクリプトはピア CLIを使用してチャネルを作成し、 ``peer0.org1.example.com`` と ``peer0.org2.example.com`` をチャネルに参加させ、両方のピアをアンカーピアにします。
If you issue the `deployCC` command, `./network.sh` runs the ``deployCC.sh`` script to install the fabcar chaincode on both peers and then define then chaincode on the channel.	`deployCC` コマンドを発行すると、`./network.sh` は ``deployCC.sh`` スクリプトを実行して両方のピアに fabcar チェーンコードをインストールし、チャネルにチェーンコードを定義します。
Once the chaincode definition is committed to the channel, the peer cli initializes the chaincode using the `Init` and invokes the chaincode to put initial data on the ledger.	チェーンコード定義がチャネルにコミットされると、ピア CLIは `Init` を使用してチェーンコードを初期化し、チェーンコードを呼び出して初期データを台帳に格納します。
If you have any problems with the tutorial, review the following:	チュートリアルで問題が発生した場合は、以下を確認してください:
You should always start your network fresh.	ネットワークは常に新しく開始する必要があります。
You can use the following command to remove the artifacts, crypto material, containers, volumes, and chaincode images from previous runs:	次のコマンドを使用して、過去の実行におけるアーティファクト、暗号マテリアル、コンテナ、Dockerボリューム、およびチェーンコードイメージを削除できます:
./network.sh down	./network.sh down
You will see errors if you do not remove old containers, images, and volumes.	古いコンテナ、イメージ、およびボリュームを削除しないと、エラーが発生します。
If you see Docker errors, first check your Docker version ([Prerequisites](prereqs.html)), and then try restarting your Docker process.	Dockerエラーが表示された場合は、まずDockerのバージョン ([前提条件](prereqs.html)) を確認してから、Dockerプロセスを再起動してみてください。
Problems with Docker are oftentimes not immediately recognizable.	Dockerの問題は、すぐにはわからないことが多いです。
For example, you may see errors that are the result of your node not being able to access the crypto material mounted within a container.	例えば、ノードがコンテナ内にマウントされた暗号マテリアルにアクセスできないことが原因で発生するエラーが表示される場合があります。
If problems persist, you can remove your images and start from scratch:	問題が解決しない場合は、以下の通りイメージを削除して一からやり直すことができます:
docker rm -f $(docker ps -aq)	docker rm -f $(docker ps -aq)
docker rmi -f $(docker images -q)	docker rmi -f $(docker images -q)
If you see errors on your create, approve, commit, invoke or query commands, make sure you have properly updated the channel name and chaincode name.	もし、生成 (create)、承認 (approve)、コミット (commit)、呼び出し (invoke)、または参照 (query) コマンドでエラーが発生した場合は、チャネル名とチェーンコード名が適切に更新されていることを確認してください。
There are placeholder values in the supplied sample commands.	提供されているサンプルコマンドには、プレースホルダー値があります。
If you see the error below:	以下のエラーが表示された場合:
Error: Error endorsing chaincode: rpc error: code = 2 desc = Error installing chaincode code mycc:1.0(chaincode /var/hyperledger/production/chaincodes/mycc.1.0 exits)	Error: Error endorsing chaincode: rpc error: code = 2 desc = Error installing chaincode code mycc:1.0(chaincode /var/hyperledger/production/chaincodes/mycc.1.0 exits)
You likely have chaincode images (e.g. ``dev-peer1.org2.example.com-fabcar-1.0`` or ``dev-peer0.org1.example.com-fabcar-1.0``) from prior runs.	前回の実行におけるチェーンコードイメージ (例: ``dev-peer1.org2.example.com-fabcar-1.0`` や ``dev-peer0.org1.example.com-fabcar-1.0``）が残っている可能性があります。
Remove them and try again.	それらを削除して、再試行してください。
docker rmi -f $(docker images | grep dev-peer[0-9] | awk '{print $3}')	docker rmi -f $(docker images | grep dev-peer[0-9] | awk '{print $3}')
If you see the below error:	以下のエラーが表示された場合:
Then you did not set the ``FABRIC_CFG_PATH`` environment variable properly.	``FABRIC_CFG_PATH`` 環境変数が適切に設定できていません。
The configtxgen tool needs this variable in order to locate the configtx.yaml.	configtxgenツールは、 configtx.yaml を見つけるためにこの環境変数を必要とします。
Go back and execute an ``export FABRIC_CFG_PATH=$PWD/configtx/configtx.yaml``, then recreate your channel artifacts.	戻って ``export FABRIC_CFG_PATH=$PWD/configtx/configtx.yaml`` を実行してから、チャネルアーティファクトを再作成してください。
If you see an error stating that you still have "active endpoints", then prune your Docker networks.	「アクティブなエンドポイント (active endpoints)」がまだあることを示すエラーが表示された場合は、Dockerネットワークを削除 (prune) します。
This will wipe your previous networks and start you with a fresh environment:	これにより、前回のネットワークが消去され、新しい環境で開始されるようになります:
docker network prune	docker network prune
You will see the following message:	次のメッセージが表示されたら:
WARNING! This will remove all networks not used by at least one container. Are you sure you want to continue? [y/N]	WARNING! This will remove all networks not used by at least one container. Are you sure you want to continue? [y/N]
Select ``y``.	``y``を選んでください。
If you see an error similar to the following:	以下に似たエラーが表示された場合:
/bin/bash: ./scripts/createChannel.sh: /bin/bash^M: bad interpreter:	/bin/bash: ./scripts/createChannel.sh: /bin/bash^M: bad interpreter: No such file or directory
No such file or directory Ensure that the file in question (createChannel.sh in this example) is encoded in the Unix format.	問題のファイル (この例では createChannel.sh) がUnix形式でエンコードされていることを確認してください。
This was most likely caused by not setting ``core.autocrlf`` to ``false`` in your Git configuration (see [Windows extras](prereqs.html#windows-extras)).	これは、Gitの設定で ``core.autocrlf`` を ``false`` に設定していないことが原因である可能性があります ([Windows extras](prereqs.html#windows-extras) 参照)。
There are several ways of fixing this.	これを修正する方法はいくつかあります。
If you have access to the vim editor for instance, open the file:	例えば、Vimエディタにアクセスできる場合は、次のファイルを開きます:
vim ./fabric-samples/test-network/scripts/createChannel.sh	vim ./fabric-samples/test-network/scripts/createChannel.sh
Then change its format by executing the following vim command:	開いたら次のVimコマンドを実行してフォーマットを変更します:
:set ff=unix	:set ff=unix
If your orderer exits upon creation or if you see that the create channel command fails due to an inability to connect to your ordering service, use the `docker logs` command to read the logs from the ordering node.	Ordererが作成時に終了したり、またはオーダリングサービスに接続できないために create channel コマンドが失敗した場合は、`docker logs` コマンドを使用してOrdererノードのログを読み取ってください。
You may see the following message:	以下のようなメッセージが表示されるかもしれません:
PANI 007 [channel system-channel] config requires unsupported orderer capabilities: Orderer capability V2_0 is required but not supported: Orderer capability V2_0 is required but not supported	PANI 007 [channel system-channel] config requires unsupported orderer capabilities: Orderer capability V2_0 is required but not supported: Orderer capability V2_0 is required but not supported
This occurs when you are trying to run the network using Fabric version 1.4.x docker images.	これは、Fabricのバージョン1.4.xのdockerイメージを使用してネットワークを実行しようとしたときに発生します。
The test network needs to run using Fabric version 2.x.	テストネットワークは Fabricのバージョン2.xを使用して実行する必要があります。
If you continue to see errors, share your logs on the fabric-questions channel on [Hyperledger Rocket Chat](https://chat.hyperledger.org/home) or on [StackOverflow](https://stackoverflow.com/questions/tagged/hyperledger-fabric).	引き続きエラーが発生する場合には、 [Hyperledger Rocket Chat](https://chat.hyperledger.org/home) または [StackOverflow](https://stackoverflow.com/questions/tagged/hyperledger-fabric) の fabric-questions チャネルでログを共有してください。
Peers	ピア
A blockchain network is comprised primarily of a set of peer nodes (or, simply, peers).	ブロックチェーンネットワークは、主にピアノード(または単にピア)のセットで構成されます。
Peers are a fundamental element of the network because they host ledgers and smart contracts.	ピアは、台帳とスマートコントラクトをホストするため、ネットワークの基本的な要素です。
Recall that a ledger immutably records all the transactions generated by smart contracts (which in Hyperledger Fabric are contained in a chaincode, more on this later).	台帳はスマートコントラクトによって生成されたすべてのトランザクションをイミュータブルに記録することを思い出してください(スマートコントラクトは、Hyperledger Fabricではチェーンコードに含まれていますが、これについては後で詳しく説明します)。
Smart contracts and ledgers are used to encapsulate the shared processes and shared information in a network, respectively.	スマートコントラクトと台帳は、それぞれ、ネットワーク内の共有プロセスと共有情報をカプセル化するために使用されます。
These aspects of a peer make them a good starting point to understand a Fabric network.	ピアのこれらの側面は、Fabricネットワークを理解するための良い出発点となります。
Other elements of the blockchain network are of course important: ledgers and smart contracts, orderers, policies, channels, applications, organizations, identities, and membership, and you can read more about them in their own dedicated sections.	ブロックチェーンネットワークのその他の要素は、もちろん重要です。台帳とスマートコントラクト、orderer、ポリシー、チャネル、アプリケーション、組織、アイデンティティ、メンバーシップなどです。これらについては、それぞれの専用セクションで詳しく説明しています。
This section focusses on peers, and their relationship to those other elements in a Fabric network.	このセクションでは、ピアと、Fabricネットワーク内の他の要素との関係に焦点を当てます。
A blockchain network is comprised of peer nodes, each of which can hold copies of ledgers and copies of smart contracts.	ブロックチェーンネットワークはピアノードで構成され、各ノードは台帳のコピーとスマートコントラクトのコピーを保持できます。
In this example, the network N consists of peers P1, P2 and P3, each of which maintain their own instance of the distributed ledger L1.	この例では、ネットワークNはピアP1、P2およびP3から構成され、それぞれが分散台帳L1の独自のインスタンスを維持します。
P1, P2 and P3 use the same chaincode, S1, to access their copy of that distributed ledger.	P1、P2およびP3は、同じチェーンコード、S1を使用して、分散台帳のコピーにアクセスします。
Peers can be created, started, stopped, reconfigured, and even deleted.	ピアの作成、開始、停止、再構成、さらには削除が可能です。
They expose a set of APIs that enable administrators and applications to interact with the services that they provide.	ピアは提供するサービスと管理者とアプリケーションが対話できるようにする一連のAPIを公開します。
We'll learn more about these services in this section.	このセクションでは、これらのサービスについて詳しく説明します。
A word on terminology	用語
Fabric implements smart contracts with a technology concept it calls chaincode --- simply a piece of code that accesses the ledger, written in one of the supported programming languages.	Fabricは、チェーンコードと呼ばれる技術コンセプトを用いて、スマートコントラクトを実装しています。チェーンコードはサポートプログラム言語の１つで書かれた台帳にアクセスするコードに過ぎません。
In this topic, we'll usually use the term chaincode, but feel free to read it as smart contract if you're more used to that term.	このトピックでは通常、チェーンコードという用語を使用しますが、スマートコントラクトに慣れている場合は、そちらの用語で読んでも構いません。
It's the same thing!	それは同じことです!
If you want to learn more about chaincode and smart contracts, check out our [documentation on smart contracts and chaincode](../smartcontract/smartcontract.html).	チェーンコードとスマートコントラクトの詳細については、[スマートコントラクトとチェーンコードに関する我々のドキュメント](../smartcontract/smartcontract.html)を参照してください。
Ledgers and Chaincode	台帳とチェーンコード
Let's look at a peer in a little more detail.	ピアをもう少し詳しく見てみましょう。
We can see that it's the peer that hosts both the ledger and chaincode.	台帳とチェーンコードの両方をピアはホストすることがわかります。
More accurately, the peer actually hosts instances of the ledger, and instances of chaincode.	より正確には、ピアは実際に台帳のインスタンスとチェーンコードのインスタンスをホストします。
Note that this provides a deliberate redundancy in a Fabric network --- it avoids single points of failure.	これにより、Fabricネットワークに意図的な冗長性が提供され、単一障害点が回避されます。
We'll learn more about the distributed and decentralized nature of a blockchain network later in this section.	ブロックチェーンネットワークの分散型および非中央集権型の性質については、このセクションの後半で詳しく説明します。
A peer hosts instances of ledgers and instances of chaincodes.	ピアは、台帳のインスタンスとチェーンコードのインスタンスをホストします。
In this example, P1 hosts an instance of ledger L1 and an instance of chaincode S1.	この例では、P1は台帳L1のインスタンスとチェーンコードS1のインスタンスをホストします。
There can be many ledgers and chaincodes hosted on an individual peer.	個々のピアでホストされる台帳やチェーンコードが多数存在する場合があります。
Because a peer is a host for ledgers and chaincodes, applications and administrators must interact with a peer if they want to access these resources.	ピアは台帳およびチェーンコードのホストであるため、アプリケーションおよび管理者がこれらのリソースにアクセスする場合は、ピアと対話する必要があります。
That's why peers are considered the most fundamental building blocks of a Fabric network.	そのため、ピアはFabricネットワークの最も基本的な構成要素と見なされています。
When a peer is first created, it has neither ledgers nor chaincodes.	ピアが最初に作成されたときは、台帳もチェーンコードもありません。
We'll see later how ledgers get created, and how chaincodes get installed, on peers.	台帳がどのように作成され、チェーンコードがどのようにピアにインストールされるかについては、後で説明します。
Multiple Ledgers	複数台帳
A peer is able to host more than one ledger, which is helpful because it allows for a flexible system design.	ピアは複数の台帳をホストできます。これは、より柔軟なシステム設計を可能するために有用です。
The simplest configuration is for a peer to manage a single ledger, but it's absolutely appropriate for a peer to host two or more ledgers when required.	最も単純な構成は、ピアが1つの台帳を管理する場合ですが、必要に応じては、ピアが2つ以上の台帳をホストすることが最適です。
A peer hosting multiple ledgers.	複数の台帳をホストするピア。
Peers host one or more ledgers, and each ledger has zero or more chaincodes that apply to them.	ピアは1つ以上の台帳をホストし、各台帳には適用されるチェーンコードが0もしくはそれ以上の場合があります。
In this example, we can see that the peer P1 hosts ledgers L1 and L2.	この例では、ピアP1がL1とL2をホストしていることがわかります。
Ledger L1 is accessed using chaincode S1.	台帳L1には、チェーンコードS1を使用してアクセスします。
Ledger L2 on the other hand can be accessed using chaincodes S1 and S2.	一方、台帳L2には、チェーンコードS1およびS2を使用してアクセスできます。
Although it is perfectly possible for a peer to host a ledger instance without hosting any chaincodes which access that ledger, it's rare that peers are configured this way.	ピアが台帳にアクセスするチェーンコードをホストせずに台帳インスタンスをホストすることは完全に可能ですが、ピアがこのように構成されることはまれです。
The vast majority of peers will have at least one chaincode installed on it which can query or update the peer's ledger instances.	大多数のピアには、ピアの台帳インスタンスをクエリまたは更新できるチェーンコードが少なくとも1つインストールされています。
It's worth mentioning in passing that, whether or not users have installed chaincodes for use by external applications, peers also have special system chaincodes that are always present.	なお付随する情報として言及しておくべき情報として、ユーザーが外部アプリケーションで使用するためにチェーンコードをインストールしたかどうかにかかわらず、ピアには常に存在する特別なシステムチェーンコードもあります。
These are not discussed in detail in this topic.	これらについては、このトピックでは詳しく説明しません。
Multiple Chaincodes	複数のチェーンコード
There isn't a fixed relationship between the number of ledgers a peer has and the number of chaincodes that can access that ledger.	ピアが持つ台帳の数と、その台帳にアクセスできるチェーンコードの数との間には、一定の関係はありません。
A peer might have many chaincodes and many ledgers available to it.	ピアは、多くのチェーンコードと多くの台帳を使用できます。
An example of a peer hosting multiple chaincodes.	複数のチェーンコードをホストするピアの例。
Each ledger can have many chaincodes which access it.	各台帳は、それにアクセスするための多数のチェーンコードを有することができます。
In this example, we can see that peer P1 hosts ledgers L1 and L2, where L1 is accessed by chaincodes S1 and S2, and L2 is accessed by S1 and S3.	この例では、ピアP1が台帳L1およびL2をホストしています。L1はチェーンコードS1およびS2によってアクセスされ、L2はS1およびS3によってアクセスされています。
We can see that S1 can access both L1 and L2.	S1がL1とL2の両方にアクセスできることがわかります。
We'll see a little later why the concept of channels in Fabric is important when hosting multiple ledgers or multiple chaincodes on a peer.	複数の台帳や複数のチェーンコードをピアがホストする場合に、Fabricのチャネルの概念が重要である理由については、後ほど説明します。
Applications and Peers	アプリケーションとピア
We're now going to show how applications interact with peers to access the ledger.	次に、アプリケーションがピアと対話して台帳にアクセスする方法を説明します。
Ledger-query interactions involve a simple three-step dialogue between an application and a peer; ledger-update interactions are a little more involved, and require two extra steps.	台帳にクエリする場合の対話には、アプリケーションとピア間の単純な3ステップの対話が含まれます。台帳を更新する場合の対話はもう少し複雑で、2つの追加ステップが必要です。
We've simplified these steps a little to help you get started with Fabric, but don't worry --- what's most important to understand is the difference in application-peer interactions for ledger-query compared to ledger-update transaction styles.	これらの手順を少し簡略化して、Fabricの使用を開始できるようにしましたが、心配する必要はありません。最も重要な点は、トランザクションスタイルに関して、台帳を更新する場合と台帳にクエリする場合を比べた場合における、アプリケーションとピア間の対話の違いです。
Applications always connect to peers when they need to access ledgers and chaincodes.	アプリケーションは、台帳およびチェーンコードにアクセスする必要がある場合に、常にピアに接続します。
The Fabric Software Development Kit (SDK) makes this easy for programmers --- its APIs enable applications to connect to peers, invoke chaincodes to generate transactions, submit transactions to the network that will get ordered, validated and committed to the distributed ledger, and receive events when this process is complete.	Fabric Software Development Kit(SDK)を使用すると、プログラマはこれを簡単に行うことができます。APIを使用すると、アプリケーションはピアに接続し、チェーンコードを呼び出してトランザクションを生成し、トランザクションをネットワークに送信して、分散台帳に対して順序付け、検証、コミットされ、このプロセスが完了したときにイベントを受信できます。
Through a peer connection, applications can execute chaincodes to query or update a ledger.	アプリケーションは、ピア接続を介してチェーンコードを実行し、台帳のクエリまたは更新を実行できます。
The result of a ledger query transaction is returned immediately, whereas ledger updates involve a more complex interaction between applications, peers and orderers.	台帳クエリトランザクションの結果は即時に戻されますが、台帳の更新には、アプリケーション、ピアおよびorderer間のより複雑な対話が必要です。
Let's investigate this in a little more detail.	これについて、もう少し詳しく調べてみましょう。
Peers, in conjunction with orderers, ensure that the ledger is kept up-to-date on every peer.	ピアは、ordererとともに、すべてのピアで台帳が最新の状態に保たれるようにします。
In this example, application A connects to P1 and invokes chaincode S1 to query or update the ledger L1.	この例では、アプリケーションAがP1に接続し、チェーンコードS1を呼び出して台帳L1をクエリもしくは更新します。
P1 invokes S1 to generate a proposal response that contains a query result or a proposed ledger update.	P1はS1を呼び出して、クエリ結果または提案された台帳更新を含む提案応答を生成します。
Application A receives the proposal response and, for queries, the process is now complete.	アプリケーションAが提案応答を受信し、クエリの場合、プロセスはこれで完了です。
For updates, A builds a transaction from all of the responses, which it sends to O1 for ordering.	更新の場合、Aはすべての応答からトランザクションを構築し、ordererであるO1に送信します。
O1 collects transactions from across the network into blocks, and distributes these to all peers, including P1.	O1は、ネットワーク上のトランザクションをブロックに収集し、P1を含むすべてのピアに配信します。
P1 validates the transaction before committing to L1.	P1は、L1にコミットする前にトランザクションを検証します。
Once L1 is updated, P1 generates an event, received by A, to signify completion.	L1が更新されると、P1はAによって受信される完了を示すイベントを生成します。
A peer can return the results of a query to an application immediately since all of the information required to satisfy the query is in the peer's local copy of the ledger.	クエリを満たすために必要なすべての情報は、ピアのローカルにある台帳のコピーにあるため、ピアはクエリ結果をただちにアプリケーションに戻すことができます。
Peers never consult with other peers in order to respond to a query from an application.	ピアは、アプリケーションからのクエリに応答するために他のピアと協議することはありません。
Applications can, however, connect to one or more peers to issue a query; for example, to corroborate a result between multiple peers, or retrieve a more up-to-date result from a different peer if there's a suspicion that information might be out of date.	しかし、アプリケーションは1つ以上のピアに接続してクエリを発行できます。たとえば、複数のピア間で結果をまとめたり、情報が最新ではない可能性がある場合に別のピアから最新の結果を取得したりできます。
In the diagram, you can see that ledger query is a simple three-step process.	この図では、台帳へのクエリが単純な3ステップのプロセスであることがわかります。
An update transaction starts in the same way as a query transaction, but has two extra steps.	更新トランザクションは、クエリトランザクションと同じ方法で開始されますが、2つの追加ステップがあります。
Although ledger-updating applications also connect to peers to invoke a chaincode, unlike with ledger-querying applications, an individual peer cannot perform a ledger update at this time, because other peers must first agree to the change --- a process called consensus.	台帳更新アプリケーションはチェーンコードを起動するためにピアにも接続しますが、台帳クエリアプリケーションとは異なり、他のピアが最初に変更に同意する必要があるため(合意形成と呼ばれるプロセス)、個々のピアはこの時点で台帳更新を実行できません。
Therefore, peers return to the application a proposed update --- one that this peer would apply subject to other peers' prior agreement.	そのため、ピアは、提案された更新をアプリケーションに返します。この更新は、他のピアの事前の合意に従って、このピアが後に適用することになるものです。
The first extra step --- step four --- requires that applications send an appropriate set of matching proposed updates to the entire network of peers as a transaction for commitment to their respective ledgers.	最初の追加ステップ ---ステップ4--- では、アプリケーションが、それぞれの台帳にコミットするためのトランザクションとして、一致する提案済の更新の適切なセットをピアのネットワーク全体に送信する必要があります。
This is achieved by the application by using an orderer to package transactions into blocks, and distributing them to the entire network of peers, where they can be verified before being applied to each peer's local copy of the ledger.	これは、ordererを使用してトランザクションをブロックにパッケージ化し、それらをピアのネットワーク全体に配布することで実現され、これらのトランザクションは、各ピアの台帳のローカルコピーに適用される前に検証できます。
As this whole ordering processing takes some time to complete (seconds), the application is notified asynchronously, as shown in step five.	この順序付け処理全体が完了するまでに時間(数秒)がかかるため、ステップ5に示すように、アプリケーションは非同期で通知されます。
Later in this section, you'll learn more about the detailed nature of this ordering process --- and for a really detailed look at this process see the [Transaction Flow](../txflow.html) topic.	順序付けプロセスの詳細については、このセクションの後半で詳しく説明します。このプロセスの更なる詳細については、[トランザクションフロー](../txflow.html)のトピックを参照してください。
Peers and Channels	ピアとチャネル
Although this section is about peers rather than channels, it's worth spending a little time understanding how peers interact with each other, and with applications, via channels --- a mechanism by which a set of components within a blockchain network can communicate and transact privately.	このセクションでは、チャネルよりもピアについて説明しますが、ピアがどのように相互に、またチャネル(ブロックチェーン・ネットワーク内の一連のコンポーネントが個別に通信および処理できるメカニズム)を介してアプリケーションと相互作用するかを理解するために、少し時間をかける価値があります。
These components are typically peer nodes, orderer nodes and applications and, by joining a channel, they agree to collaborate to collectively share and manage identical copies of the ledger associated with that channel.	これらのコンポーネントは通常、ピアノード、ordererノード、およびアプリケーションであり、チャネルに参加することによって、そのチャネルに関連付けられた台帳の同一のコピーを共同で共有および管理することに同意します。
Conceptually, you can think of channels as being similar to groups of friends (though the members of a channel certainly don't need to be friends!).	概念的には、チャネルは友人のグループに似ていると考えることができます(ただし、チャネルのメンバーが友人である必要はありません)。
A person might have several groups of friends, with each group having activities they do together.	友人のグループが複数あって、それぞれのグループが一緒に活動する場合もあります。
These groups might be totally separate (a group of work friends as compared to a group of hobby friends), or there can be some crossover between them.	これらのグループは完全に独立しているか(趣味の友人のグループと仕事の友人のグループ)、あるいはそれらの間にいくらかの交流があり得ます。
Nevertheless, each group is its own entity, with "rules" of a kind.	それにもかかわらず、各グループは独自のエンティティであり、ある種の"規則"を持っています。
Channels allow a specific set of peers and applications to communicate with each other within a blockchain network.	チャネルを使用すると、特定のピアとアプリケーションのセットがブロックチェーンネットワーク内で相互に通信できます。
In this example, application A can communicate directly with peers P1 and P2 using channel C.	この例では、アプリケーションAは、チャネルCを使用してピアP1およびP2と直接通信できます。
You can think of the channel as a pathway for communications between particular applications and peers.	チャネルは、特定のアプリケーションとピア間の通信のためのパスと考えることができます。
For simplicity, orderers are not shown in this diagram, but must be present in a functioning network.	簡単にするために、この図ではordererは示されていませんが、機能しているネットワークに存在する必要があります。
We see that channels don't exist in the same way that peers do ---	チャネルはピアと同じようには存在しないことがわかります。
it's more appropriate to think of a channel as a logical structure that is formed by a collection of physical peers.	チャネルは、物理的なピアの集まりによって形成される論理構造と考える方が適切です。
It is vital to understand this point --- peers provide the control point for access to, and management of, channels.	この点を理解しておくことが重要です。ピアは、チャネルへのアクセスおよびチャネルの管理のための制御ポイントを提供します。
Peers and Organizations	ピアと組織
Now that you understand peers and their relationship to ledgers, chaincodes and channels, you'll be able to see how multiple organizations come together to form a blockchain network.	これで、ピアおよび、ピアと台帳、チェーンコード、チャネルとの関係が理解できたので、複数の組織がどのようにしてブロックチェーンネットワークを形成するかを確認できます。
Blockchain networks are administered by a collection of organizations rather than a single organization.	ブロックチェーンネットワークは、単一の組織ではなく、組織の集まりによって管理されます。
Peers are central to how this kind of distributed network is built because they are owned by --- and are the connection points to the network for --- these organizations.	この種の分散ネットワークを構築するには、ピアが中心となります。ピアは、これらの組織によって所有され、ネットワークへの接続ポイントとなるためです。
Peers in a blockchain network with multiple organizations.	複数の組織を持つブロックチェーンネットワーク内のピア。
The blockchain network is built up from the peers owned and contributed by the different organizations.	ブロックチェーンネットワークは、異なる組織によって所有され、提供されるピアから構築されます。
In this example, we see four organizations contributing eight peers to form a network.	この例では、4つの組織が8つのピアを提供してネットワークを形成しています。
The channel C connects five of these peers in the network N --- P1, P3, P5, P7 and P8.	チャネルCは、ネットワークNの5つのピア --- P1、P3、P5、P7、およびP8を接続します。
The other peers owned by these organizations have not been joined to this channel, but are typically joined to at least one other channel.	これらの組織が所有する他のピアは、このチャネルに参加していませんが、通常は少なくとも1つの他のチャネルに参加しています。
Applications that have been developed by a particular organization will connect to their own organization's peers as well as those of different organizations.	特定の組織によって開発されたアプリケーションは、異なる組織のピアだけでなく、その組織のピアにも接続されます。
Again, for simplicity, an orderer node is not shown in this diagram.	ここでも、簡単にするために、この図ではordererノードは示されていません。
It's really important that you can see what's happening in the formation of a blockchain network.	ブロックチェーンネットワークの形成過程で何が起きているかを知ることは非常に重要です。
The network is both formed and managed by the multiple organizations who contribute resources to it.	ネットワークは、リソースを提供する複数の組織によって形成および管理されます。
Peers are the resources that we're discussing in this topic, but the resources an organization provides are more than just peers.	ピアとは、このトピックで説明しているリソースですが、組織が提供するリソースはピアだけではありません。
There's a principle at work here --- the network literally does not exist without organizations contributing their individual resources to the collective network.	ここでは原理が働いています。ネットワークは組織が個々の資源を集合的なネットワークに貢献しなければ文字通り存在しません。
Moreover, the network grows and shrinks with the resources that are provided by these collaborating organizations.	さらに、ネットワークは、これらの協力する組織によって提供されるリソースとともに拡大および縮小します。
You can see that (other than the ordering service) there are no centralized resources --- in the [example above](#Peer8), the network, N, would not exist if the organizations did not contribute their peers.	(orderingサービス以外には)一元化されたリソースがないことがわかります。[上の例](#Peer8)では、組織がピアを提供しなければ、ネットワークNは存在しません。
This reflects the fact that the network does not exist in any meaningful sense unless and until organizations contribute the resources that form it.	これは、組織がネットワークを形成する資源を提供しない限り、また提供するまでは、ネットワークは意味のある状態で存在しないという事実を反映しています。
Moreover, the network does not depend on any individual organization --- it will continue to exist as long as one organization remains, no matter which other organizations may come and go.	さらに、ネットワークは個々の組織に依存するものではなく、他のどの組織が出入りしても、1つの組織が残っている限り存続します。
This is at the heart of what it means for a network to be decentralized.	これは、ネットワークが分散化されるということの核心になります。
Applications in different organizations, as in the [example above](#Peer8), may or may not be the same.	[上の例](#Peer8)のように、異なる組織のアプリケーションは同じであっても異なっていてもかまいません。
That's because it's entirely up to an organization as to how its applications process their peers' copies of the ledger.	これは、そのアプリケーションがピアの台帳のコピーをどのように処理するかは、完全に組織に依存するためです。
This means that both application and presentation logic may vary from organization to organization even though their respective peers host exactly the same ledger data.	つまり、アプリケーションと表現ロジックは、それぞれのピアがまったく同じ台帳データをホストしていても、組織によって異なる場合があります。
Applications connect either to peers in their organization, or peers in another organization, depending on the nature of the ledger interaction that's required.	アプリケーションは、必要な台帳相互作用の性質に応じて、組織内のピアまたは別の組織内のピアに接続します。
For ledger-query interactions, applications typically connect to their own organization's peers.	台帳クエリの相互作用の場合、アプリケーションは通常、独自の組織のピアに接続します。
For ledger-update interactions, we'll see later why applications need to connect to peers representing every organization that is required to endorse the ledger update.	台帳更新の相互作用については、台帳更新のエンドースに必要なすべての組織を代表するピアにアプリケーションを接続する必要がある理由を後で説明します。
Peers and Identity	ピアとアイデンティティ
Now that you've seen how peers from different organizations come together to form a blockchain network, it's worth spending a few moments understanding how peers get assigned to organizations by their administrators.	これまで、異なる組織のピアがブロックチェーンネットワークを形成する方法を見てきました。ここでは、ピアがどのようにして管理者によって組織に割り当てられるかについて、少し説明します。
Peers have an identity assigned to them via a digital certificate from a particular certificate authority.	ピアには、特定の認証局からのデジタル証明書を介して割り当てられたアイデンティティがあります。
You can read lots more about how X.509 digital certificates work elsewhere in this guide but, for now, think of a digital certificate as being like an ID card that provides lots of verifiable information about a peer.	X.509デジタル証明書がどのように機能するかについては、このガイドの別の箇所で詳しく説明していますが、ここでは、デジタル証明書は、ピアに関する多くの検証可能な情報を提供するIDカードのようなものと考えてください。
Each and every peer in the network is assigned a digital certificate by an administrator from its owning organization.	ネットワーク内のすべてのピアには、所有する組織の管理者によってデジタル証明書が割り当てられます。
When a peer connects to a channel, its digital certificate identifies its owning organization via a channel MSP.	ピアがチャネルに接続すると、そのデジタル証明書によってチャネルMSPを介して所有組織が識別されます。
In this example, P1 and P2 have identities issued by CA1.	この例では、P1とP2はCA1によって発行されたアイデンティティを持っています。
Channel C determines from a policy in its channel configuration that identities from CA1 should be associated with Org1 using ORG1.MSP.	チャネルCは、チャネル設定のポリシーから、CA1のアイデンティティをORG1.MSPを使用してORG1に関連付ける必要があると判断します。
Similarly, P3 and P4 are identified by ORG2.MSP as being part of Org2.	同様に、P3およびP4は、ORG2.MSPによって、ORG2の一部として識別されます。
Whenever a peer connects using a channel to a blockchain network, a policy in the channel configuration uses the peer's identity to determine its rights.	ピアがチャネルを使用してブロックチェーンネットワークに接続するたびに、チャネル設定のポリシーはピアのアイデンティティを使用してその権限を決定します。
The mapping of identity to organization is provided by a component called a Membership Service Provider (MSP) --- it determines how a peer gets assigned to a specific role in a particular organization and accordingly gains appropriate access to blockchain resources.	組織へのアイデンティティのマッピングは、メンバーシップサービスプロバイダー(MSP)と呼ばれるコンポーネントによって提供されます。MSPは、ピアが特定の組織内の特定のロールに割り当てられる方法を決定し、それに応じてブロックチェーンリソースへの適切なアクセスを取得します。
Moreover, a peer can be owned only by a single organization, and is therefore associated with a single MSP.	さらに、ピアは1つの組織のみが所有できるため、1つのMSPに関連付けられます。
We'll learn more about peer access control later in this section, and there's an entire section on MSPs and access control policies elsewhere in this guide.	ピアアクセスコントロールの詳細については、このセクションの後半で説明します。また、MSPとアクセスコントロールポリシーについては、このガイドの別の箇所で詳しく説明します。
But for now, think of an MSP as providing linkage between an individual identity and a particular organizational role in a blockchain network.	しかし今のところ、MSPは、ブロックチェーン・ネットワークにおける個々のアイデンティティと特定の組織的役割との間の結び付きを提供するものと考えてください。
To digress for a moment, peers as well as everything that interacts with a blockchain network acquire their organizational identity from their digital certificate and an MSP.	少し話を進めると、ブロックチェーンネットワークと相互作用するすべてのものと同様に、ピアはデジタル証明書とMSPから組織的なアイデンティティを取得します。
Peers, applications, end users, administrators and orderers must have an identity and an associated MSP if they want to interact with a blockchain network.	ピア、アプリケーション、エンドユーザ、管理者、ordererがブロックチェーンネットワークと対話する場合は、アイデンティティと関連するMSPが必要です。
We give a name to every entity that interacts with a blockchain network using an identity --- a principal.	アイデンティティを使用してブロックチェーンネットワークと対話するすべてのエンティティについてプリンシパルと名前を付けます。
You can learn lots more about principals and organizations elsewhere in this guide, but for now you know more than enough to continue your understanding of peers!	本書の他の箇所では、プリンシパルと組織についてさらに多くのことを学ぶことができますが、今のところは、ピアについての理解を深めるのに十分な知識があります!
Finally, note that it's not really important where the peer is physically located ---	最後に、ピアが物理的にどこにあるかは重要ではないことに注意してください。
it could reside in the cloud, or in a data centre owned by one of the organizations, or on a local machine ---	ピアは、クラウド内にある場合もあれば、いずれかの組織が所有するデータセンターにある場合もあります。また、ローカルマシン上にある場合もあります。
it's the digital certificate associated with it that identifies it as being owned by a particular organization.	ピアに関連付けられたデジタル証明書によって、特定の組織が所有していることが識別されます。
In our example above, P3 could be hosted in Org1's data center, but as long as the digital certificate associated with it is issued by CA2, then it's owned by Org2.	上記の例では、P3を組織1のデータセンターでホストできますが、関連付けられたデジタル証明書がCA2によって発行されていれば、組織2が所有しています。
Peers and Orderers	ピアとorderer
We've seen that peers form the basis for a blockchain network, hosting ledgers and smart contracts which can be queried and updated by peer-connected applications.	これまで見てきたように、ピアはブロックチェーンネットワークの基盤を形成し、ピアに接続されたアプリケーションによってクエリおよび更新される台帳やスマートコントラクトをホストします。
However, the mechanism by which applications and peers interact with each other to ensure that every peer's ledger is kept consistent with each other is mediated by special nodes called orderers, and it's to these nodes we now turn our attention.	しかし、アプリケーションとピアが相互作用して、すべてのピアの台帳が相互に一貫性を保つようにするメカニズムは、ordererと呼ばれる特殊なノードによって仲介され、これらのノードに着目していきます。
An update transaction is quite different from a query transaction because a single peer cannot, on its own, update the ledger --- updating requires the consent of other peers in the network.	更新トランザクションは、単一のピアだけでは台帳を更新できないため、クエリートランザクションとはまったく異なります。更新には、ネットワーク内の他のピアの同意が必要です。
A peer requires other peers in the network to approve a ledger update before it can be applied to a peer's local ledger.	ピアは、ピアのローカル台帳に適用する前に、ネットワーク内の他のピアが台帳更新を承認する必要があります。
This process is called consensus, which takes much longer to complete than a simple query.	このプロセスは合意形成と呼ばれ、単純なクエリよりも完了に時間がかかります。
But when all the peers required to approve the transaction    do so, and the transaction is committed to the ledger, peers will notify their connected applications that the ledger has been updated.	ただし、トランザクションを承認する必要があるすべてのピアが承認し、トランザクションが台帳にコミットされると、ピアは台帳が更新されたことを接続アプリケーションに通知します。
You're about to be shown a lot more detail about how peers and orderers manage the consensus process in this section.	このセクションでは、ピアやordererが合意形成プロセスを管理する方法について、さらに詳しく説明します。
Specifically, applications that want to update the ledger are involved in a 3-phase process, which ensures that all the peers in a blockchain network keep their ledgers consistent with each other.	具体的には、台帳を更新するアプリケーションは、ブロックチェーンネットワーク内のすべてのピアが台帳の一貫性を維持することを保証する3フェーズプロセスに関与します。
In the first phase, applications work with a subset of endorsing peers, each of which provide an endorsement of the proposed ledger update to the application, but do not apply the proposed update to their copy of the ledger.	最初のフェーズでは、アプリケーションはエンドーシングピアのサブセットと連携します。各ピアは、提案された台帳更新のエンドースメントをアプリケーションに提供しますが、提案された更新を台帳のコピーに適用しません。
In the second phase, these separate endorsements are collected together as transactions and packaged into blocks.	2番目のフェーズでは、これらの個別のエンドースメントがトランザクションとして収集され、ブロックにパッケージ化されます。
In the third and final phase, these blocks are distributed back to every peer where each transaction is validated before being committed to that peer's copy of the ledger.	3番目の最後のフェーズでは、これらのブロックがすべてのピアに配布され、各トランザクションが検証されてから、そのピアの台帳のコピーにコミットされます。
As you will see, orderer nodes are central to this process, so let's investigate in a little more detail how applications and peers use orderers to generate ledger updates that can be consistently applied to a distributed, replicated ledger.	これから説明するように、ordererノードはこのプロセスの中心となるので、アプリケーションとピアがordererを使用して、分散され複製された台帳に一貫して適用できる台帳更新を生成する方法をもう少し詳しく調べていきます。
Phase 1: Proposal	フェーズ 1: 提案
Phase 1 of the transaction workflow involves an interaction between an application and a set of peers --- it does not involve orderers.	トランザクションワークフローのフェーズ1では、アプリケーションと一連のピアとの間の対話が行われますが、ordererは関与しません。
Phase 1 is only concerned with an application asking different organizations' endorsing peers to agree to the results of the proposed chaincode invocation.	フェーズ1は、異なる組織のエンドーシングピアに対して、提案されたチェーンコード呼び出しの結果に同意するように求めるアプリケーションにのみ関係します。
To start phase 1, applications generate a transaction proposal which they send to each of the required set of peers for endorsement.	フェーズ1を開始するために、アプリケーションはトランザクション提案を生成し、それをエンドースメントのために必要なピアのセットのそれぞれに送信します。
Each of these endorsing peers then independently executes a chaincode using the transaction proposal to generate a transaction proposal response.	これらのエンドーシングピアのそれぞれは、トランザクション提案を使用してチェーンコードを独立して実行し、トランザクション提案応答を生成します。
It does not apply this update to the ledger, but rather simply signs it and returns it to the application.	この更新は台帳に適用されず、単に署名してアプリケーションに戻します。
Once the application has received a sufficient number of signed proposal responses, the first phase of the transaction flow is complete.	アプリケーションが十分な数の署名付き提案応答を受信すると、トランザクションフローの最初のフェーズが完了します。
Let's examine this phase in a little more detail.	このフェーズをもう少し詳しく見てみましょう。
Transaction proposals are independently executed by peers who return endorsed proposal responses.	トランザクション提案は、承認された提案応答を返すピアによって独立して実行されます。
In this example, application A1 generates transaction T1 proposal P which it sends to both peer P1 and peer P2 on channel C.	この例では、アプリケーションA1は、チャネルC上のピアP1とピアP2の両方に送信するトランザクションT1の提案Pを生成します。
P1 executes S1 using transaction T1 proposal P generating transaction T1 response R1 which it endorses with E1.	P1は、トランザクションT1の提案Pを使用してS1を実行し、E1でエンドースされるトランザクションT1の応答R1を生成します。
Independently, P2 executes S1 using transaction T1 proposal P generating transaction T1 response R2 which it endorses with E2.	独立して、P2は、トランザクションT1の提案Pを使用してS1を実行し、トランザクションT1の応答R2を生成し、これをE2でエンドースします。
Application A1 receives two endorsed responses for transaction T1, namely E1 and E2.	アプリケーションA1は、トランザクションT1に対する2つのエンドースされた応答、すなわちE1とE2を受け取ります。
Initially, a set of peers are chosen by the application to generate a set of proposed ledger updates.	最初に、提案された台帳更新のセットを生成するために、ピアのセットがアプリケーションによって選択されます。
Which peers are chosen by the application?	どのピアがアプリケーションによって選択されるのでしょうか?
Well, that depends on the endorsement policy (defined for a chaincode), which defines the set of organizations that need to endorse a proposed ledger change before it can be accepted by the network.	これは、(チェーンコードに対して定義された)エンドースメントポリシーに依存します。エンドースメントポリシーは、提案された台帳変更をネットワークで受け入れる前にエンドースする必要がある組織のセットを定義します。
This is literally what it means to achieve consensus --- every organization who matters must have endorsed the proposed ledger change before it will be accepted onto any peer's ledger.	これは文字通り、合意形成を達成することを意味します。つまり、重要なすべての組織は、提案された台帳変更をエンドースしてからでなければ、その変更が他の組織の台帳に受け入れられません。
A peer endorses a proposal response by adding its digital signature, and signing the entire payload using its private key.	ピアは、デジタル署名を追加し、プライベートキーを使用してペイロード全体に署名することによって、提案応答をエンドースします。
This endorsement can be subsequently used to prove that this organization's peer generated a particular response.	このエンドースメントは、その後、この組織のピアが特定の応答を生成したことを証明するために使用できます。
In our example, if peer P1 is owned by organization Org1, endorsement E1 corresponds to a digital proof that "Transaction T1 response R1 on ledger L1 has been provided by Org1's peer P1!".	この例では、ピアP1が組織Org1によって所有されている場合、エンドースメントE1は、"台帳L1のトランザクションT1の応答R1が組織1のピアP1によって提供された"というデジタル証明に対応します。
Phase 1 ends when the application receives signed proposal responses from sufficient peers.	フェーズ1は、アプリケーションが十分な数のピアから署名された提案応答を受信すると終了します。
We note that different peers can return different and therefore inconsistent transaction responses to the application for the same transaction proposal.	我々は、異なるピアが、同じトランザクション提案に対して、異なる、すなわち、一貫性のないトランザクション応答をアプリケーションに返す可能性があることに留意が必要です。
It might simply be that the result was generated at different times on different peers with ledgers at different states, in which case an application can simply request a more up-to-date proposal response.	単に、異なる状態の台帳を持つ異なるピアで異なる時間に結果が生成されたということかもしれず、その場合、アプリケーションは単純に、より最新の提案応答を要求できます。
Less likely, but much more seriously, results might be different because the chaincode is non-deterministic.	可能性は低いが、より深刻なのは、チェーンコードが非決定的であることにより、結果が異なる場合です。
Non-determinism is the enemy of chaincodes and ledgers and if it occurs it indicates a serious problem with the proposed transaction, as inconsistent results cannot, obviously, be applied to ledgers.	非決定性はチェーンコードと台帳の敵であり、それが発生した場合、矛盾した結果は明らかに台帳に適用できないので、提案されたトランザクションに重大な問題を示す。
An individual peer cannot know that their transaction result is non-deterministic --- transaction responses must be gathered together for comparison before non-determinism can be detected.	個々のピアは、トランザクションの結果が非決定的であることを知ることはできません。非決定的であることを検出する前に、比較のためにトランザクション応答を収集する必要があります。
Strictly speaking, even this is not enough, but we defer this discussion to the transaction section, where non-determinism is discussed in detail.	厳密に言えば、これだけでは十分ではありませんが、この議論はトランザクションセクションに委ねます。トランザクションセクションでは、非決定性について詳しく説明します。
At the end of phase 1, the application is free to discard inconsistent transaction responses if it wishes to do so, effectively terminating the transaction workflow early.	フェーズ1の終了時に、アプリケーションは、矛盾したトランザクション応答を破棄することを望む場合には、トランザクションワークフローを効果的に早期に終了させることができます。
We'll see later that if an application tries to use an inconsistent set of transaction responses to update the ledger, it will be rejected.	アプリケーションが一貫性のないトランザクション応答のセットを使用して台帳を更新しようとすると、拒否されることが後でわかります。
Phase 2: Ordering and packaging transactions into blocks	フェーズ 2: トランザクションのブロックへの順序付けとパッケージ化
The second phase of the transaction workflow is the packaging phase.	トランザクションワークフローの2番目のフェーズは、パッケージ化フェーズです。
The orderer is pivotal to this process --- it receives transactions containing endorsed transaction proposal responses from many applications, and orders the transactions into blocks.	ordererは、このプロセスの中心的役割を果たします。ordererは、多くのアプリケーションからエンドースされたトランザクション提案応答を含むトランザクションを受け取り、そのトランザクションを順序整理してブロックにします。
For more details about the ordering and packaging phase, check out our [conceptual information about the ordering phase](../orderer/ordering_service.html#phase-two-ordering-and-packaging-transactions-into-blocks).	順序付けおよびパッケージ化フェーズの詳細については、[順序付けフェーズに関する概念情報](../orderer/ordering_service.html#phase-two-ordering-and-packaging-transactions-into-blocks)を参照してください。
Phase 3: Validation and commit	フェーズ 3: 検証とコミット
At the end of phase 2, we see that orderers have been responsible for the simple but vital processes of collecting proposed transaction updates, ordering them, and packaging them into blocks, ready for distribution to the peers.	フェーズ2の終わりには、提案されたトランザクション更新を収集し、それらを順序整理してブロックにパッケージ化して、ピアに配布できるようにするという、シンプルだが重要なプロセスをordererが担当していることがわかります。
The final phase of the transaction workflow involves the distribution and subsequent validation of blocks from the orderer to the peers, where they can be committed to the ledger.	トランザクションワークフローの最終フェーズでは、ブロックをordererからピアに配布して検証し、台帳にコミットされます。
Specifically, at each peer, every transaction within a block is validated to ensure that it has been consistently endorsed by all relevant organizations before it is committed to the ledger.	具体的には、各ピアで、ブロック内のすべてのトランザクションが検証され、台帳にコミットされる前に、すべての関連組織によって一貫してエンドースされていることが確認されます。
Failed transactions are retained for audit, but are not committed to the ledger.	失敗したトランザクションは監査のために保持されますが、台帳にはコミットされません。
The second role of an orderer node is to distribute blocks to peers.	ordererノードの2番目の役割は、ブロックをピアに配布することです。
In this example, orderer O1 distributes block B2 to peer P1 and peer P2.	この例では、orderer O1はブロックB2をピアP1およびピアP2に配布します。
Peer P1 processes block B2, resulting in a new block being added to ledger L1 on P1.	ピアP1はブロックB2を処理し、P1の台帳L1に新しいブロックが追加されます。
In parallel, peer P2 processes block B2, resulting in a new block being added to ledger L1 on P2.	並行して、ピアP2はBlock B2を処理し、P2の台帳L1に新しいブロックが追加されます。
Once this process is complete, the ledger L1 has been consistently updated on peers P1 and P2, and each may inform connected applications that the transaction has been processed.	このプロセスが完了すると、台帳L1はピアP1およびP2上で一貫して更新され、それぞれが、トランザクションが処理されたことをそれぞれのピアに接続しているアプリケーションに通知することができます。
Phase 3 begins with the orderer distributing blocks to all peers connected to it.	フェーズ3は、ordererが接続されているすべてのピアにブロックを配布することから始まります。
Peers are connected to orderers on channels such that when a new block is generated, all of the peers connected to the orderer will be sent a copy of the new block.	新しいブロックが生成されると、ordererに接続されたすべてのピアに新しいブロックのコピーが送信されるように、ピアはチャネル上のordererに接続されます。
Each peer will process this block independently, but in exactly the same way as every other peer on the channel.	各ピアはこのブロックを個別に処理しますが、チャネル上の他のすべてのピアとまったく同じ方法で処理します。
In this way, we'll see that the ledger can be kept consistent.	このようにして、台帳の整合性を保つことができます。
It's also worth noting that not every peer needs to be connected to an orderer --- peers can cascade blocks to other peers using the gossip protocol, who also can process them independently.	また、すべてのピアがordererに接続されている必要があるわけではないことにも注意してください。ピアは、ゴシッププロトコルを使用してブロックを他のピアに伝播させることができます。また、ゴシッププロトコルは、ブロックを独立して処理することもできます。
But let's leave that discussion to another time!	でも、その話は別の機会にしましょう!
Upon receipt of a block, a peer will process each transaction in the sequence in which it appears in the block.	ブロックを受信すると、ピアは、ブロックに現れる順序で各トランザクションを処理します。
For every transaction, each peer will verify that the transaction has been endorsed by the required organizations according to the endorsement policy of the chaincode which generated the transaction.	各ピアは、トランザクションを生成したチェーンコードのエンドースメントポリシーに従って、トランザクションが必要な組織によってエンドースされたことを、トランザクションごとに検証します。
For example, some transactions may only need to be endorsed by a single organization, whereas others may require multiple endorsements before they are considered valid.	たとえば、トランザクションの中には、単一の組織によってのみエンドースされる必要があるものもあれば、有効とみなされる前に複数のエンドースメントが必要なものもあります。
This process of validation verifies that all relevant organizations have generated the same outcome or result.	この検証プロセスは、すべての関連組織が同じ結果または結果を生成したことを検証します。
Also note that this validation is different than the endorsement check in phase 1, where it is the application that receives the response from endorsing peers and makes the decision to send the proposal transactions.	また、この検証はフェーズ1のエンドースメントチェックとは異なります。フェーズ2では、アプリケーションがエンドーシングピアからの応答を受信し、提案トランザクションの送信を決定します。
In case the application violates the endorsement policy by sending wrong transactions, the peer is still able to reject the transaction in the validation process of phase 3.	アプリケーションが誤ったトランザクションを送信してエンドースメントポリシーに違反した場合でも、ピアはフェーズ3の検証プロセスでトランザクションを拒否できます。
If a transaction has been endorsed correctly, the peer will attempt to apply it to the ledger.	トランザクションが正しくエンドースされている場合、ピアはそのトランザクションを台帳に適用しようとします。
To do this, a peer must perform a ledger consistency check to verify that the current state of the ledger is compatible with the state of the ledger when the proposed update was generated.	これを行うには、台帳の整合性チェックを実行して、台帳の現在の状態が、提示された更新が生成されたときの台帳の状態と互換性があることを確認する必要があります。
This may not always be possible, even when the transaction has been fully endorsed.	これは、トランザクションが完全にエンドースされている場合でも、常に可能であるとは限りません。
For example, another transaction may have updated the same asset in the ledger such that the transaction update is no longer valid and therefore can no longer be applied.	たとえば、別のトランザクションによって台帳内の同じ資産が更新され、トランザクション更新が有効でなくなり、適用できなくなる場合があります。
In this way, the ledger is kept consistent across each peer in the channel because they each follow the same rules for validation.	この方法では、チャネル内の各ピアが同じ検証ルールに従うため、台帳はチャネル内の各ピア間で一貫性が保たれます。
After a peer has successfully validated each individual transaction, it updates the ledger.	ピアは、各トランザクションの検証に成功すると、台帳を更新します。
Failed transactions are not applied to the ledger, but they are retained for audit purposes, as are successful transactions.	失敗したトランザクションは台帳に適用されませんが、成功したトランザクションと同様に監査目的で保持されます。
This means that peer blocks are almost exactly the same as the blocks received from the orderer, except for a valid or invalid indicator on each transaction in the block.	これは、ピア上のブロックが、ブロック内の各トランザクションに有効または無効のインジケータがあることを除いて、ordererから受信したブロックと同じであることを意味します。
We also note that phase 3 does not require the running of chaincodes --- this is done only during phase 1, and that's important.	また、フェーズ3ではチェーンコードの実行は必要ありません。これはフェーズ1でのみ行われます。これは重要です。
It means that chaincodes only have to be available on endorsing nodes, rather than throughout the blockchain network.	つまり、チェーンコードはブロックチェーンネットワーク全体ではなく、エンドーシングノードでのみ使用可能である必要があります。
This is often helpful as it keeps the logic of the chaincode confidential to endorsing organizations.	これは、チェーンコードの論理をエンドースをする組織内で秘密にしておくのにしばしば役立ちます。
This is in contrast to the output of the chaincodes (the transaction proposal responses) which are shared with every peer in the channel, whether or not they endorsed the transaction.	これは、チャネル内のすべてのピア（そのピアがトランザクションをエンドースする役割か否かに関わらず）と共有されるチェーンコードの出力(トランザクション提案応答)とは対照的です。
This specialization of endorsing peers is designed to help scalability and confidentiality.	このエンドーシングピアの特殊化は、拡張性と機密性を高めるために設計されています。
Finally, every time a block is committed to a peer's ledger, that peer generates an appropriate event.	最後に、ブロックがピアの台帳にコミットされるたびに、そのピアは適切なイベントを生成します。
Block events include the full block content, while block transaction events include summary information only, such as whether each transaction in the block has been validated or invalidated.	ブロックイベントには完全なブロック内容が含まれますが、ブロックトランザクションイベントには、ブロック内の各トランザクションが検証済みか無効かなどの要約情報のみが含まれます。
Chaincode events that the chaincode execution has produced can also be published at this time.	チェーンコード実行が生成するチェーンコードイベントも、このタイミングで発行されます。
Applications can register for these event types so that they can be notified when they occur.	アプリケーションは、これらのイベントタイプを登録して、イベントが発生したときに通知を受け取ることができます。
These notifications conclude the third and final phase of the transaction workflow.	これらの通知によって、トランザクションワークフローの3番目の最終フェーズが終了します。
In summary, phase 3 sees the blocks which are generated by the orderer consistently applied to the ledger.	要約すると、フェーズ3では、台帳に一貫して適用されているordererによって生成されたブロックが参照されます。
The strict ordering of transactions into blocks allows each peer to validate that transaction updates are consistently applied across the blockchain network.	ブロックへのトランザクションの厳密な順序付けにより、各ピアは、トランザクション更新がブロックチェーンネットワーク全体に一貫して適用されていることを検証できます。
Orderers and Consensus	ordererと合意形成
This entire transaction workflow process is called consensus because all peers have reached agreement on the order and content of transactions, in a process that is mediated by orderers.	このトランザクションワークフロープロセス全体を合意形成と呼びます。これは、すべてのピアが、ordererによって仲介されるプロセスにおいて、トランザクションの順序と内容について合意に達しているためです。
Consensus is a multi-step process and applications are only notified of ledger updates when the process is complete --- which may happen at slightly different times on different peers.	合意形成は複数ステップのプロセスであり、プロセスが完了したときにのみ、アプリケーションに台帳の更新が通知されます。これは、異なるピアではわずかに異なる時間に発生する場合があります。
We will discuss orderers in a lot more detail in a future orderer topic, but for now, think of orderers as nodes which collect and distribute proposed ledger updates from applications for peers to validate and include on the ledger.	ordererについては、今後のordererのトピックでさらに詳しく説明しますが、現時点では、ordererは、アプリケーションから提案された台帳更新を収集して配布し、ピアが検証して台帳に含めるためのノードと考えてください。
We've now finished our tour of peers and the other components that they relate to in Fabric.	これで、Fabric内で関連するピアとその他のコンポーネントのツアーは終了です。
We've seen that peers are in many ways the most fundamental element ---	これまで見てきたように、ピアは多くの点で最も基本的な要素です。
they form the network, host chaincodes and the ledger, handle transaction proposals and responses, and keep the ledger up-to-date by consistently applying transaction updates to it.	ピアは、ネットワークを形成し、チェーンコードおよび台帳をホストし、トランザクションの提案と応答を処理し、一貫してトランザクションの更新を適用することによって台帳を最新の状態に維持します。
**Audience**: Architects, Application and smart contract developers, Business professionals	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者、ビジネス専門家
This topic shows you how to design the commercial paper processes and their related data structures in PaperNet.	このトピックでは、コマーシャルペーパーのプロセスおよびPaperNetにおける関連するデータ構造をどのように設計するかを示します。
Our [analysis](./analysis.html) highlighted that modelling PaperNet using states and transactions provided a precise way to understand what's happening.	前の[分析](./analysis.html)では、ステートとトランザクションによるPaperNetのモデル化によって、何が起きるかを正確に理解することができることを強調しました。
We're now going to elaborate on these two strongly related concepts to help us subsequently design the smart contracts and applications of PaperNet.	それではこれから、PaperNetのスマートコントラクトとアプリケーションの設計において、この二つの非常に関連した概念がどのように役立つのかを詳細に見ていきましょう。
As we've seen, there are two important concepts that concern us when dealing with commercial paper; states and transactions.	コマーシャルペーパーを取り扱うときに二つの重要な概念、すなわち、ステートとトランザクションがあることをみてきました。
Indeed, this is true for all blockchain use cases;	実際これは、すべてのブロックチェーンのユースケースであてはまります。
there are conceptual objects of value, modeled as states, whose lifecycle transitions are described by transactions.	つまり、価値の概念的なオブジェクトが存在し、それはステートとしてモデル化され、そのライフサイクルの遷移はトランザクションによって記述されるということです。
An effective analysis of states and transactions is an essential starting point for a successful implementation.	ステートとトランザクションの意味のある分析は、実装がうまくいくための欠かせない出発点になります。
We can represent the life cycle of a commercial paper using a state transition diagram:	コマーシャルペーパーのライフサイクルを、状態遷移図を用いて次のように表現することができます。
The state transition diagram for commercial paper.	コマーシャルペーパーの状態遷移図。
Commercial papers transition between issued, trading and redeemed states by means of the issue, buy and redeem transactions.	コマーシャルペーパーは、発行済み(issued)、取引中(trading)、現金化済み(redeemed)の状態間を、発行(issue)、購入(buy)、現金化(redeem)のトランザクションによって遷移します。
See how the state diagram describes how commercial papers change over time, and how specific transactions govern the life cycle transitions.	コマーシャルペーパーがどのように時間とともに変化し、どのトランザクションがライフサイクルの遷移をもたらしているのか、状態遷移図の表現によって確認してください。
In Hyperledger Fabric, smart contracts implement transaction logic that transition commercial papers between their different states.	Hyperledger Fabricにおいては、スマートコントラクトは、コマーシャルペーパーの状態間の遷移を行うトランザクションのロジックを実装するものです。
Commercial paper states are actually held in the ledger world state;	コマーシャルペーパーのステートは、実際には台帳のワールドステートによって保持されます。
so let's take a closer look at them.	では、これを詳細に見ていきましょう。
Recall the structure of a commercial paper:	コマーシャルペーパーの構造を思い出しましょう。
A commercial paper can be represented as a set of properties, each with a value.	コマーシャルペーパーは、それぞれが値を持つプロパティの集まりとして表現できます。
Typically, some combination of these properties will provide a unique key for each paper.	これらのプロパティのいくつかの組み合わせによって、各コマーシャルペーパーのユニークなキーが作り出せることが多いでしょう。
See how a commercial paper `Paper` property has value `00001`, and the `Face value` property has value `5M USD`.	コマーシャルペーパーの`Paper`プロパティが`00001`という値を持ち、`Face value`(額面)というプロパティが`5M USD`という値を持っていることを見てください。
Most importantly, the `Current state` property indicates whether the commercial paper is `issued`,`trading` or `redeemed`.	さらに最も重要なのは、`Current state`(現在の状態)が、コマーシャルペーパーが`issued`(発行済み)、`trading`(取引中)、`redeemed`(現金化済み)のどの状態であるかを表していることです。
In combination, the full set of properties make up the state of a commercial paper.	これらのプロパティ全てが組み合わさって、コマーシャルペーパーのステートを形づくっています。
Moreover, the entire collection of these individual commercial paper states constitutes the ledger [world state](../ledger/ledger.html#world-state).	そして、これらの個々のコマーシャルペーパーのステートの集まり全体が、台帳の[ワールドステート](../ledger/ledger.html#world-state)を構成しています。
All ledger state share this form; each has a set of properties, each with a different value.	全ての台帳ステートは、この形態をとっています。すなわち、各ステートは、それぞれが異なる値をもつプロパティの集まりをもっているというものです。
This multi-property aspect of states is a powerful feature -- it allows us to think of a Fabric state as a vector rather than a simple scalar.	ステートが複数プロパティをもつというこの側面は非常に強力な機能で、これにより、Fabricのステートを単なるスカラーではなく、ベクトルとして考えることができます。
We then represent facts about whole objects as individual states, which subsequently undergo transitions controlled by transaction logic.	そして、オブジェクト全体に関する事実をそれぞれのステートとして表現し、トランザクションのロジックによってその遷移が管理されます。
A Fabric state is implemented as a key/value pair, in which the value encodes the object properties in a format that captures the object's multiple properties, typically JSON.	Fabricのステートは、キーバリューのペアとして実装されており、値はオブジェクトのプロパティを、典型的にはJSONといった、複数のプロパティを表現できるフォーマットによってエンコードしたものです。
The [ledger database](../ledger/ledger.html#ledger-world-state-database-options) can support advanced query operations against these properties, which is very helpful for sophisticated object retrieval.	[台帳のデータベース](../ledger/ledger.html#ledger-world-state-database-options)は、これらのプロパティに対する高度なクエリ操作をサポートすることもでき、オブジェクトの複雑な取得には非常に役に立ちます。
See how MagnetoCorp's paper `00001` is represented as a state vector that transitions according to different transaction stimuli:	MagnetoCorpのコマーシャルペーパー`00001`が、トランザクションの刺激によって遷移するベクトルのステートとしてどのように表現されているかを見てください。
A commercial paper state is brought into existence and transitions as a result of different transactions.	コマーシャルペーパーのステートは、様々なトランザクションの結果として、誕生し遷移します。
Hyperledger Fabric states have multiple properties, making them vectors rather than scalars.	Hyperledger Fabricのステートは複数のプロパティをもっているため、スカラーではなくベクトルとなります。
Notice how each individual paper starts with the empty state, which is technically a [`nil`](https://en.wikipedia.org/wiki/Null_(SQL)) state for the paper, as it doesn't exist!	個々のコマーシャルペーパーは、最初は存在しないので、空のステート、技術的には[`nil`](https://en.wikipedia.org/wiki/Null_(SQL))(ヌル)状態から始まってることに注意してください!
See how paper `00001` is brought into existence by the issue transaction, and how it is subsequently updated as a result of the buy and redeem transactions.	コマーシャルペーパー`00001`が、発行(issue)トランザクションによって産まれ、その後、購入(buy)および現金化(redeem)トランザクションによって更新されることを確認してください。
Notice how each state is self-describing; each property has a name and a value.	各ステートが、自己記述的であることに注目してください。各プロパティは、名前と値を持っています。
Although all our commercial papers currently have the same properties, this need not be the case for all time, as Hyperledger Fabric supports different states having different properties.	このコマーシャルペーパーにおいては、全てが同じプロパティを持っていますが、これはいつもそうである必要はありません。Hyperledger Fabricはステートが別のプロパティを持つことをサポートしているためです。
This allows the same ledger world state to contain different forms of the same asset as well as different types of asset.	これによって、一つの同じ台帳のワールドステートに、異なる資産も、同じ資産であっても異なる形態のものも格納することができます。
It also makes it possible to update a state's structure; imagine a new regulation that requires an additional data field.	また、ステートの構造を更新することも可能になっています。たとえば、新しい規制によって追加のデータフィールドが必要になったときのことを想像してみてください。
Flexible state properties support the fundamental requirement of data evolution over time.	ステートのプロパティが柔軟なことで、時間の変化によって起こるデータの進化の根本的な要件に対応しています。
In most practical applications, a state will have a combination of properties that uniquely identify it in a given context -- it's key.	多くの実際のアプリケーションでは、ステートは、ある時点においてそれを一意に識別可能なプロパティの組み合わせ、すなわちキーを持つでしょう。
The key for a PaperNet commercial paper is formed by a concatenation of the `Issuer` and `paper` properties; so for MagnetoCorp's first paper, it's `MagnetoCorp00001`.	PaperNetのコマーシャルペーパーにおけるキーは、`Issuer`(発行者)と`Paper`のプロパティを連結したものとして構成されます。つまり、MagnetoCorpの最初のコマーシャルペーパーのキーは、`MagnetoCorp00001`となります。
A state key allows us to uniquely identify a paper; it is created as a result of the issue transaction and subsequently updated by buy and redeem.	ステートのキーによって、コマーシャルペーパーを一意に識別することができます。コマーシャルペーパーは、発行(issue)トランザクションによって作られ、購入(buy)および現金化(redeem)トランザクションによって更新されます。
Hyperledger Fabric requires each state in a ledger to have a unique key.	Hyperledger Fabricでは、台帳の各ステートがユニークなキーを持つ必要があります。
When a unique key is not available from the available set of properties, an application-determined unique key is specified as an input to the transaction that creates the state.	存在するプロパティの中からユニークなキーが作れない場合には、アプリケーションによって決められたユニークキーが、ステートを作るトランザクションの入力として与えられます。
This unique key is usually with some form of [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), which although less readable, is a standard practice.	このユニークなキーは、通常、可読性は低くなりますが標準的方法である[UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)の何らかの形を使います。
What's important is that every individual state object in a ledger must have a unique key.	重要なのは、台帳の各ステートオブジェクトは、ユニークなキーを持たなければならないということです。
Note: You should avoid using U+0000 (nil byte) in keys.	注: U+0000(ヌル文字)をキーに使用することは避けるべきです。
As we've seen, commercial papers in PaperNet are stored as state vectors in a ledger.	これまで見てきたように、PaperNetのコマーシャルペーパーは、台帳にベクトルのステートとして格納されています。
It's a reasonable requirement to be able to query different commercial papers from the ledger; for example: find all the papers issued by MagnetoCorp, or: find all the papers issued by MagnetoCorp in the `redeemed` state.	台帳から異なるコマーシャルペーパーをクエリが可能であるというのは、まっとうな要件で、例えば、MagnetoCorpによって発行されたコマーシャルペーパーを全て取得するとか、MagnetoCorpによって発行された`redeemed`(現金化済み)状態のコマーシャルペーパーを全て取得するといったものです。
To make these kinds of search tasks possible, it's helpful to group all related papers together in a logical list.	このような検索タスクを可能にするために、関連するコマーシャルペーパーを論理的なリストにまとめるというのが役立ちます。
The PaperNet design incorporates the idea of a commercial paper list -- a logical container which is updated whenever commercial papers are issued or otherwise changed.	PaperNetの設計は、コマーシャルペーパーのリスト、すなわちコマーシャルペーパーが発行されたり変化した場合に更新される論理的なコンテナの考えが考慮されています。
It's helpful to think of all PaperNet commercial papers being in a single list of commercial papers:	全てのPaperNetのコマーシャルペーパーが、コマーシャルペーパーの単一のリストに存在すると考えるのがわかりやすいでしょう。
MagnetoCorp's newly created commercial  paper 00004 is added to the list of existing commercial papers.	MagnetoCorpの新しく作られたコマーシャルペーパーの00004が、既存のコマーシャルペーパーのリストに追加されています。
New papers can be added to the list as a result of an issue transaction, and papers already in the list can be updated with buy or redeem transactions.	新しいコマーシャルペーパーは、発行(issue)トランザクションの結果としてリストに追加され、既にリストに存在するコマーシャルペーパーは購入(buy)や現金化済み(redeem)トランザクションによって更新されることがあります。
See how the list has a descriptive name: `org.papernet.papers`;	このリストが`org.papernet.papers`という名前を持っていることを確認してください。
it's a really good idea to use this kind of [DNS name](https://en.wikipedia.org/wiki/Domain_Name_System) because well-chosen names will make your blockchain designs intuitive to other people.	このような[DNS名](https://en.wikipedia.org/wiki/Domain_Name_System)を使うのは非常によい考えで、なぜならば、良く選ばれた名前によって、他人が直観的にブロックチェーンのデザインを理解できるであろうからです。
This idea applies equally well to smart contract [names](./contractname.html).	この考えは、スマートコントラクトの[名前](./contractname.html)についても同様にあてはまります。
While it's correct to think of a single list of papers in PaperNet -- `org.papernet.papers` -- lists are best implemented as a set of individual Fabric states, whose composite key associates the state with its list.	PaperNetにおいて、コマーシャルペーパーの一つのリスト `org.papernet.papers` として考えることは正しいのですが、リストの最も良い実装は、コンポジットキー(複合キー)によってリストと関連づられたFabricのステートの集まりとするものです。
In this way, each state's composite key is both unique and supports effective list query.	このようにして、各ステートのコンポジットキーは、ユニークであり、かつリストの有効なクエリにも対応します。
Representing a list of PaperNet commercial papers as a set of distinct Hyperledger Fabric states	PaperNetのコマーシャルペーパーのリストが、別々のHyperledger Fabricステートの集まりとして表現されています
Notice how each paper in the list is represented by a vector state, with a unique composite key formed by the concatenation of `org.papernet.paper`, `Issuer` and `Paper` properties.	リストにある各コマーシャルペーパーが、`org.papernet.paper`と、`Issuer`、`Paper`プロパティの連結によって作られたユニークなコンポジットキーを持つベクトルのステートによって表現されていることに注目してください。
This structure is helpful for two reasons:	この構造は、次の二つの理由で便利です。
It allows us to examine any state vector in the ledger to determine which list it's in, without reference to a separate list.	各リストを参照せずに、台帳内のベクトルのステートがどのリストにあるかを確かめることができます。
It's analogous to looking at set of sports fans, and identifying which team they support by the colour of the shirt they are wearing.	これは、着ているシャツの色をみて、スポーツファンがどのチームをサポートしているかを見分けるのに似ています。
The sports fans self-declare their allegiance; we don't need a list of fans.	スポーツファンは、自身の忠誠を自ら宣言しているため、ファンのリストは必要ありません。
Hyperledger Fabric internally uses a concurrency control mechanism to update a ledger, such that keeping papers in separate state vectors vastly reduces the opportunity for shared-state collisions.	Hyperledger Fabricは、台帳の更新に際して、内部的に同時実行制御の機構を利用しています。そのため、コマーシャルペーパーを別々のベクトルのステートとすることで、同じステートの更新衝突の可能性を大きく減らすことができます。
Such collisions require transaction re-submission, complicate application design, and decrease performance.	このような衝突が発生すると、トランザクションの再発行が必要となり、アプリケーションの設計を複雑にし、性能を低下させることになります。
This second point is actually a key take-away for Hyperledger Fabric; the physical design of state vectors is very important to optimum performance and behaviour.	この二つ目は、実際のところ、Hyperledger Fabricにおける重要なポイントで、ベクトルのステートという物理的な設計は、性能とふるまいを最適化する上で非常に重要です。
Keep your states separate!	ステートは、別々のものとして実装しましょう!
We have discussed how the different roles in a network, such as issuer, trader or rating agencies as well as different business interests determine who needs to sign off on a transaction.	トランザクションの署名を誰が行う必要があるかは、ネットワークにおける、発行者や取引者、あるいは格付け機関といったそれぞれの役割、そしてそれぞれの営業上の利益によって決定されます。
In Fabric, these rules are captured by so-called [endorsement policies](endorsementpolicies.html).	Fabricでは、この規則は、[エンドースメントポリシー](endorsementpolicies.html)として表現されます。
The rules can be set on a chaincode granularity, as well as for individual state keys.	この規則は、チェーンコードの単位でも、各ステートのキーの単位でも設定することができます。
This means that in PaperNet, we can set one rule for the whole namespace that determines which organizations can issue new papers.	すなわち、PaperNetでは、誰が新しいコマーシャルペーパーを発行できるかを決める規則を、ネームスペース全体について一つ設定することができます。
Later, rules can be set and updated for individual papers to capture the trust relationships of buy and redeem transactions.	そしてその後、個別のコマーシャルペーパーに対して、購入と現金化のトランザクションの信頼関係を表現するために規則を設定し更新することができます。
In the next topic, we will show you how to combine these design concepts to implement the PaperNet commercial paper smart contract, and then an application in exploits it!	次のトピックでは、この設計した概念とPaperNetコマーシャルペーパーのスマートコントラクトの実装をどのように結合し、アプリケーションがどのようにそれを利用するのかを見ていきます!
**Audience**: Architects, Application and smart contract developers	**対象読者**: アーキテクト、アプリケーション及びスマートコントラクト開発者
At the heart of a blockchain network is a smart contract.	スマートコントラクトは、ブロックチェーン・ネットワークの中心にあります。
In PaperNet, the code in the commercial paper smart contract defines the valid states for commercial paper, and the transaction logic that transition a paper from one state to another.	PaperNetでは、コマーシャルペーパーの有効な状態と、その状態間の遷移を引き起こすロジックは、コマーシャルペーパーのスマートコントラクトのコードによって定義されています。
In this topic, we're going to show you how to implement a real world smart contract that governs the process of issuing, buying and redeeming commercial paper.	このトピックでは、コマーシャルペーパーの発行、購入、現金化のプロセスを管理する実世界のスマートコントラクトをどのように実装するかを示していきます。
We're going to cover:	ここでは、以下について扱います。
[What is a smart contract and why it's important](#smart-contract)	[スマートコントラクトとは何か、そして、なぜそれが重要なのか](#smart-contract)
[How to define a smart contract](#contract-class)	[スマートコントラクトの定義の仕方](#contract-class)
[How to define a transaction](#transaction-definition)	[トランザクションの定義の仕方](#transaction-definition)
[How to implement a transaction](#transaction-logic)	[トランザクションの実装の仕方](#transaction-logic)
[How to represent a business object in a smart contract](#representing-an-object)	[スマートコントラクトでのビジネスデータの表現の仕方](#representing-an-object)
[How to store and retrieve an object in the ledger](#access-the-ledger)	[台帳におけるデータの格納と取得の仕方](#access-the-ledger)
If you'd like, you can [download the sample](../install.html) and even [run it locally](../tutorial/commercial_paper.html).	もし必要であれば、[サンプルをダウンロード](../install.html)し、さらに[ローカルで実行する](../tutorial/commercial_paper.html)こともできます。
It is written in JavaScript and Java, but the logic is quite language independent, so you'll easily be able to see what's going on! (The sample will become available for Go as well.)	サンプルは、JavaScriptとJavaで書かれていますが、そのロジックはプログラミング言語には依存しませんので、内容を把握するのは簡単でしょう。(Go版のサンプルも作られる予定です)
A smart contract defines the different states of a business object and governs the processes that move the object between these different states.	スマートコントラクトは、ビジネスデータの様々な状態を定義し、データをその状態間で遷移させるプロセスを管理するものです。
Smart contracts are important because they allow architects and smart contract developers to define the key business processes and data that are shared across the different organizations collaborating in a blockchain network.	スマートコントラクトによって、アーキテクトやスマートコントラクト開発者が、ブロックチェーンネットワークで協業する様々な組織間で共有される重要なビジネスプロセスやデータを定義することができるため、スマートコントラクトは重要なものです。
In the PaperNet network, the smart contract is shared by the different network participants, such as MagnetoCorp and DigiBank.	PaperNetのネットワークにおいては、スマートコントラクトは、MagnetoCorpやDigiBankといった様々なネットワーク参加者によって共有されています。
The same version of the smart contract must be used by all applications connected to the network so that they jointly implement the same shared business processes and data.	共有している同じビジネスプロセスとデータを共同で実装するために、ネットワークに接続されているすべてのアプリケーションは、同じバージョンのスマートコントラクトを使用しなければなりません。
There are two runtimes that are supported, the Java Virtual Machine and Node.js.	Java仮想マシンとNode.jsの二つのランタイムがサポートされています。
This gives the opportunity to use one of JavaScript, TypeScript, Java or any other language that can run on one of these supported runtimes.	これにより、JavaScript、TypeScriptやJava、あるいはこれらのランタイム上で動くその他の言語を使うことができます。
In Java and TypeScript, annotations or decorators are used to provide information about the smart contract and it's structure.	JavaとTypeScriptにおいては、アノテーションあるいはデコレータを使って、スマートコントラクトとその構造に関する情報を提供することができます。
This allows for a richer development experience --- for example, author information or return types can be enforced.	これによって、よりよい開発体験、例えば、製作者の情報の提供や、返り値の型の強制などを行うことができます。
Within JavaScript, conventions must be followed, therefore, there are limitations around what can be determined automatically.	JavaScriptだけでは、コーディング規約に従う必要があり、それゆえに自動的に判定できることに制限があります。
Examples here are given in both JavaScript and Java.	このトピックの例では、JavaScriptとJavaの両方を使用しています。
A copy of the PaperNet commercial paper smart contract is contained in a single file.	PaperNetコマーシャルペーパーのスマートコントラクトは、一つのファイル内に書かれています。
View it with your browser, or open it in your favorite editor if you've downloaded it.	ブラウザで見るか、既にダウンロードしてあるのであれば、好きなエディタで開いてください。
`papercontract.js` - [JavaScript version](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js) - `CommercialPaperContract.java` - [Java version](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp//contract-java/src/main/java/org/example/CommercialPaperContract.java)	`papercontract.js` - [JavaScript版](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js) - `CommercialPaperContract.java` - [Java版](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp//contract-java/src/main/java/org/example/CommercialPaperContract.java)
You may notice from the file path that this is MagnetoCorp's copy of the smart contract.	ファイルのパスから、これはMagnetoCorpのスマートコントラクトと気づくかもしれません。
MagnetoCorp and DigiBank must agree on the version of the smart contract that they are going to use.	MagnetoCorpとDigiBankは、これから使用するスマートコントラクトのバージョンについて合意していなければなりません。
For now, it doesn't matter which organization's copy you use, they are all the same.	とりあえずは、どの組織のものを使うかは関係ありません。全て同じです。
Spend a few moments looking at the overall structure of the smart contract; notice that it's quite short!	スマートコントラクトの全体の構造について、少し見てみましょう。非常に短いことに注目してください！
Towards the top of the file, you'll see that there's a definition for the commercial paper smart contract:	ファイルの冒頭のほうに、次のようなコマーシャルペーパーのスマートコントラクトの定義があることがわかります。
The `CommercialPaperContract` class contains the transaction definitions for commercial paper -- issue, buy and redeem.	`CommercialPaperContract`クラスは、コマーシャルペーパーに関するトランザクションの定義を含んでいます。すなわち、発行(issue)、購入(buy)、現金化(redeem)です。
It's these transactions that bring commercial papers into existence and move them through their lifecycle.	これらのトランザクションが、コマーシャルペーパーを作り出し、そのライフサイクルに従って遷移させるものです。
We'll examine these [transactions](#transaction-definition) soon, but for now notice for JavaScript, that the `CommericalPaperContract` extends the Hyperledger Fabric `Contract` [class](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-contract-api.Contract.html).	この[トランザクション](#transaction-definition)については、この後ですぐ見ることになります。今のところは、JavaScriptでは`CommercialPaperContract`が、Hyperledger Fabricの`Contract`[クラス](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-contract-api.Contract.html)を継承していることに注意してください。
With Java, the class must be decorated with the `@Contract(...)` annotation.	Javaでは、このクラスには、アノテーション`@Contract(...)`を付加する必要があります。
This provides the opportunity to supply additional information about the contract, such as license and author.	これによって、ライセンスや製作者といったコントラクトに関する追加の情報を提供することができます。
The `@Default()` annotation indicates that this contract class is the default contract class.	`@Default()`アノテーションは、このクラスが、デフォルトのコントラクトのクラスであることを示しています。
Being able to mark a contract class as the default contract class is useful in some smart contracts which have multiple contract classes.	あるクラスを、デフォルトのコントラクトのクラスとして指定できることは、複数のコントラクトのクラスをもつスマートコントラクトで便利なことがあります。
If you are using a TypeScript implementation, there are similar `@Contract(...)` annotations that fulfill the same purpose as in Java.	もし、TypeScriptによる実装を使っている場合には、Javaと同じ目的を満たす、似たような`@Contract(...)`デコレータがあります。
For more information on the available annotations, consult the available API documentation:	アノテーションに関する情報については、APIのドキュメントを参照してください。
[API documentation for Java smart contracts](https://hyperledger.github.io/fabric-chaincode-java/)	[JavaスマートコントラクトのAPIドキュメント](https://hyperledger.github.io/fabric-chaincode-java/)
[API documentation for Node.js smart contracts](https://hyperledger.github.io/fabric-chaincode-node/)	[Node.JsスマートコントラクトのAPIドキュメント](https://hyperledger.github.io/fabric-chaincode-node/)
The Fabric contract class is also available for smart contracts written in Go.	Fabricのコントラクトのクラスは、Goで書かれたスマートコントラクトでも利用可能です。
While we do not discuss the Go contract API in this topic, it uses similar concepts as the API for Java and JavaScript:	このトピックでは、GoのコントラクトAPIについては述べませんが、JavaやJavaScriptのAPIと同様の概念を利用しています。
[API documentation for Go smart contracts](https://github.com/hyperledger/fabric-contract-api-go)	[GoスマートコントラクトのAPIドキュメント](https://github.com/hyperledger/fabric-contract-api-go)
These classes, annotations, and the `Context` class, were brought into scope earlier:	これらのクラス、アノテーション、`Context`クラスは、その前の下記の記述によって、スコープ内に取り込んでいます。
Our commercial paper contract will use built-in features of these classes, such as automatic method invocation, a [per-transaction context](./transactioncontext.html), [transaction handlers](./transactionhandler.html), and class-shared state.	コマーシャルペーパーのスマートコントラクトは、これらのクラスに組み込まれている機能を用います。例えば、自動的なメソッドの呼び出し、[トランザクションごとのコンテキスト](./transactioncontext.html)、[トランザクション・ハンドラ](./transactionhandler.html)、クラス間で共有されるステートなどです。
Notice also how the JavaScript class constructor uses its [superclass](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super) to initialize itself with an explicit [contract name](./contractname.html):	JavaScriptでは、クラスのコンストラクタで、[親クラス](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super)を用いて、明示的に[コントラクト名](./contractname.html)を指定して初期化していることにも注目してください。
With the Java class, the constructor is blank as the explicit contract name can be specified in the `@Contract()` annotation.	Javaのクラスでは、コンストラクトは空で、`@Contract()`アノテーションによって明示的な名前を指定することができます。
If it's absent, then the name of the class is used.	もし、アノテーションがなければ、そのクラスの名前が使われます。
Most importantly, `org.papernet.commercialpaper` is very descriptive -- this smart contract is the agreed definition of commercial paper for all PaperNet organizations.	最も重要なのは、`org.papernet.commercialpaper`という名前が非常に記述的であるということで、このスマートコントラクトは、PaperNetに参加する組織すべてで合意されたコマーシャルペーパーの定義であるということを示しています。
Usually there will only be one smart contract per file -- contracts tend to have different lifecycles, which makes it sensible to separate them.	通常、1つのファイルには1つのスマートコントラクトしか書かれないでしょう。これは、スマートコントラクトは、別々のライフサイクルを持つことが多く、分けておくことは賢明なことだからです。
However, in some cases, multiple smart contracts might provide syntactic help for applications, e.g. `EuroBond`, `DollarBond`, `YenBond`, but essentially provide the same function.	しかし、場合によっては、例えば`EuroBond`、`DollarBond`、`YenBond`というように、複数のスマートコントラクトで、アプリケーションに対しては文法的に区別できるようにしつつ、基本的には同じ機能を提供したいという場合があります。
In such cases, smart contracts and transactions can be disambiguated.	このような場合では、スマートコントラクトとトランザクションの曖昧さを避けることができます。
Within the class, locate the issue method.	クラスの中からissueメソッドを探してみてください。
The Java annotation `@Transaction` is used to mark this method as a transaction definition; TypeScript has an equivalent annotation.	Javaのアノテーション `@Transaction` は、このメソッドがトランザクションの定義であることを示すもので、TypeScriptにも同等のデコレータがあります。
This function is given control whenever this contract is called to `issue` a commercial paper.	このコントラクトがコマーシャルペーパーの`issue`(発行)のために呼ばれた場合に、この関数に制御がわたります。
Recall how commercial paper 00001 was created with the following transaction:	コマーシャルペーパー00001が次のようなトランザクションで作成されたことを思い出してください。
We've changed the variable names for programming style, but see how these properties map almost directly to the `issue` method variables.	プログラミング・スタイルに従って変数名は変えていますが、これらのプロパティがほとんどそのまま`issue`メソッドの引数に対応することがわかるでしょう。
The `issue` method is automatically given control by the contract whenever an application makes a request to issue a commercial paper.	`issue`メソッドは、アプリケーションがコマーシャルペーパーの発行の要求をするたびに、コントラクトによって自動的に実行されます。
The transaction property values are made available to the method via the corresponding variables.	トランザクションのプロパティの値は、対応する引数という形でメソッドから利用可能です。
See how an application submits a transaction using the Hyperledger Fabric SDK in the [application](./application.html) topic, using a sample application program.	アプリケーションがどのようにHyperledger SDKを用いてトランザクションを送信するかは、[アプリケーション](./application.html)のトピックで、サンプルのアプリケーションを用いて説明されています。
You might have noticed an extra variable in the issue definition -- `ctx`.	issueの定義に、追加の引数 `ctx` があることに気づいたかもしれません。
It's called the [transaction context](./transactioncontext.html), and it's always first.	これは、[トランザクション・コンテキスト](./transactioncontext.html)と呼ばれるもので、必ず一番最初の引数となります。
By default, it maintains both per-contract and per-transaction information relevant to [transaction logic](#transaction-logic).	デフォルトでは、[トランザクションのロジック](#transaction-logic)に関係する、コントラクトごと、またトランザクションごとの情報を保持しています。
For example, it would contain MagnetoCorp's specified transaction identifier, a MagnetoCorp issuing user's digital certificate, as well as access to the ledger API.	たとえば、MagnetoCorpのあるトランザクションの識別子、すなわちMagnetoCorpにより発行されたユーザーのデジタル証明書や、台帳APIへのアクセスを含んでいるでしょう。
See how the smart contract extends the default transaction context by implementing its own `createContext()` method rather than accepting the default implementation:	スマートコントラクトは、デフォルトのトランザクション・コンテキストを拡張することができます。これには、デフォルトをそのまま使うのではなく、独自の`createContext()`メソッドを実装することによって行えます。
This extended context adds a custom property `paperList` to the defaults:	この拡張されたコンテキストでは、デフォルトのプロパティに対して、カスタムプロパティである`paperList`を加えています。
All papers are held in a list of papers this.paperList = new PaperList(this);	すべてのコマーシャルペーパーがリストに保存される
We'll soon see how `ctx.paperList` can be subsequently used to help store and retrieve all PaperNet commercial papers.	この後で、どのように`ctx.paperList`が全てのPaperNetのコマーシャルペーパーを格納し取得するのに役立つかを述べます。
To solidify your understanding of the structure of a smart contract transaction, locate the buy and redeem transaction definitions, and see if you can see how they map to their corresponding commercial paper transactions.	スマートコントラクト・トランザクションの構造に対する理解を確かなものにするために、buyとredeemトランザクションの定義を探してみて、それぞれ相当するコマーシャルペーパーのトランザクションにどのように対応するかを見てみてください。
The buy transaction:	buyトランザクション:
The redeem transaction:	redeemトランザクション:
In both cases, observe the 1:1 correspondence between the commercial paper transaction and the smart contract method definition.	どちらの場合も、コマーシャルペーパーのトランザクションと、スマートコントラクトのメソッド定義に1:1の対応関係があるのを確認してください。
All of the JavaScript functions use the `async` and `await` [keywords](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) which allow JavaScript functions to be treated as if they were synchronous function calls.	全てのJavaScriptの関数は、`async`と`await`[キーワード](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)を使っています。これによって、JavaScriptの関数を、同期的関数呼び出しかのように扱うことを可能にしています。
Now that you've seen how contracts are structured and transactions are defined, let's focus on the logic within the smart contract.	ここまでで、コントラクトがどのような構造をもち、トランザクションがどのように定義されているかを見てきましたので、次は、スマートコントラクト内のロジックにフォーカスしましょう。
Recall the first issue transaction:	最初のissueトランザクションを思い出してください。
It results in the issue method being passed control:	これによって、issueメソッドに処理が渡ります。
create an instance of the paper Smart contract, rather than paper, moves paper into ISSUED state	コマーシャルペーパーのインスタンスを作成　コマーシャルペーパーでなく、スマートコントラクトがコマーシャルペーパーをISSUED(発行済み)状態に設定
Newly issued paper is owned by the issuer paper.setOwner(issuer);	新規発行されたコマーシャルペーパーの所有者は発行者
paper.setOwner(issuer);	paper.setOwner(issuer);
Add the paper to the list of all similar commercial papers in the ledger world state	このコマーシャルペーパーを、台帳のワールドステート内の同様のコマーシャルペーパーのリストに追加
await ctx.paperList.addPaper(paper);	await ctx.paperList.addPaper(paper);
Must return a serialized paper to caller of smart contract	スマートコントラクトの呼び出し元に、シリアライズしたコマーシャルペーパーを返す
create an instance of the paper Smart contract, rather than paper, moves paper into ISSUED state	コマーシャルペーパーのインスタンスを作成　コマーシャルペーパーでなく、スマートコントラクトがコマーシャルペーパーをISSUED(発行済み)状態に設定
Newly issued paper is owned by the issuer	新規発行されたコマーシャルペーパーの所有者は発行者
Add the paper to the list of all similar commercial papers in the ledger world state	このコマーシャルペーパーを、台帳のワールドステート内の同様のコマーシャルペーパーのリストに追加
Must return a serialized paper to caller of smart contract	スマートコントラクトの呼び出し元に、シリアライズしたコマーシャルペーパーを返す
The logic is simple: take the transaction input variables, create a new commercial paper `paper`, add it to the list of all commercial papers using `paperList`, and return the new commercial paper (serialized as a buffer) as the transaction response.	ロジックは単純で、入力値を取得し、新しいコマーシャルペーパー `paper` を作成し、それをコマーシャルペーパーのリストに、`paperList`を使って追加し、(bufferとしてシリアライズした)新しいコマーシャルペーパーを、トランザクションの応答として返すというものです。
See how `paperList` is retrieved from the transaction context to provide access to the list of commercial papers.	`paperList`が、トランザクション・コンテキストから取得され、コマーシャルペーパーのリストへのアクセスを提供しているのを確認してください。
`issue()`, `buy()` and `redeem()` continually re-access `ctx.paperList` to keep the list of commercial papers up-to-date.	`issue()`、`buy()`、そして`redeem()`は`ctx.paperList`に継続的に何度もアクセスし、コマーシャルペーパーのリストを最新の状態に維持しています。
The logic for the buy transaction is a little more elaborate:	buyトランザクションのロジックは、もう少し複雑なものです。
Retrieve the current paper using key fields provided	与えられたフィールドをキーとして、現在のコマーシャルペーパーを取得
Validate current owner	現在の所有者の検証
First buy moves state from ISSUED to TRADING	最初の購入では、状態をISSUEDからTRADINGに変更
Check paper is not already REDEEMED	コマーシャルペーパーが既にREDEEMED(現金化済み)でないことを確認
Update the paper	コマーシャルペーパーの更新
Retrieve the current paper using key fields provided	与えられたフィールドをキーとして、現在のコマーシャルペーパーを取得
Validate current owner	現在の所有者の検証
First buy moves state from ISSUED to TRADING	最初の購入では、状態をISSUEDからTRADINGに変更
Check paper is not already REDEEMED	コマーシャルペーパーが既にREDEEMED(現金化済み)でないことを確認
Update the paper	コマーシャルペーパーの更新
See how the transaction checks `currentOwner` and that `paper` is `TRADING` before changing the owner with `paper.setOwner(newOwner)`.	トランザクションが、`curretOwner`と`paper`が`TRADING`であることを確認してから、所有者を`paper.SetOwner(newOwner)`で変更しているのを確認してください。
The basic flow is simple though -- check some pre-conditions, set the new owner, update the commercial paper on the ledger, and return the updated commercial paper (serialized as a buffer) as the transaction response.	ですが、基本的なフローは単純で、いくつかの前提条件をチェックし、新しい所有者を設定し、台帳上のコマーシャルペーパーを更新し、更新した(bufferとしてシリアライズした)コマーシャルペーパーをトランザクションの応答として返すというものです。
Why don't you see if you can understand the logic for the redeem transaction?	redeemトランザクションのロジックも理解できるかどうか確認してみませんか？
We've seen how to define and implement the issue, buy and redeem transactions using the `CommercialPaper` and `PaperList` classes.	ここまでは、`CommercialPaper`と`PaperList`クラスを用いて、issue、buy、redeemのトランザクションをどのように定義・実装するかを見てきました。
Let's end this topic by seeing how these classes work.	これらのクラスがどのように動くのかを見て、このトピックを終わりにしましょう。
Locate the `CommercialPaper` class:	`CommercialPaper`クラスを探してみてください。
In the [paper.js file](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/paper.js):	[paper.jsファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/paper.js)の中:
In the [CommercialPaper.java file](https://github.com/hyperledger/fabric-samples/blob/release-1.4/commercial-paper/organization/magnetocorp/contract-java/src/main/java/org/example/CommercialPaper.java):	[CommercialPaper.javaファイル](https://github.com/hyperledger/fabric-samples/blob/release-1.4/commercial-paper/organization/magnetocorp/contract-java/src/main/java/org/example/CommercialPaper.java)の中:
This class contains the in-memory representation of a commercial paper state.	このクラスは、コマーシャルペーパーのステートのメモリ上での表現を含んでいます。
See how the `createInstance` method initializes a new commercial paper with the provided parameters:	`createInstance`メソッドの、新しいコマーシャルペーパーを与えられたパラメータで初期化する方法を見てください。
Recall how this class was used by the issue transaction:	このクラスがissueトランザクションでどのように使われていたかを思い出してください。
See how every time the issue transaction is called, a new in-memory instance of a commercial paper is created containing the transaction data.	このissueトランザクションが呼ばれるたびに、トランザクションのデータを含んだコマーシャルペーパーの新しいメモリ上のインスタンスが作成されます。
A few important points to note:	何点か重要な注意点です。
This is an in-memory representation;	これはメモリ上での表現です
we'll see [later](#accessing-the-ledger) how it appears on the ledger.	台帳上にどう表れるかは、[後ほど](#accessing-the-ledger)見ていきます。
The `CommercialPaper` class extends the `State` class.	`CommercialPaper`クラスは、`State`クラスを継承しています。
`State` is an application-defined class which creates a common abstraction for a state.	`State`は、ステートの共通的な抽象化を作成するアプリケーションで定義されたクラスです。
All states have a business object class which they represent, a composite key, can be serialized and de-serialized, and so on.	全てのステートには、それが表現するビジネスデータのクラスがあり、複合キーを作り、シリアライズやデシリアライズなどを行うことができます。
`State` helps our code be more legible when we are storing more than one business object type on the ledger.	`State`は、台帳に複数の型のビジネスデータを格納する際に、コードをより読みやすくするのに役立ちます。
Examine the `State` class in the `state.js` [file](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/ledger-api/state.js).	`State`クラスの内容は、`state.js`[ファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/ledger-api/state.js)で確認できます。
A paper computes its own key when it is created --	コマーシャルペーパーは、作られた際に、そのキーを計算します
this key will be used when the ledger is accessed.	このキーは、台帳にアクセスする際に用いられます。
The key is formed from a combination of `issuer` and `paperNumber`.	キーは、`issuer`と`paperNumber`を合わせたものです。
A paper is moved to the `ISSUED` state by the transaction, not by the paper class.	コマーシャルペーパーは、クラスではなく、トランザクションによって`ISSUED`状態に遷移させられます。
That's because it's the smart contract that governs the lifecycle state of the paper.	これは、コマーシャルペーパーのライフサイクル状態を管理するのは、スマートコントラクトであるからです。
For example, an `import` transaction might create a new set of papers immediately in the `TRADING` state.	たとえば、`import`トランザクションがあったならば、いくつかの`TRADING`状態のコマーシャルペーパーを作成することになるであろうからです。
The rest of the `CommercialPaper` class contains simple helper methods:	`CommercialPaper`クラスの残りは、単純なヘルパーメソッドを含んでいます。
Recall how methods like this were used by the smart contract to move the commercial paper through its lifecycle.	スマートコントラクトが、このようなメソッドを使ってコマーシャルペーパーをライフサイクルの中で、どのように遷移させていたかを思い出してください。
For example, in the redeem transaction we saw:	たとえば、redeemトランザクションでは、次のようなコードがありました。
Now locate the `PaperList` class in the `paperlist.js` [file](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/paperlist.js):	では、`paperlist.js`[ファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/paperlist.js)から、`PaperList`クラスを探してください。
This utility class is used to manage all PaperNet commercial papers in Hyperledger Fabric state database.	このユーティリティ・クラスは、Hyperledger Fabricのステートデータベース内の全てのPaperNetのコマーシャルペーパーを管理するのに使用されます。
The PaperList data structures are described in more detail in the [architecture topic](./architecture.html).	PaperListのデータ構造の詳細は、[アーキテクチャのトピック](./architecture.html)で説明されています。
Like the `CommercialPaper` class, this class extends an application-defined `StateList` class which creates a common abstraction for a list of states -- in this case, all the commercial papers in PaperNet.	`CommercialPaper`と同じように、このクラスは、アプリケーションで定義された`StateList`クラスを継承しています。`SateList`クラスは、ステートのリストに共通で使われる抽象化を作成し、この場合には、PaperNetの全てのコマーシャルペーパーのリストのことです。
The `addPaper()` method is a simple veneer over the `StateList.addState()` method:	`addPaper()`メソッドは、以下のような、`StateList.addState()`に対する単純なラッパーです。
You can see in the `StateList.js` [file](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/ledger-api/statelist.js) how the `StateList` class uses the Fabric API `putState()` to write the commercial paper as state data in the ledger:	`StateList.js`[ファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/ledger-api/statelist.js)で、`StateList`クラスが、ステートデータとして台帳にコマーシャルペーパーを記録するのに、どのようにFabric APIの`putState()`を使用しているかを見ることができます。
Every piece of state data in a ledger requires these two fundamental elements:	台帳において、各ステートデータには、二つの基本的な要素が必要となります。
Key:	キー。
`key` is formed with `createCompositeKey()` using a fixed name and the key of `state`.	`key`は、固定の名前と`state`のキーを用いて、`createCompositeKey()`によって作られます。
The name was assigned when the `PaperList` object was constructed, and `state.getSplitKey()` determines each state's unique key.	この名前は、`PaperList`オブジェクトが作られたときに与えられ、`state.getSplitKey()`によって各ステートのユニークなキーが決められます。
Data:	データ。
`data` is simply the serialized form of the commercial paper state, created using the `State.serialize()` utility method.	`data`は、単純にコマーシャルペーパーのステートをシリアライズしたもので、`State.serialize()`というユーティリティメソッドを用いて作られます。
The `State` class serializes and deserializes data using JSON, and the State's business object class as required, in our case `CommercialPaper`, again set when the `PaperList` object was constructed.	`State`クラスは、JSONによってデータ、また、必要があればStateのビジネスデータのクラス(この場合は`CommercialPaper`)のシリアライズ・デシリアライズを行います。ビジネスデータのクラスもまた、`PaperList`オブジェクトが作られたときに設定されます。
Notice how a `StateList` doesn't store anything about an individual state or the total list of states -- it delegates all of that to the Fabric state database.	`StateList`自体は各ステートやステートのリストを格納せず、すべてFabricのステートデータベースに任せていることに注意してください。
This is an important design pattern -- it reduces the opportunity for [ledger MVCC collisions](../readwrite.html) in Hyperledger Fabric.	これは重要なデザインパターンで、Hyperledger Fabricにおける[台帳のMVCC衝突](../readwrite.html)の可能性を減らすことができます。
The StateList `getState()` and `updateState()` methods work in similar ways:	ステートリストの`getState()`と`updateState()`メソッドは、同じように動作します。
See how they use the Fabric APIs `putState()`, `getState()` and `createCompositeKey()` to access the ledger.	これらのメソッドが、Fabric APIである`putState()`、`getState()`、`createCompositeKey()`を使って台帳にアクセスするのを確認してください。
We'll expand this smart contract later to list all commercial papers in paperNet -- what might the method look like to implement this ledger retrieval?	後でこのスマートコントラクトをPaperNetにあるすべてのコマーシャルペーパーのリストを返すように拡張します。このとき、そのメソッドはどのような実装になるでしょうか？
That's it!	以上です！
In this topic you've understood how to implement the smart contract for PaperNet.	このトピックでは、PaperNetのスマートコントラクトをどのように実装するかを理解できました。
You can move to the next sub topic to see how an application calls the smart contract using the Fabric SDK.	次のサブトピックにうつって、アプリケーションがFabric SDKを用いてどのようにスマートコントラクトを呼ぶかを見ることができます。
End users interact with the blockchain ledger by invoking smart contracts.	エンドユーザはスマートコントラクトを呼び出すことでブロックチェーン台帳と対話します。
In Hyperledger Fabric, smart contracts are deployed in packages referred to as chaincode.	Hyperledger Fabricでは、スマートコントラクトはチェーンコードと呼ばれるパッケージでデプロイされます。
Organizations that want to validate transactions or query the ledger need to install a chaincode on their peers.	トランザクションの検証や台帳のクエリを行う組織は、チェーンコードをピアにインストールする必要があります。
After a chaincode has been installed on the peers joined to a channel, channel members can deploy the chaincode to the channel and use the smart contracts in the chaincode to create or update assets on the channel ledger.	チャネルに参加したピアにチェーンコードがインストールされると、チャネルメンバーはチェーンコードをチャネルにデプロイし、チェーンコードのスマートコントラクトを使用して、チャネル台帳のアセットを作成または更新できます。
A chaincode is deployed to a channel using a process known as the Fabric chaincode lifecycle.	チェーンコードは、Fabricチェーンコードライフサイクルと呼ばれるプロセスを使用してチャネルにデプロイされます。
The Fabric chaincode lifecycle allows multiple organizations to agree how a chaincode will be operated before it can be used to create transactions.	Fabricチェーンコードのライフサイクルでは、トランザクションの作成に使用する前に、チェーンコードの操作方法について複数の組織が合意できます。
For example, while an endorsement policy specifies which organizations need to execute a chaincode to validate a transaction, channel members need to use the Fabric chaincode lifecycle to agree on the chaincode endorsement policy.	例えば、エンドースメントポリシーは、トランザクションを検証するためにチェーンコードを実行する必要がある組織を指定しますが、チャネルメンバーは、チェーンコードエンドースメントポリシーに同意するためにFabricチェーンコードライフサイクルを使用する必要があります。
For a more in-depth overview about how to deploy and manage a chaincode on a channel, see [Fabric chaincode lifecycle](./chaincode_lifecycle.html).	チャネルでチェーンコードをデプロイおよび管理する方法の詳細については、[Fabricチェーンコードライフサイクル](./chaincode_lifecycle.html)を参照してください。
You can use this tutorial to learn how to use the [peer lifecycle chaincode commands](./commands/peerlifecycle.html) to deploy a chaincode to a channel of the Fabric test network.	このチュートリアルでは、[peer lifecycle chaincode コマンド](./commands/peerlifecycle.html)を使用して、チェーンコードをFabricテストネットワークのチャネルにデプロイする方法について学習します。
Once you have an understanding of the commands, you can use the steps in this tutorial to deploy your own chaincode to the test network, or to deploy chaincode to a production network.	コマンドを理解したら、このチュートリアルの手順を使用して、独自のチェーンコードをテストネットワークにデプロイしたり、チェーンコードを実稼動ネットワークにデプロイすることができます。
In this tutorial, you will deploy the Fabcar chaincode that is used by the [Writing your first application tutorial](./write_first_app.html).	このチュートリアルでは、[最初のアプリケーション作成チュートリアル](./write_first_app.html)で使用するFabcarチェーンコードをデプロイします。
Note: These instructions use the Fabric chaincode lifecycle introduced in the v2.0 release.	注: この手順では、v2.0リリースで導入されたFabricチェーンコードライフサイクルを使用します。
If you would like to use the previous lifecycle to install and instantiate a chaincode, visit the [v1.4 version of the Fabric documentation](https://hyperledger-fabric.readthedocs.io/en/release-1.4).	以前のライフサイクルを使用してチェーンコードをインストールおよびインスタンス化する場合は、[v1.4バージョンのFabricのマニュアル](https://hyperledger-fabric.readthedocs.io/en/release-1.4)を参照してください。
We will start by deploying an instance of the Fabric test network.	まず、Fabricテストネットワークのインスタンスをデプロイします。
Before you begin, make sure that that you have installed the [Prerequisites](prereqs.html) and [Installed the Samples, Binaries and Docker Images](install.html).	作業を始める前に、[前提条件](prereqs.html)と[サンプル、バイナリ、Dockerイメージ](install.html)がインストールされていることを確認してください。
Use the following command to navigate to the test network directory within your local clone of the `fabric-samples` repository:	次のコマンドを使用して、`fabric-samples`リポジトリのローカルクローン内のtest networkディレクトリに移動します:
cd fabric-samples/test-network	cd fabric-samples/test-network
For the sake of this tutorial, we want to operate from a known initial state.	このチュートリアルでは、既知の初期状態から操作します。
The following command will kill any active or stale docker containers and remove previously generated artifacts.	次のコマンドは、アクティブまたは古いDockerコンテナを削除し、以前に生成されたアーティファクトを削除します。
./network.sh down	./network.sh down
You can then use the following command to start the test network:	次のコマンドを使用して、テストネットワークを起動できます:
./network.sh up createChannel	./network.sh up createChannel
The `createChannel` command creates a channel named ``mychannel`` with two channel members, Org1 and Org2.	`createChannel`コマンドは、Org1とOrg2という2つのチャネルメンバを持つ``mychannel``という名前のチャネルを作成します。
The command also joins a peer that belongs to each organization to the channel.	また、このコマンドは、各組織に属するピアをチャネルに参加させます。
If the network and the channel are created successfully, you can see the following message printed in the logs:	ネットワークとチャネルが正常に作成されると、次のメッセージがログに出力されます:
========= Channel successfully joined ===========	========= Channel successfully joined ===========
We can now use the Peer CLI to deploy the Fabcar chaincode to the channel using the following steps:	これで、ピアCLIを使用して、次の手順に従ってFabcarチェーンコードをチャネルにデプロイできます:
This step is not required but is extremely useful for troubleshooting chaincode.	この手順は必須ではありませんが、チェーンコードのトラブルシューティングに非常に役立ちます。
To monitor the logs of the smart contract, an administrator can view the aggregated output from a set of Docker containers using the `logspout` [tool](https://logdna.com/what-is-logspout/).	スマートコントラクトのログを監視するために、管理者は`logspout`[ツール](https://logdna.com/what-is-logspout/)を使用して、一連のDockerコンテナから集約された出力を表示することができます。
The tool collects the output streams from different Docker containers into one place, making it easy to see what's happening from a single window.	このツールは、さまざまなDockerコンテナからの出力ストリームを1つの場所に集め、1つのウィンドウで何が起きているかを簡単に見ることができます。
This can help administrators debug problems when they install smart contracts or developers when they invoke smart contracts.	これは、管理者がスマートコントラクトをインストールするときに問題をデバッグしたり、開発者がスマートコントラクトを呼び出すときに問題をデバッグしたりするのに役立ちます。
Because some containers are created purely for the purposes of starting a smart contract and only exist for a short time, it is helpful to collect all of the logs from your network.	一部のコンテナの中には、スマートコントラクトを開始するためだけに作成され、短時間しか存在しない場合もあるため、ネットワークからすべてのログを収集すると便利です。
A script to install and configure Logspout, `monitordocker.sh`, is already included in the `commercial-paper` sample in the Fabric samples.	Logspoutをインストールして構成するスクリプト`monitordocker.sh`は、すでにFabricサンプルの`commercial-paper`サンプルに含まれています。
We will use the same script in this tutorial as well.	このチュートリアルでも同じスクリプトを使用します。
The Logspout tool will continuously stream logs to your terminal, so you will need to use a new terminal window.	Logspoutツールは、端末に継続的にログをストリームするため、新しい端末ウィンドウを使用する必要があります。
Open a new terminal and navigate to the `test-network` directory.	新しい端末を開き、`test-network`ディレクトリに移動します。
cd fabric-samples/test-network	cd fabric-samples/test-network
You can run the `monitordocker.sh` script from any directory.	`monitordocker.sh`スクリプトは、任意のディレクトリから実行できます。
For ease of use, we will copy the `monitordocker.sh` script from the `commercial-paper` sample to your working directory	使いやすいように、`monitordocker.sh`スクリプトを`commercial-paper`のサンプルから作業ディレクトリにコピーします。
cp ../commercial-paper/organization/digibank/configuration/cli/monitordocker.sh .	cp ../commercial-paper/organization/digibank/configuration/cli/monitordocker.sh .
You can then start Logspout by running the following command:	次のコマンドを実行すると、Logspoutを起動できます:
./monitordocker.sh net_test	./monitordocker.sh net_test
You should see output similar to the following:	次のような出力が表示されます:
You will not see any logs at first, but this will change when we deploy our chaincode.	最初はログは表示されませんが、チェーンコードをデプロイすると変更されます。
It can be helpful to make this terminal window wide and the font small.	このターミナルウィンドウを広くして、フォントを小さくすると便利です。
We need to package the chaincode before it can be installed on our peers.	チェーンコードは、ピアにインストールする前にパッケージ化する必要があります。
The steps are different if you want to install a smart contract written in [Go](#go), [Java](#java), or [JavaScript](#javascript).	[Go](#go)、[Java](#java)、または[JavaScript](#javascript)で作成されたスマートコントラクトをインストールする場合は、手順が異なります。
Before we package the chaincode, we need to install the chaincode dependences.	チェーンコードをパッケージ化する前に、チェーンコードの依存関係をインストールする必要があります。
Navigate to the folder that contains the Go version of the Fabcar chaincode.	GoバージョンのFabcarチェーンコードが格納されているフォルダに移動します。
cd fabric-samples/chaincode/fabcar/go	cd fabric-samples/chaincode/fabcar/go
The sample uses a Go module to install the chaincode dependencies.	このサンプルでは、Goモジュールを使用してチェーンコードの依存関係をインストールします。
The dependencies are listed in a `go.mod` file in the `fabcar/go` directory.	依存関係は、`fabcar/go`ディレクトリの`go.mod`ファイルにリストされています。
You should take a moment to examine this file.	このファイルを確認してください。
The `go.mod` file imports the Fabric contract API into the smart contract package.	`go.mod`ファイルは、Fabric コントラクトAPIをスマートコントラクトパッケージにインポートします。
You can open `fabcar.go` in a text editor to see how the contract API is used to define the `SmartContract` type at the beginning of the smart contract:	`fabcar.go`をテキストエディタで開き、スマートコントラクトの開始時にコントラクトAPIを使用して`SmartContract`タイプを定義する方法を確認します:
The ``SmartContract`` type is then used to create the transaction context for the functions defined within the smart contract that read and write data to the blockchain ledger.	次に、``SmartContract``タイプを使用して、スマートコントラクト内で定義され、ブロックチェーン台帳にデータを読み書きする関数のトランザクションコンテキストを作成します。
You can learn more about the Go contract API by visiting the [API documentation](https://github.com/hyperledger/fabric-contract-api-go) and the [smart contract processing topic](developapps/smartcontract.html).	GoコントラクトAPIの詳細については、[APIドキュメント](https://github.com/hyperledger/fabric-contract-api-go)と[スマートコントラクト処理のトピック](developapps/smartcontract.html)を参照してください。
To install the smart contract dependencies, run the following command from the `fabcar/go` directory.	スマートコントラクトの依存関係をインストールするには、`fabcar/go`ディレクトリから次のコマンドを実行します。
GO111MODULE=on go mod vendor	GO111MODULE=on go mod vendor
If the command is successful, the go packages will be installed inside a `vendor` folder.	コマンドが正常に実行されると、goパッケージは`vendor`フォルダ内にインストールされます。
Now that we that have our dependences, we can create the chaincode package.	これで依存関係ができたので、チェーンコードパッケージを作成することができます。
Navigate back to our working directory in the `test-network` folder so that we can package the chaincode together with our other network artifacts.	`test-network`フォルダの作業ディレクトリに戻り、他のネットワークのアーティファクトと一緒にチェーンコードをパッケージ化できるようにします。
cd ../../../test-network	cd ../../../test-network
You can use the `peer` CLI to create a chaincode package in the required format.	`peer` CLIを使用して、必要な形式のチェーンコードパッケージを作成できます。
The `peer` binaries are located in the `bin` folder of the `fabric-samples` repository.	`peer`バイナリは、`fabric-samples`リポジトリの`bin`フォルダにあります。
Use the following command to add those binaries to your CLI Path:	これらのバイナリをCLIパスに追加するには、次のコマンドを使用します。
export PATH=${PWD}/../bin:$PATH	export PATH=${PWD}/../bin:$PATH
You also need to set the `FABRIC_CFG_PATH` to point to the `core.yaml` file in the `fabric-samples` repository:	また、`fabric-samples`リポジトリの`core.yaml`ファイルをポイントするように`FABRIC_CFG_PATH`を設定する必要があります:
export FABRIC_CFG_PATH=$PWD/../config/	export FABRIC_CFG_PATH=$PWD/../config/
To confirm that you are able to use the `peer` CLI, check the version of the binaries.	`peer` CLIを使用できることを確認するには、バイナリのバージョンを確認します。
The binaries need to be version `2.0.0` or later to run this tutorial.	このチュートリアルを実行するには、バイナリのバージョンが`2.0.0`以降である必要があります。
peer version	peer version
You can now create the chaincode package using the [peer lifecycle chaincode package](commands/peerlifecycle.html#peer-lifecycle-chaincode-package) command:	[peer lifecycle chaincode package](commands/peerlifecycle.html#peer-lifecycle-chaincode-package)コマンドを使用して、チェーンコードパッケージを作成できるようになりました:
peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/go/ --lang golang --label fabcar_1	peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/go/ --lang golang --label fabcar_1
This command will create a package named ``fabcar.tar.gz`` in your current directory.	このコマンドは、現在のディレクトリに``fabcar.tar.gz``という名前のパッケージを作成します。
The `--lang` flag is used to specify the chaincode language and the `--path` flag provides the location of your smart contract code.	`--lang`フラグはチェーンコード言語を指定するために使用され、`--path`フラグはスマートコントラクトコードの場所を提供します。
The path must be a fully qualified path or a path relative to your present working directory.	パスは、完全修飾パスまたは現在の作業ディレクトリからの相対パスである必要があります。
The `--label` flag is used to specify a chaincode label that will identity your chaincode after it is installed.	`--label`フラグを使用して、インストール後にチェーンコードを識別するチェーンコードラベルを指定します。
It is recommended that your label include the chaincode name and version.	ラベルには、チェーンコード名とバージョンを含めることをお勧めします。
Now that we created the chaincode package, we can [install the chaincode](#install-the-chaincode-package) on the peers of the test network.	これで、チェーンコードパッケージが作成されたので、テストネットワークのピアに[チェーンコードをインストール](#install-the-chaincode-package)できます。
Before we package the chaincode, we need to install the chaincode dependences.	チェーンコードをパッケージ化する前に、チェーンコードの依存関係をインストールする必要があります。
Navigate to the folder that contains the JavaScript version of the Fabcar chaincode.	JavaScriptバージョンのFabcarチェーンコードが格納されているフォルダに移動します。
cd fabric-samples/chaincode/fabcar/javascript	cd fabric-samples/chaincode/fabcar/javascript
The dependencies are listed in the `package.json` file in the `fabcar/javascript` directory.	依存関係は、`fabcar/javascript`ディレクトリの`package.json`ファイルにリストされます。
You should take a moment to examine this file.	このファイルを確認してください。
You can find the dependences section displayed below:	依存関係のセクションは次のとおりです。
The `package.json` file imports the Fabric contract class into the smart contract package.	`package.json`ファイルは、Fabricコントラクトクラスをスマートコントラクトパッケージにインポートします。
You can open `lib/fabcar.js` in a text editor to see the contract class imported into the smart contract and used to create the FabCar class.	`lib/fabcar.js`をテキストエディタで開くと、コントラクトクラスがスマートコントラクトにインポートされ、FabCarクラスの作成に使用されていることが確認できます。
The ``FabCar`` class provides the transaction context for the functions defined within the smart contract that read and write data to the blockchain ledger.	``FabCar``クラスは、ブロックチェーン台帳へデータを読み書きするスマートコントラクト内で定義された関数のトランザクションコンテキストを提供します。
You can learn more about the JavaScript contract API by visiting the [API documentation](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/) and the [smart contract processing topic](developapps/smartcontract.html).	JavaScriptコントラクトAPIの詳細については、[APIドキュメント](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/)と[スマートコントラクト処理のトピック](developapps/smartcontract.html)を参照してください。
To install the smart contract dependencies, run the following command from the `fabcar/javascript` directory.	スマートコントラクトの依存関係をインストールするには、`fabcar/javascript`ディレクトリから次のコマンドを実行します。
npm install	npm install
If the command is successful, the JavaScript packages will be installed inside a `npm_modules` folder.	コマンドが正常に実行されると、JavaScriptパッケージは`node_modules`フォルダ内にインストールされます。
Now that we that have our dependences, we can create the chaincode package.	これで依存関係ができたので、チェーンコードパッケージを作成することができます。
Navigate back to our working directory in the `test-network` folder so that we can package the chaincode together with our other network artifacts.	`test-network`フォルダーの作業ディレクトリに戻り、他のネットワークのアーティファクトと一緒にチェーンコードをパッケージ化できるようにします。
cd ../../../test-network	cd ../../../test-network
You can use the `peer` CLI to create a chaincode package in the required format.	`peer` CLIを使用して、必要なフォーマットでチェーンコードパッケージを作成できます。
The `peer` binaries are located in the `bin` folder of the `fabric-samples` repository.	`peer`バイナリは`fabric-samples`リポジトリの`bin`フォルダにあります。
Use the following command to add those binaries to your CLI Path:	これらのバイナリをCLIパスに追加するには、次のコマンドを使用します:
export PATH=${PWD}/../bin:$PATH	export PATH=${PWD}/../bin:$PATH
You also need to set the `FABRIC_CFG_PATH` to point to the `core.yaml` file in the `fabric-samples` repository:	また、`fabric-samples`リポジトリの`core.yaml`ファイルを指すように`FABRIC_CFG_PATH`を設定する必要があります:
export FABRIC_CFG_PATH=$PWD/../config/	export FABRIC_CFG_PATH=$PWD/../config/
To confirm that you are able to use the `peer` CLI, check the version of the binaries.	`peer` CLIを使用できることを確認するには、バイナリのバージョンをチェックしてください。
The binaries need to be version `2.0.0` or later to run this tutorial.	このチュートリアルを実行するには、バイナリのバージョンが`2.0.0`以降である必要があります。
peer version	peer version
You can now create the chaincode package using the [peer lifecycle chaincode package](commands/peerlifecycle.html#peer-lifecycle-chaincode-package) command:	[peer lifecycle chaincode package](commands/peerlifecycle.html#peer-lifecycle-chaincode-package)コマンドを使用して、チェーンコードパッケージを作成できるようになりました:
peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/javascript/ --lang node --label fabcar_1	peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/javascript/ --lang node --label fabcar_1
This command will create a package named ``fabcar.tar.gz`` in your current directory.	このコマンドは、現在のディレクトリに``fabcar.tar.gz``という名前のパッケージを作成します。
The `--lang` flag is used to specify the chaincode language and the `--path` flag provides the location of your smart contract code.	`--lang`フラグはチェーンコード言語を指定するために使用され、`--path`フラグはスマートコントラクトコードの場所を提供します。
The `--label` flag is used to specify a chaincode label that will identity your chaincode after it is installed.	`--label`フラグを使用して、インストール後にチェーンコードを識別するチェーンコードラベルを指定します。
It is recommended that your label include the chaincode name and version.	ラベルには、チェーンコード名とバージョンを含めることをお勧めします。
Now that we created the chaincode package, we can [install the chaincode](#install-the-chaincode-package) on the peers of the test network.	これで、チェーンコードパッケージが作成されたので、テストネットワークのピアに[チェーンコードをインストール](#install-the-chaincode-package)できます。
Before we package the chaincode, we need to install the chaincode dependences.	チェーンコードをパッケージ化する前に、チェーンコードの依存関係をインストールする必要があります。
Navigate to the folder that contains the Java version of the Fabcar chaincode.	JavaバージョンのFabcarチェーンコードが格納されているフォルダに移動します。
cd fabric-samples/chaincode/fabcar/java	cd fabric-samples/chaincode/fabcar/java
The sample uses Gradle to install the chaincode dependencies.	このサンプルでは、Gradleを使用してチェーンコードの依存関係をインストールします。
The dependencies are listed in the `build.gradle` file in the `fabcar/java` directory.	依存関係は、`fabcar/java`ディレクトリの`build.gradle`ファイルにリストされます。
You should take a moment to examine this file.	このファイルを確認してください。
You can find the dependences section displayed below:	依存関係のセクションは次のとおりです:
The `build.gradle` file imports the Java chaincode shim into the smart contract package, which includes the contract class.	`build.gradle`ファイルは、コントラクトクラスを含むスマートコントラクトパッケージにJavaチェーンコードのshimをインポートします。
You can find Fabcar smart contract in the `src` directory.	Fabcarスマートコントラクトは`src`ディレクトリにあります。
You can navigate to the `FabCar.java` file and open it in a text editor to see how the contract class is used to create the transaction context for the functions defined that read and write data to the blockchain ledger.	`FabCar.java`ファイルに移動してテキストエディタで開き、ブロックチェーン台帳にデータを読み書きするように定義された関数のトランザクションコンテキストを作成するために、コントラクトクラスがどのように使用されるかを確認できます。
You can learn more about the Java chaincode shim and the contract class by visiting the [Java chaincode documentation](https://hyperledger.github.io/fabric-chaincode-java/{BRANCH}/api/) and the [smart contract processing topic](developapps/smartcontract.html).	Java chaincode shimとcontractクラスの詳細については、[Java chaincodeのドキュメント](https://hyperledger.github.io/fabric-chaincode-java/{BRANCH}/api/)と[smart contract processingトピック](developapps/smartcontract.html)を参照してください。
To install the smart contract dependencies, run the following command from the `fabcar/java` directory.	スマートコントラクトの依存関係をインストールするには、`fabcar/java`ディレクトリから次のコマンドを実行します。
./gradlew installDist	./gradlew installDist
If the command is successful, you will be able to find the built smart contract in the `build` folder.	コマンドが正常に実行されると、構築されたスマートコントラクトが`build`フォルダに出力されます。
Now that we have installed the dependences and built the smart contract, we can create the chaincode package.	依存関係をインストールしてスマートコントラクトを構築したところで、チェーンコードパッケージを作成することができます。
Navigate back to our working directory in the `test-network` folder so that we can package the chaincode together with our other network artifacts.	`test-network`フォルダーの作業ディレクトリに戻り、他のネットワークのアーティファクトと一緒にチェーンコードをパッケージ化できるようにします。
cd ../../../test-network	cd ../../../test-network
You can use the `peer` CLI to create a chaincode package in the required format.	`peer` CLIを使用して、必要なフォーマットでチェーンコードパッケージを作成できます。
The `peer` binaries are located in the `bin` folder of the `fabric-samples` repository.	`peer`バイナリは`fabric-samples`リポジトリの`bin`フォルダにあります。
Use the following command to add those binaries to your CLI Path:	これらのバイナリをCLIパスに追加するには、次のコマンドを使用します:
export PATH=${PWD}/../bin:$PATH	export PATH=${PWD}/../bin:$PATH
You also need to set the `FABRIC_CFG_PATH` to point to the `core.yaml` file in the `fabric-samples` repository:	また、`fabric-samples`リポジトリの`core.yaml`ファイルを指すように`FABRIC_CFG_PATH`を設定する必要があります:
export FABRIC_CFG_PATH=$PWD/../config/	export FABRIC_CFG_PATH=$PWD/../config/
To confirm that you are able to use the `peer` CLI, check the version of the binaries.	`peer` CLIを使用できることを確認するには、バイナリのバージョンをチェックしてください。
The binaries need to be version `2.0.0` or later to run this tutorial.	このチュートリアルを実行するには、バイナリのバージョンが`2.0.0`以降である必要があります。
You can now create the chaincode package using the [peer lifecycle chaincode package](commands/peerlifecycle.html#peer-lifecycle-chaincode-package) command:	[peer lifecycle chaincode package](commands/peerlifecycle.html#peer-lifecycle-chaincode-package)コマンドを使用して、チェーンコードパッケージを作成できるようになりました:
peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/java/build/install/fabcar --lang java --label fabcar_1	peer lifecycle chaincode package fabcar.tar.gz --path ../chaincode/fabcar/java/build/install/fabcar --lang java --label fabcar_1
This command will create a package named ``fabcar.tar.gz`` in your current directory.	このコマンドは、現在のディレクトリに``fabcar.tar.gz``という名前のパッケージを作成します。
The `--lang` flag is used to specify the chaincode language and the `--path` flag provides the location of your smart contract code.	`--lang`フラグはチェーンコード言語を指定するために使用され、`--path`フラグはスマートコントラクトコードの場所を提供します。
The `--label` flag is used to specify a chaincode label that will identity your chaincode after it is installed.	`--label`フラグを使用して、インストール後にチェーンコードを識別するチェーンコードラベルを指定します。
It is recommended that your label include the chaincode name and version.	ラベルには、チェーンコード名とバージョンを含めることをお勧めします。
Now that we created the chaincode package, we can [install the chaincode](#install-the-chaincode-package) on the peers of the test network.	これで、チェーンコードパッケージが作成されたので、テストネットワークのピアに[チェーンコードをインストール](#install-the-chaincode-package)できます。
After we package the Fabcar smart contract, we can install the chaincode on our peers.	Fabcarスマートコントラクトをパッケージ化したら、チェーンコードをピアにインストールできます。
The chaincode needs to be installed on every peer that will endorse a transaction.	チェーンコードは、トランザクションを承認するすべてのピアにインストールする必要があります。
Because we are going to set the endorsement policy to require endorsements from both Org1 and Org2, we need to install the chaincode on the peers operated by both organizations:	ここでは、Org1とOrg2の両方からのエンドースメントを必要とするエンドースメントポリシーを設定するので、両方の組織が運営するピアにチェーンコードをインストールする必要があります:
peer0.org1.example.com	peer0.org1.example.com
Let's install the chaincode on the Org1 peer first.	最初に、Org1ピアにチェーンコードをインストールしましょう。
Set the following environment variables to operate the `peer` CLI as the Org1 admin user.	`peer` CLIをOrg1管理ユーザとして操作するには、次の環境変数を設定します。
The `CORE_PEER_ADDRESS` will be set to point to the Org1 peer, `peer0.org1.example.com`.	`CORE_PEER_ADDRESS`は、Org1ピアである`peer0.org1.example.com`を指すように設定されます。
export CORE_PEER_TLS_ENABLED=true	export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"	export CORE_PEER_LOCALMSPID="Org1MSP"
Issue the [peer lifecycle chaincode install](commands/peerlifecycle.html#peer-lifecycle-chaincode-install) command to install the chaincode on the peer:	[peer lifecycle chaincode install](commands/peerlifecycle.html#peer-lifecycle-chaincode-install)コマンドを発行して、チェーンコードをピアにインストールします:
peer lifecycle chaincode install fabcar.tar.gz	peer lifecycle chaincode install fabcar.tar.gz
If the command is successful, the peer will generate and return the package identifier.	コマンドが成功すると、ピアはパッケージ識別子を生成して返します。
This package ID will be used to approve the chaincode in the next step.	このパッケージIDは、次のステップでチェーンコードを承認するために使用されます。
You should see output similar to the following:	次のような出力が表示されます:
We can now install the chaincode on the Org2 peer.	これで、Org2ピアにチェーンコードをインストールできます。
Set the following environment variables to operate as the Org2 admin and target target the Org2 peer, `peer0.org2.example.com`.	次の環境変数を設定して、Org2管理者として動作し、Org2ピアである`peer0.org2.example.com`をターゲットにします。
export CORE_PEER_LOCALMSPID="Org2MSP"	export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt	export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
Issue the following command to install the chaincode:	次のコマンドを発行して、チェーンコードをインストールします:
peer lifecycle chaincode install fabcar.tar.gz	peer lifecycle chaincode install fabcar.tar.gz
The chaincode is built by the peer when the chaincode is installed.	チェーンコードは、チェーンコードのインストール時にピアによって構築されます。
The install command will return any build errors from the chaincode if there is a problem with the smart contract code.	スマートコントラクトコードに問題がある場合、installコマンドはチェーンコードからビルドエラーを返します。
After you install the chaincode package, you need to approve a chaincode definition for your organization.	チェーンコードパッケージをインストールしたら、組織のチェーンコード定義を承認する必要があります。
The definition includes the important parameters of chaincode governance such as the name, version, and the chaincode endorsement policy.	定義には、名前、バージョン、チェーンコードエンドースメントポリシーなど、チェーンコードガバナンスの重要なパラメータが含まれます。
The set of channel members who need to approve a chaincode before it can be deployed is governed by the `Application/Channel/lifeycleEndorsement` policy.	デプロイする前にチェーンコードを承認する必要があるチャネルメンバのセットは、`/Channel/Application/LifecycleEndorsement`ポリシーによって管理されます。
By default, this policy requires that a majority of channel members need to approve a chaincode before it can used on a channel.	デフォルトでは、このポリシーでは、チャネルで使用する前に、チャネルメンバーの過半数がチェーンコードを承認する必要があります。
Because we have only two organizations on the channel, and a majority of 2 is 2, we need approve a chaincode definition of Fabcar as Org1 and Org2.	チャネルには組織が2つしかなく、2の過半数が2であるため、Org1およびOrg2がFabcarのチェーンコード定義を承認する必要があります。
If an organization has installed the chaincode on their peer, they need to include the packageID in the chaincode definition approved by their organization.	組織がチェーンコードをピアにインストールした場合、組織が承認したチェーンコード定義にパッケージIDを含める必要があります。
The package ID is used to associate the chaincode installed on a peer with an approved chaincode definition, and allows an organization to use the chaincode to endorse transactions.	パッケージIDは、ピアにインストールされたチェーンコードを承認済みのチェーンコード定義に関連付けるために使用され、組織がチェーンコードを使用してトランザクションをエンドースできるようにします。
You can find the package ID of a chaincode by using the [peer lifecycle chaincode queryinstalled](commands/peerlifecycle.html#peer-lifecycle-chaincode-queryinstalled) command to query your peer.	チェーンコードのパッケージIDを検索するには、[peer lifecycle chaincode queryinstalled](commands/peerlifecycle.html#peer-lifecycle-chaincode-queryinstalled)コマンドを使用してピアに照会します。
peer lifecycle chaincode queryinstalled	peer lifecycle chaincode queryinstalled
The package ID is the combination of the chaincode label and a hash of the chaincode binaries.	パッケージIDは、チェーンコードラベルとチェーンコードバイナリのハッシュの組み合わせです。
Every peer will generate the same package ID.	すべてのピアが同じパッケージIDを生成します。
You should see output similar to the following:	次のような出力が表示されます:
Installed chaincodes on peer:	Installed chaincodes on peer:
Package ID: fabcar_1:69de748301770f6ef64b42aa6bb6cb291df20aa39542c3ef94008615704007f3, Label: fabcar_1	Package ID: fabcar_1:69de748301770f6ef64b42aa6bb6cb291df20aa39542c3ef94008615704007f3, Label: fabcar_1
We are going to use the package ID when we approve the chaincode, so let's go ahead and save it as an environment variable.	パッケージIDは、チェーンコードを承認するときに使用するので、環境変数として保存します。
Paste the package ID returned by `peer lifecycle chaincode queryinstalled` into the command below.	`peer lifecycle chaincode queryinstalled`から返されたパッケージIDを、次のコマンドに貼り付けます。
Note: The package ID will not be the same for all users, so you need to complete this step using the package ID returned from your command window in the previous step.	注: パッケージIDはすべてのユーザで同じではないため、前の手順でコマンドウィンドウから返されたパッケージIDを使用してこの手順を完了する必要があります。
export CC_PACKAGE_ID=fabcar_1:69de748301770f6ef64b42aa6bb6cb291df20aa39542c3ef94008615704007f3	export CC_PACKAGE_ID=fabcar_1:69de748301770f6ef64b42aa6bb6cb291df20aa39542c3ef94008615704007f3
Because the environment variables have been set to operate the `peer` CLI as the Org2 admin, we can approve the chaincode definition of Fabcar as Org2.	環境変数は`peer` CLIをOrg2管理者として動作するように設定されているため、Fabcarのチェーンコード定義をOrg2として承認できます。
Chaincode is approved at the organization level, so the command only needs to target one peer.	チェーンコードは組織レベルで承認されるため、コマンドは1つのピアのみをターゲットにする必要があります。
The approval is distributed to the other peers within the organization using gossip.	承認は、ゴシップを使用して組織内の他のピアに配布されます。
Approve the chaincode definition using the [peer lifecycle chaincode approveformyorg](commands/peerlifecycle.html#peer-lifecycle-chaincode-approveformyorg) command:	次のように、[peer lifecycle chaincode approveformyorg](commands/peerlifecycle.html#peer-lifecycle-chaincode-approveformyorg)コマンドを使用して、チェーンコード定義を承認します:
The command above uses the `--package-id` flag to include the package identifier in the chaincode definition.	上記のコマンドは、`--package-id`フラグを使用して、パッケージ識別子をチェーンコード定義に含めます。
The `--sequence` parameter is an integer that keeps track of the number of times a chaincode has been defined or updated.	`--sequence`パラメータは、チェーンコードが定義または更新された回数を追跡する整数です。
Because the chaincode is being deployed to the channel for the first time, the sequence number is 1.	チェーンコードはチャネルに初めてデプロイされるため、シーケンス番号は1です。
When the Fabcar chaincode is upgraded, the sequence number will be incremented to 2.	Fabcarチェーンコードがアップグレードされると、シーケンス番号が2に増分されます。
If you are using the low level APIs provided by the Fabric Chaincode Shim API, you could pass the `--init-required` flag to the command above to request the execution of the Init function to initialize the chaincode.	Fabric Chaincode Shim APIで提供される低レベルのAPIを使用している場合は、上記のコマンドに`--init-required`フラグを渡して、Init関数の実行を要求し、チェーンコードを初期化できます。
The first invoke of the chaincode would need to target the Init function and include the `--isInit` flag before you could use the other functions in the chaincode to interact with the ledger.	チェーンコードの最初の呼び出しは、チェーンコードの他の関数を使用して台帳と対話する前に、Init関数をターゲットにし、`--isInit`フラグを含める必要があります。
We could have provided a ``--signature-policy`` or ``--channel-config-policy`` argument to the `approveformyorg` command to specify a chaincode endorsement policy.	`approveformyorg`コマンドに``--signature-policy``または``--channel-config-policy``引数を指定して、チェーンコードエンドースメントポリシーを指定できます。
The endorsement policy specifies how many peers belonging to different channel members need to validate a transaction against a given chaincode.	エンドースメントポリシーは、異なるチャネルメンバに属するいくつのピアが、当該のチェーンコードに対してトランザクションを検証する必要があるかを指定します。
Because we did not set a policy, the definition of Fabcar will use the default endorsement policy, which requires that a transaction be endorsed by a majority of channel members present when the transaction is submitted.	我々はポリシーを設定しなかったので、Fabcarの定義ではデフォルトのエンドースメントポリシーを使用します。このポリシーでは、トランザクションが提出されたときに、存在しているチャネルメンバーの過半数によってトランザクションがエンドースされることが要求されます。
This implies that if new organizations are added or removed from the channel, the endorsement policy is updated automatically to require more or fewer endorsements.	つまり、新しい組織がチャネルに追加されたり、チャネルから削除されたりすると、エンドースメントポリシーが自動的に更新され、より多くのエンドースメントが必要になったり、より少ないエンドースメントが必要になったりします。
In this tutorial, the default policy will require a majority of 2 out of 2 and transactions will need to be endorsed by a peer from Org1 and Org2.	このチュートリアルでは、デフォルトポリシーは2つのうちの2つの過半数を必要とし、トランザクションはOrg1とOrg2のピアによって承認される必要があります。
If you want to specify a custom endorsement policy, you can use the [Endorsement Policies](endorsement-policies.html) operations guide to learn about the policy syntax.	ユーザー設定のエンドースメントポリシーを指定する場合は、[エンドースメントポリシー](endorsement-policies.html)操作ガイドを使用して、ポリシー構文について学習できます。
You need to approve a chaincode definition with an identity that has an admin role.	管理者ロールを持つアイデンティティでチェーンコード定義を承認する必要があります。
As a result, the `CORE_PEER_MSPCONFIGPATH` variable needs to point to the MSP folder that contains an admin identity.	その結果、`CORE_PEER_MSPCONFIGPATH`変数は、管理者アイデンティティを含むMSPフォルダをポイントする必要があります。
You cannot approve a chaincode definition with a client user.	チェーンコード定義は、クライアントユーザで承認することはできません。
The approval needs to be submitted to the ordering service, which will validate the admin signature and then distribute the approval to your peers.	承認をオーダリングサービスに送信する必要があります。オーダリングサービスは管理者の署名を検証し、承認をピアに配布します。
We still need to approve the chaincode definition as Org1.	チェーンコード定義をOrg1として承認する必要があります。
Set the following environment variables to operate as the Org1 admin:	Org1管理者として動作するように、次の環境変数を設定します:
export CORE_PEER_LOCALMSPID="Org1MSP"	export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp	export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt	export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_ADDRESS=localhost:7051	export CORE_PEER_ADDRESS=localhost:7051
You can now approve the chaincode definition as Org1.	これで、チェーンコード定義をOrg1として承認できます。
We now have the majority we need to deploy the Fabcar the chaincode to the channel.	これで、チャネルにFabcarチェーンコードをデプロイする必要がある多数のユーザができました。
While only a majority of organizations need to approve a chaincode definition (with the default policies), all organizations need to approve a chaincode definition to start the chaincode on their peers.	(デフォルトのポリシーでは)組織の過半数だけがチェーンコード定義を承認する必要がありますが、すべての組織がチェーンコード定義を承認して、ピアでチェーンコードを開始する必要があります。
If you commit the definition before a channel member has approved the chaincode, the organization will not be able to endorse transactions.	チャネルメンバーがチェーンコードを承認する前に定義をコミットすると、組織はトランザクションをエンドースできなくなります。
As a result, it is recommended that all channel members approve a chaincode before committing the chaincode definition.	そのため、チェーンコード定義をコミットする前に、すべてのチャネルメンバがチェーンコードを承認することをお勧めします。
After a sufficient number of organizations have approved a chaincode definition, one organization can commit the chaincode definition to the channel.	十分な数の組織がチェーンコード定義を承認すると、1つの組織がチェーンコード定義をチャネルにコミットできます。
If a majority of channel members have approved the definition, the commit transaction will be successful and the parameters agreed to in the chaincode definition will be implemented on the channel.	チャネルメンバの過半数が定義を承認した場合、コミットトランザクションは成功し、チェーンコード定義で合意されたパラメータがチャネルに実装されます。
You can use the [peer lifecycle chaincode checkcommitreadiness](commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness) command to check whether channel members have approved the same chaincode definition.	[peer lifecycle chaincode checkcommitreadiness](commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness)コマンドを使用すると、チャネルメンバが同じチェーンコード定義を承認しているかどうかをチェックできます。
The flags used for the `checkcommitreadiness` command are identical to the flags used to approve a chaincode for your organization.	`checkcommitreadiness`コマンドで使用するフラグは、組織のチェーンコードを承認するために使用するフラグと同じです。
However, you do not need to include the `--package-id` flag.	ただし、`--package-id`フラグを含める必要はありません。
The command will produce a JSON map that displays if a channel member has approved the parameters that were specified in the `checkcommitreadiness` command:	このコマンドは、チャネルメンバが`checkcommitreadiness`コマンドで指定されたパラメータを承認したかどうかを表示するJSONマップを生成します:
Since both organizations that are members of the channel have approved the same parameters, the chaincode definition is ready to be committed to the channel.	チャネルのメンバーである両方の組織が同じパラメータを承認しているため、チェーンコード定義をチャネルにコミットする準備ができています。
You can use the [peer lifecycle chaincode commit](commands/peerlifecycle.html#peer-lifecycle-chaincode-commit) command to commit the chaincode definition to the channel.	[peer lifecycle chaincode commit](commands/peerlifecycle.html#peer-lifecycle-chaincode-commit)コマンドを使用すると、チェーンコード定義をチャネルにコミットできます。
The commit command also needs to be submitted by an organization admin.	commitコマンドは、組織の管理者がサブミットする必要もあります。
The transaction above uses the `--peerAddresses` flag to target `peer0.org1.example.com` from Org1 and `peer0.org2.example.com` from Org2.	上記のトランザクションは、`--peerAddresses`フラグを使用して、Org1の`peer0.org1.example.com`とOrg2の`peer0.org2.example.com`をターゲットにします。
The `commit` transaction is submitted to the peers joined to the channel to query the chaincode definition that was approved by the organization that operates the peer.	`commit` トランザクションは、チャネルに参加しているピアにサブミットされ、ピアを運用する組織によって承認されたチェーンコード定義を照会します。
The command needs to target the peers from a sufficient number of organizations to satisfy the policy for deploying a chaincode.	このコマンドは、チェーンコードをデプロイするためのポリシーを満たすために、十分な数の組織からピアをターゲットにする必要があります。
Because the approval is distributed within each organization, you can target any peer that belongs to a channel member.	承認は各組織内に配布されるため、チャネルメンバーに属する任意のピアをターゲットにできます。
The chaincode definition endorsements by channel members are submitted to the ordering service to be added to a block and distributed to the channel.	チャネルメンバによるチェーンコード定義のエンドースメントは、ブロックに追加し、チャネルに配布するために、オーダリングサービスに提出されます。
The peers on the channel then validate whether a sufficient number of organizations have approved the chaincode definition.	次に、チャネル上のピアは、十分な数の組織がチェーンコード定義を承認したかどうかを検証します。
The `peer lifecycle chaincode commit` command will wait for the validations from the peer before returning a response.	`peer lifecycle chaincode commit`コマンドは、応答を返す前に、ピアからの検証を待ちます。
You can use the [peer lifecycle chaincode querycommitted](commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted) command to confirm that the chaincode definition has been committed to the channel.	チェーンコード定義がチャネルにコミットされたことを確認するには、[peer lifecycle chaincode querycommitted](commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted)コマンドを使用します。
If the chaincode was successful committed to the channel, the `querycommitted` command will return the sequence and version of the chaincode definition:	チェーンコードがチャネルに正常にコミットされた場合、`querycommitted`コマンドはチェーンコード定義のシーケンスとバージョンを返します:
After the chaincode definition has been committed to a channel, the chaincode will start on the peers joined to the channel where the chaincode was installed.	チェーンコード定義がチャネルにコミットされると、チェーンコードがインストールされたチャネルに参加しているピア上でチェーンコードが開始されます。
The Fabcar chaincode is now ready to be invoked by client applications.	これで、Fabcarチェーンコードをクライアントアプリケーションから呼び出す準備ができました。
Use the following command create an initial set of cars on the ledger.	次のコマンドを使用して、台帳に自動車の初期セットを作成します。
Note that the invoke command needs target a sufficient number of peers to meet chaincode endorsement policy.	invokeコマンドは、チェーンコードエンドースメントポリシーを満たすために十分な数のピアをターゲットにする必要があることに注意してください。
If the command is successful, you should be able to a response similar to the following:	コマンドが正常に実行されると、次のような応答が返されます:
We can use a query function to read the set of cars that were created by the chaincode:	クエリ関数を使用して、チェーンコードで作成された車のセットを読み込むことができます:
peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryAllCars"]}'	peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryAllCars"]}'
The response to the query should be the following list of cars:	クエリに対する応答は、次の自動車のリストになるはずです:
[{"Key":"CAR0","Record":{"make":"Toyota","model":"Prius","colour":"blue","owner":"Tomoko"}},	[{"Key":"CAR0","Record":{"make":"Toyota","model":"Prius","colour":"blue","owner":"Tomoko"}},
{"Key":"CAR1","Record":{"make":"Ford","model":"Mustang","colour":"red","owner":"Brad"}},	{"Key":"CAR1","Record":{"make":"Ford","model":"Mustang","colour":"red","owner":"Brad"}},
You can use the same Fabric chaincode lifecycle process to upgrade a chaincode that has already been deployed to a channel.	同じFabricチェーンコードライフサイクルプロセスを使用して、チャネルに既にデプロイされているチェーンコードをアップグレードできます。
Channel members can upgrade a chaincode by installing a new chaincode package and then approving a chaincode definition with the new package ID, a new chaincode version, and with the sequence number incremented by one.	チャネルメンバは、新しいチェーンコードパッケージをインストールし、新しいパッケージID、新しいチェーンコードバージョン、およびシーケンス番号を1つ増分したチェーンコード定義を承認することで、チェーンコードをアップグレードできます。
The new chaincode can be used after the chaincode definition is committed to the channel.	新しいチェーンコードは、チェーンコード定義がチャネルにコミットされた後に使用できます。
This process allows channel members to coordinate on when a chaincode is upgraded, and ensure that a sufficient number of channel members are ready to use the new chaincode before it is deployed to the channel.	このプロセスにより、チャネルメンバーは、チェーンコードがアップグレードされるときに調整を行うことができ、チャネルにデプロイされる前に、十分な数のチャネルメンバーが新しいチェーンコードを使用する準備ができていることを確認できます。
Channel members can also use the upgrade process to change the chaincode endorsement policy.	チャネルメンバーは、アップグレードプロセスを使用して、チェーンコードエンドースメントポリシーを変更することもできます。
By approving a chaincode definition with a new endorsement policy and committing the chaincode definition to the channel, channel members can change the endorsement policy governing a chaincode without installing a new chaincode package.	新しいエンドースメントポリシーでチェーンコード定義を承認し、そのチェーンコード定義をチャネルにコミットすることで、チャネルメンバーは新しいチェーンコードパッケージをインストールすることなく、チェーンコードを管理するエンドースメントポリシーを変更できます。
To provide a scenario for upgrading the Fabcar chaincode that we just deployed, let's assume that Org1 and Org2 would like to install a version of the chaincode that is written in another language.	デプロイしたばかりのFabcarチェーンコードをアップグレードするためのシナリオを提供するために、Org1とOrg2が別の言語で書かれたバージョンのチェーンコードをインストールしたいとします。
They will use the Fabric chaincode lifecycle to update the chaincode version and ensure that both organizations have installed the new chaincode before it becomes active on the channel.	これらの組織は、Fabricチェーンコードライフサイクルを使用してチェーンコードバージョンを更新し、新しいチェーンコードがチャネル上でアクティブになる前に両方の組織インストールされていることを確認します。
We are going to assume that Org1 and Org2 initially installed the GO version of the Fabcar chaincode, but would be more comfortable working with a chaincode written in JavaScript.	ここでは、Org1とOrg2が最初にFabcarチェーンコードのGOバージョンをインストールしたのち、JavaScriptで作成されたチェーンコードを使用する方が快適になったと想定します。
The first step is to package the JavaScript version of the Fabcar chaincode.	最初のステップは、FabcarチェーンコードのJavaScriptバージョンをパッケージ化することです。
If you used the JavaScript instructions to package your chaincode when you went through the tutorial, you can install new chaincode binaries by following the steps for packaging a chaincode written in [Go](#go) or [Java](#java).	チュートリアルの実行時にJavaScriptの指示に従ってチェーンコードをパッケージ化した場合は、[Go](#go) または [Java](#java)で記述されたチェーンコードをパッケージ化する手順に従って、新しいチェーンコードバイナリをインストールできます。
Issue the following commands from the `test-network` directory to install the chaincode dependences.	チェーンコード依存関係をインストールするには、`test-network`ディレクトリから次のコマンドを発行します。
cd ../chaincode/fabcar/javascript	cd ../chaincode/fabcar/javascript
npm install	npm install
cd ../../../test-network	cd ../../../test-network
You can then issue the following commands to package the JavaScript chaincode from the `test-network` directory.	次に、以下のコマンドを実行して、`test-network`ディレクトリからJavaScriptチェーンコードをパッケージ化することができます。
We will set the environment variables needed to use the `peer` CLI again in case you closed your terminal.	端末を閉じた場合に`peer` CLIを再度使用するために必要な環境変数を設定します。
export PATH=${PWD}/../bin:$PATH	export PATH=${PWD}/../bin:$PATH
export FABRIC_CFG_PATH=$PWD/../config/	export FABRIC_CFG_PATH=$PWD/../config/
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp	export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
peer lifecycle chaincode package fabcar_2.tar.gz --path ../chaincode/fabcar/javascript/ --lang node --label fabcar_2	peer lifecycle chaincode package fabcar_2.tar.gz --path ../chaincode/fabcar/javascript/ --lang node --label fabcar_2
Run the following commands to operate the `peer` CLI as the Org1 admin:	次のコマンドを実行して、`peer` CLIをOrg1管理者として操作します:
export CORE_PEER_TLS_ENABLED=true	export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"	export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt	export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp	export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051	export CORE_PEER_ADDRESS=localhost:7051
We can now use the following command to install the new chaincode package on the Org1 peer.	次のコマンドを使用して、新しいチェーンコードパッケージをOrg1ピアにインストールできます。
peer lifecycle chaincode install fabcar_2.tar.gz	peer lifecycle chaincode install fabcar_2.tar.gz
The new chaincode package will create a new package ID.	新しいチェーンコードパッケージは、新しいパッケージIDを作成します。
We can find the new package ID by querying our peer.	ピアに照会することで、新しいパッケージIDを見つけることができます。
peer lifecycle chaincode queryinstalled	peer lifecycle chaincode queryinstalled
The `queryinstalled` command will return a list of the chaincode that have been installed on your peer.	`queryinstalled`コマンドは、ピアにインストールされているチェーンコードのリストを返します。
Installed chaincodes on peer:	Installed chaincodes on peer:
Package ID: fabcar_1:69de748301770f6ef64b42aa6bb6cb291df20aa39542c3ef94008615704007f3, Label: fabcar_1	Package ID: fabcar_1:69de748301770f6ef64b42aa6bb6cb291df20aa39542c3ef94008615704007f3, Label: fabcar_1
Package ID: fabcar_2:1d559f9fb3dd879601ee17047658c7e0c84eab732dca7c841102f20e42a9e7d4, Label: fabcar_2	Package ID: fabcar_2:1d559f9fb3dd879601ee17047658c7e0c84eab732dca7c841102f20e42a9e7d4, Label: fabcar_2
You can use the package label to find the package ID of the new chaincode and save it as a new environment variable.	パッケージラベルを使用して、新しいチェーンコードのパッケージIDを検索し、新しい環境変数として保存できます。
export NEW_CC_PACKAGE_ID=fabcar_2:1d559f9fb3dd879601ee17047658c7e0c84eab732dca7c841102f20e42a9e7d4	export NEW_CC_PACKAGE_ID=fabcar_2:1d559f9fb3dd879601ee17047658c7e0c84eab732dca7c841102f20e42a9e7d4
Org1 can now approve a new chaincode definition:	Org1は、新しいチェーンコード定義を承認できるようになりました:
The new chaincode definition uses the package ID of the JavaScript chaincode package and updates the chaincode version.	新しいチェーンコード定義では、JavaScriptチェーンコードパッケージのパッケージIDが使用され、チェーンコードバージョンが更新されます。
Because the sequence parameter is used by the Fabric chaincode lifecycle to keep track of chaincode upgrades, Org1 also needs to increment the sequence number from 1 to 2.	シーケンスパラメータは、チェーンコードのアップグレードを追跡するためにFabricチェーンコードライフサイクルで使用されるため、Org1でもシーケンス番号を1から2に増分する必要があります。
You can use the [peer lifecycle chaincode querycommitted](commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted) command to find the sequence of the chaincode that was last committed to the channel.	[peer lifecycle chaincode querycommitted](commands/peerlifecycle.html#peer-lifecycle-chaincode-querycommitted)コマンドを使用すると、チャネルに最後にコミットされたチェーンコードのシーケンスを検索できます。
We now need to install the chaincode package and approve the chaincode definition as Org2 in order to upgrade the chaincode.	ここで、チェーンコードパッケージをインストールし、チェーンコード定義をOrg2として承認して、チェーンコードをアップグレードする必要があります。
Run the following commands to operate the `peer` CLI as the Org2 admin:	次のコマンドを実行して、`peer` CLIをOrg2管理者として操作します:
export CORE_PEER_LOCALMSPID="Org2MSP"	export CORE_PEER_LOCALMSPID="Org2MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt	export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt	export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp	export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp
export CORE_PEER_ADDRESS=localhost:9051	export CORE_PEER_ADDRESS=localhost:9051
We can now use the following command to install the new chaincode package on the Org2 peer.	次のコマンドを使用して、新しいチェーンコードパッケージをOrg2ピアにインストールできます。
peer lifecycle chaincode install fabcar_2.tar.gz	peer lifecycle chaincode install fabcar_2.tar.gz
You can now approve the new chaincode definition for Org2.	これで、Org2の新しいチェーンコード定義を承認できます。
Use the [peer lifecycle chaincode checkcommitreadiness](commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness) command to check if the chaincode definition with sequence 2 is ready to be committed to the channel:	[peer lifecycle chaincode checkcommitreadiness](commands/peerlifecycle.html#peer-lifecycle-chaincode-checkcommitreadiness)コマンドを使用して、シーケンス2のチェーンコード定義がチャネルにコミットする準備ができているかどうかを確認します:
The chaincode is ready to be upgraded if the command returns the following JSON:	コマンドが次のJSONを返す場合、チェーンコードはアップグレードの準備ができています:
The chaincode will be upgraded on the channel after the new chaincode definition is committed.	新しいチェーンコード定義がコミットされると、チャネル上のチェーンコードがアップグレードされます。
Until then, the previous chaincode will continue to run on the peers of both organizations.	それまでは、以前のチェーンコードは両方の組織のピア上で実行され続けます。
Org2 can use the following command to upgrade the chaincode:	Org2では、次のコマンドを使用してチェーンコードをアップグレードできます:
A successful commit transaction will start the new chaincode right away.	コミットトランザクションが成功すると、新しいチェーンコードがすぐに開始されます。
If the chaincode definition changed the endorsement policy, the new policy would be put in effect.	チェーンコード定義がエンドースメントポリシーを変更した場合、新しいポリシーが有効になります。
You can use the `docker ps` command to verify that the new chaincode has started on your peers:	`docker ps`コマンドを使うと、新しいチェーンコードがピア上で起動したことを確認できます:
If you used the `--init-required` flag, you need to invoke the Init function before you can use the upgraded chaincode.	`--init-required`フラグを使用した場合は、アップグレードしたチェーンコードを使用する前にInit関数を呼び出す必要があります。
Because we did not request the execution of Init, we can test our new JavaScript chaincode by creating a new car:	私たちはInitの実行を要求していないので、新しい車を作成することで新しいJavaScriptのチェーンコードをテストすることができます:
You can query all the cars on the ledger again to see the new car:	台帳のすべての車を再度クエリして、新規の車を表示できます:
peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryAllCars"]}'	peer chaincode query -C mychannel -n fabcar -c '{"Args":["queryAllCars"]}'
You should see the following result from the JavaScript chaincode:	JavaScriptチェーンコードから次のような結果が得られます:
[{"Key":"CAR0","Record":{"make":"Toyota","model":"Prius","colour":"blue","owner":"Tomoko"}},	[{"Key":"CAR0","Record":{"make":"Toyota","model":"Prius","colour":"blue","owner":"Tomoko"}},
{"Key":"CAR1","Record":{"make":"Ford","model":"Mustang","colour":"red","owner":"Brad"}},	{"Key":"CAR1","Record":{"make":"Ford","model":"Mustang","colour":"red","owner":"Brad"}},
When you are finished using the chaincode, you can also use the following commands to remove the Logspout tool.	チェーンコードの使用が終了したら、次のコマンドを使用してLogspoutツールを削除することもできます。
docker stop logspout	docker stop logspout
docker rm logspout	docker rm logspout
You can then bring down the test network by issuing the following command from the `test-network` directory:	次に、`test-network`ディレクトリから次のコマンドを発行して、テストネットワークを停止できます:
./network.sh down	./network.sh down
After you write your smart contract and deploy it to a channel, you can use the APIs provided by the Fabric SDKs to invoke the smart contracts from a client application.	スマートコントラクトを作成してチャネルにデプロイしたら、Fabric SDKが提供するAPIを使用して、クライアントアプリケーションからスマートコントラクトを呼び出すことができます。
This allows end users to interact with the assets on the blockchain ledger.	これにより、エンドユーザはブロックチェーン台帳上の資産と対話することができます。
To get started with the Fabric SDKs, see the [Writing Your first application tutorial](write_first_app.html).	Fabric SDKを使い始めるには、[Writing Your first application tutorial](write_first_app.html)を参照してください。
Problem: When I try to commit a new chaincode definition to the channel, the `peer lifecycle chaincode commit` command fails with the following error:	問題: 新しいチェーンコード定義をチャネルにコミットしようとすると、`peer lifecycle chaincode commit`コマンドが次のエラーで失敗します:
Error: failed to create signed transaction: proposal response was not successful, error code 500, msg failed to invoke backing implementation of 'CommitChaincodeDefinition': chaincode definition not agreed to by this org (Org1MSP)	Error: failed to create signed transaction: proposal response was not successful, error code 500, msg failed to invoke backing implementation of 'CommitChaincodeDefinition': chaincode definition not agreed to by this org (Org1MSP)
Solution: You can try to resolve this error by using the `peer lifecycle chaincode checkcommitreadiness` command to check which channel members have approved the chaincode definition that you are trying to commit.	解決策: このエラーを解決するには、`peer lifecycle chaincode checkcommitreadiness`コマンドを使用して、コミットしようとしているチェーンコード定義を承認したチャネルメンバをチェックします。
If any organization used a different value for any parameter of the chaincode definition, the commit transaction will fail.	チェーンコード定義のパラメータに異なる値を使用している組織がある場合、コミットトランザクションは失敗します。
The `peer lifecycle chaincode checkcommitreadiness` will reveal which organizations did not approve the chaincode definition you are trying to commit:	`peer lifecycle chaincode checkcommitreadiness`は、コミットしようとしているチェーンコード定義を承認しなかった組織を明らかにします:
Problem: The `peer lifecycle chaincode commit` transaction is successful, but when I try to invoke the chaincode for the first time, it fails with the following error:	問題: `peer lifecycle chaincode commit`トランザクションは成功しましたが、チェーンコードを初めて起動しようとすると、次のエラーで失敗します:
Error: endorsement failure during invoke. response: status:500 message:"make sure the chaincode fabcar has been successfully defined on channel mychannel and try again: chaincode definition for 'fabcar' exists, but chaincode is not installed"	Error: endorsement failure during invoke. response: status:500 message:"make sure the chaincode fabcar has been successfully defined on channel mychannel and try again: chaincode definition for 'fabcar' exists, but chaincode is not installed"
Solution: You may not have set the correct `--package-id` when you approved your chaincode definition.	解決策: チェーンコード定義を承認したときに、正しい`--package-id`を設定していない可能性があります。
As a result, the chaincode definition that was committed to the channel was not associated with the chaincode package you installed and the chaincode was not started on your peers.	その結果、チャネルにコミットされたチェーンコード定義は、インストールしたチェーンコードパッケージに関連付けられず、チェーンコードはピア上で開始されませんでした。
If you are running a docker based network, you can use the `docker ps` command to check if your chaincode is running:	Dockerベースのネットワークを使っている場合は、`docker ps`コマンドを使って、チェーンコードが動作しているかどうかをチェックすることができます:
If you do not see any chaincode containers listed, use the `peer lifecycle chaincode approveformyorg` command approve a chaincode definition with the correct package ID.	チェーンコードコンテナが一覧表示されない場合は、`peer lifecycle chaincode approveformyorg`コマンドを使用して、正しいパッケージIDでチェーンコード定義を承認します。
Problem: When I try to commit the chaincode definition to the channel, the transaction fails with the following error:	問題: チェーンコード定義をチャネルにコミットしようとすると、トランザクションが次のエラーで失敗します:
Solution: This error is a result of the commit transaction not gathering enough endorsements to meet the Lifecycle endorsement policy.	解決策: このエラーは、コミットトランザクションがライフサイクルエンドースメントポリシーを満たすだけのエンドースメントを収集していないために発生します。
This problem could be a result of your transaction not targeting a sufficient number of peers to meet the policy.	この問題は、ポリシーを満たすのに十分な数のピアをターゲットとしていないトランザクションが原因で発生する可能性があります。
This could also be the result of some of the peer organizations not including the `Endorsement:` signature policy referenced by the default `/Channel/Application/Endorsement` policy in their `configtx.yaml` file:	これは、`configtx.yaml`ファイルでデフォルトの`/Channel/Application/Endorsement` ポリシーによって参照される署名ポリシー`Endorsement:`を含まない一部のピア組織の結果である可能性もあります。
When you [enable the Fabric chaincode lifecycle](enable_cc_lifecycle.html), you also need to use the new Fabric 2.0 channel policies in addition to upgrading your channel to the `V2_0` capability.	[Fabric chaincodeライフサイクルを有効にする](enable_cc_lifecycle.html)場合は、チャネルを`V2_0`機能にアップグレードするだけでなく、新しいFabric2.0チャネルポリシーも使用する必要があります。
Your channel needs to include the new `/Channel/Application/LifecycleEndorsement` and `/Channel/Application/Endorsement` policies:	チャネルには、新しい`/Channel/Application/LifecycleEndorsement`ポリシーと`/Channel/Application/Endorsement` ポリシーを含める必要があります:
If you do not include the new channel policies in the channel configuration, you will get the following error when you approve a chaincode definition for your organization:	チャネル設定に新しいチャネルポリシーを含めない場合、組織のチェーンコード定義を承認すると、次のエラーが発生します:
Error: proposal failed with status: 500 - failed to invoke backing implementation of 'ApproveChaincodeDefinitionForMyOrg': could not set defaults for chaincode definition in channel mychannel: policy '/Channel/Application/Endorsement' must be defined for channel 'mychannel' before chaincode operations can be attempted 	Error: proposal failed with status: 500 - failed to invoke backing implementation of 'ApproveChaincodeDefinitionForMyOrg': could not set defaults for chaincode definition in channel mychannel: policy '/Channel/Application/Endorsement' must be defined for channel 'mychannel' before chaincode operations can be attempted
**Audience**: Architects, application and smart contract developers	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者
A connection profile describes a set of components, including peers, orderers and certificate authorities in a Hyperledger Fabric blockchain network.	コネクションプロファイル (Connection Profile) は、Hyperledger Fabricブロックチェーンネットワーク内のピア、Orderer、認証局などのコンポーネントのセットを記述します。
It also contains channel and organization information relating to these components.	また、これらのコンポーネントに関連するチャネルおよび組織の情報も含まれています。
A connection profile is primarily used by an application to configure a [gateway](./gateway.html) that handles all network interactions, allowing it to focus on business logic.	コネクションプロファイルは、主にアプリケーションがネットワークとのあらゆるやりとりを処理する[ゲートウェイ (Gateway)](./gateway.html) を設定するために使用され、ビジネスロジックに集中できるようにします。
A connection profile is normally created by an administrator who understands the network topology.	コネクションプロファイルは通常、ネットワークトポロジを理解している管理者によって作成されます。
In this topic, we're going to cover:	このトピックでは、以下について説明します:
[Why connection profiles are important](#scenario)	[コネクションプロファイルが重要な理由](#scenario)
[How applications use a connection profile](#usage)	[アプリケーションがコネクションプロファイルを使用する方法](#usage)
[How to define a connection profile](#structure)	[コネクションプロファイルを定義する方法](#structure)
A connection profile is used to configure a gateway.	コネクションプロファイルは、ゲートウェイを設定するために使用されます。
Gateways are important for [many reasons](./gateway.html), the primary being to simplify an application's interaction with a network channel.	ゲートウェイは[多くの理由](./gateway.html) で重要であり、主な目的はアプリケーションとネットワークチャネルとのやりとりを単純化することです。
Two applications, issue and buy, use gateways 1&2 configured with connection profiles 1&2.	2つのアプリケーションである「発行」と「購入」は、コネクションプロファイル1および2を用いて設定されたゲートウェイ1および2を使用します。
Each profile describes a different subset of MagnetoCorp and DigiBank network components.	各プロファイルは、MagnetoCorp および DigiBank ネットワークコンポーネントの異なるサブセットを記述します。
Each connection profile must contain sufficient information for a gateway to interact with the network on behalf of the issue and buy applications.	各コネクションプロファイルには、ゲートウェイが「発行」および「購入」アプリケーションに代わってネットワークとやりとりするための十分な情報が含まれている必要があります。
See the text for a detailed explanation.	詳細な説明については、テキストを参照してください。
A connection profile contains a description of a network view, expressed in a technical syntax, which can either be JSON or YAML.	コネクションプロファイルには、JSONまたはYAMLのどちらかの構文で表現されたネットワークビューの説明が含まれています。
In this topic, we use the YAML representation, as it's easier for you to read.	このトピックでは、読みやすいようにYAMLでの表現を使用します。
Static gateways need more information than dynamic gateways because the latter can use [service discovery](../discovery-overview.html) to dynamically augment the information in a connection profile.	静的ゲートウェイは動的ゲートウェイよりも多くの情報を必要とします。なぜなら、動的ゲートウェイはコネクションプロファイルの情報を動的に拡張するために[サービスディスカバリ (Service Discovery)](../discovery-overview.html) を使用できるからです。
A connection profile should not be an exhaustive description of a network channel; it just needs to contain enough information sufficient for a gateway that's using it.	コネクションプロファイルは、ネットワークチャネルの網羅的な記述であるべきではなく、それを使用しているゲートウェイにとって十分な情報を含む必要があるだけです。
In the network above, connection profile 1 needs to contain at least the endorsing organizations and peers for the `issue` transaction, as well as identifying the peers that will notify the gateway when the transaction has been committed to the ledger.	上記のネットワークでは、コネクションプロファイル1は、少なくとも `発行 (issue)` トランザクションのためのエンドーシング組織とピアを含む必要があります。また、トランザクションが台帳にコミットされたときにゲートウェイに通知するピアを特定する必要があります。
It's easiest to think of a connection profile as describing a view of the network.	コネクションプロファイルは、ネットワークの ビュー を表すものと考えるのが最も簡単です。
It could be a comprehensive view, but that's unrealistic for a few reasons:	それは包括的なビューとすることもできますが、それはいくつかの理由で非現実的です:
Peers, orderers, certificate authorities, channels, and organizations are added and removed according to demand.	ピア、Orderer、認証局、チャネル、組織は、要求に応じて追加・削除されます。
Components can start and stop, or fail unexpectedly (e.g. power outage).	コンポーネントは、起動および停止したり、予期せず障害が発生したりする可能性があります (停電など)。
A gateway doesn't need a view of the whole network, only what's necessary to successfully handle transaction submission or event notification for example.	ゲートウェイはネットワーク全体のビューを必要とせず、たとえばトランザクションの送信やイベント通知を正常に処理するために必要なものだけを必要とします。
Service Discovery can augment the information in a connection profile.	サービスディスカバリは、コネクションプロファイルの情報を拡張することができます。
Specifically, dynamic gateways can be configured with minimal Fabric topology information; the rest can be discovered.	具体的には、動的ゲートウェイは最小限のFabricトポロジ情報で設定でき、残りはサービスディスカバリで検出することができます。
A static connection profile is normally created by an administrator who understands the network topology in detail.	静的コネクションプロファイルは通常、ネットワークトポロジを詳細に理解している管理者によって作成されます。
That's because a static profile can contain quite a lot of information, and an administrator needs to capture this in the corresponding connection profile.	これは、静的プロファイルには非常に多くの情報が含まれている可能性があり、管理者は対応するコネクションプロファイルにこの情報を取り込む必要があるためです。
In contrast, dynamic profiles minimize the amount of definition required and therefore can be a better choice for developers who want to get going quickly, or administrators who want to create a more responsive gateway.	対照的に、動的プロファイルは必要な定義の量を最小限に抑えるため、早く作業を始めたい開発者や、より応答性の高いゲートウェイを作成したい管理者にとってより良い選択となります。
Connection profiles are created in either the YAML or JSON format using an editor of choice.	コネクションプロファイルは、選択したエディタを使用してYAMLまたはJSON形式で作成されます。
We'll see how to define a connection profile in a moment;	コネクションプロファイルを定義する方法をすぐに見てみましょう。
let's first see how it is used by a sample MagnetoCorp `issue` application:	まず、サンプルのMagnetoCorpの `issue` アプリケーションでどのように使用されるかを見てみましょう:
After loading some required classes, see how the `paperNet.yaml` gateway file is loaded from the file system, converted to a JSON object using the `yaml.safeLoad()` method, and used to configure a gateway using its `connect()` method.	いくつかの必要なクラスをロードした後で`yaml.safeLoad()` メソッドを使用して `paperNet.yaml` ゲートウェイファイルをファイルシステムからロード、JSONオブジェクトに変換し、`connect()` メソッドを使用してゲートウェイを設定する方法を確認します。
By configuring a gateway with this connection profile, the issue application is providing the gateway with the relevant network topology it should use to process transactions.	このコネクションプロファイルを使用してゲートウェイを設定することにより、発行アプリケーションは、トランザクションの処理に使用する必要のある関連するネットワークトポロジをゲートウェイに提供します。
That's because the connection profile contains sufficient information about the PaperNet channels, organizations, peers, orderers and CAs to ensure transactions can be successfully processed.	これは、コネクションプロファイルにPaperNetチャネル、組織、ピア、Orderer、およびCAに関する十分な情報が含まれており、トランザクションを正常に処理できるようにするためです。
It's good practice for a connection profile to define more than one peer for any given organization -- it prevents a single point of failure.	コネクションプロファイルでは、特定の組織に対して複数のピアを定義することは良い方法です。これにより、単一障害点が防止されます。
This practice also applies to dynamic gateways; to provide more than one starting point for service discovery.	この方法は、サービスディスカバリのための複数の開始点を提供するために動的ゲートウェイにも適用されます。
A DigiBank `buy` application would typically configure its gateway with a similar connection profile, but with some important differences.	DigiBankの `購入 (buy)` アプリケーションは通常、同様のコネクションプロファイルでゲートウェイを設定しますが、いくつかの重要な違いがあります。
Some elements will be the same, such as the channel; some elements will overlap, such as the endorsing peers.	チャネルなど、一部の要素は同じになります。エンドーシングピアなど、一部の要素は重複します。
Other elements will be completely different, such as notification peers or certificate authorities for example.	イベント通知に使用するピアや認証局など、他の要素は完全に異なります。
The `connectionOptions` passed to a gateway complement the connection profile.	ゲートウェイに渡される `connectionOptions` は、コネクションプロファイルを補完します。
They allow an application to declare how it would like the gateway to use the connection profile.	これにより、アプリケーションは、ゲートウェイがコネクションプロファイルを使用する方法を宣言できます。
They are interpreted by the SDK to control interaction patterns with network components, for example to select which identity to connect with, or which peers to use for event notifications.	これらはネットワークコンポーネントとのやりとりのパターンを制御するためにSDKによって解釈されます。たとえば、接続するアイデンティティや、イベント通知に使用するピアを選択します。
Read [about](./connectionoptions.html) the list of available connection options and when to use them.	使用可能なコネクションオプションのリストとそれらをいつ使用するについては [こちら](./connectionoptions.html) をお読みください。
To help you understand the structure of a connection profile, we're going to step through an example for the network shown [above](#scenario).	コネクションプロファイルの構造を理解しやすくするために、[上記](#scenario) に示されているネットワークの例を順を追って説明します。
Its connection profile is based on the PaperNet commercial paper sample, and [stored](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml) in the GitHub repository.	そのコネクションプロファイルは、PaperNetコマーシャルペーパーサンプルに基づいており、GitHubリポジトリ内に[保存](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml)されています。
For convenience, we've reproduced it [below](#sample).	便宜上、[以下](#sample) に転載しました。
You will find it helpful to display it in another browser window as you now read about it:	サンプル自体も別のブラウザウィンドウに表示しながら以下を読み進めるとわかりやすいです:
Line 9: `name: "papernet.magnetocorp.profile.sample"`	9行目: `name: "papernet.magnetocorp.profile.sample"`
This is the name of the connection profile.	これはコネクションプロファイルの名前です。
Try to use DNS style names;	DNS形式の名前を使用してみてください。
they are a very easy way to convey meaning.	これは意味を伝えるための非常に簡単な方法です。
Line 16: `x-type: "hlfv1"`	16行目: `x-type: "hlfv1"`
Users can add their own `x-` properties that are "application-specific" -- just like with HTTP headers.	ユーザーは、HTTPヘッダーの場合と同様に、「アプリケーション固有」の独自の `x-` プロパティを追加できます。
They are provided primarily for future use.	これは主に将来的な使用のために提供されています。
Line 20: `description: "Sample connection profile for documentation topic"`	20行目: `description: "Sample connection profile for documentation topic"`
A short description of the connection profile.	このコネクションプロファイルの簡単な説明です。
Try to make this helpful for the reader who might be seeing this for the first time!	初めてこれを見るかもしれない読者のために役立つように設定してください！
Line 25: `version: "1.0"`	25行目: `version: "1.0"`
The schema version for this connection profile.	このコネクションプロファイルのスキーマのバージョンです。
Currently only version 1.0 is supported, and it is not envisioned that this schema will change frequently.	現在はバージョン1.0のみがサポートされており、このスキーマが頻繁に変更されることは想定されていません。
Line 32: `channels:`	32行目: `channels:`
This is the first really important line.	これは本当に重要な最初の行です。
`channels:` identifies that what follows are all the channels that this connection profile describes.	`channels:` は、このコネクションプロファイルが記述する すべて のチャネルが続くことを示します。
However, it is good practice to keep different channels in different connection profiles, especially if they are used independently of each other.	ただし、特に互いに独立して使用される場合には、異なるチャネルを異なるコネクションプロファイルに入れておくことは良い方法です。
Line 36: `papernet:`	36行目: `papernet:`
Details of `papernet`, the first channel in this connection profile, will follow.	このコネクションプロファイルの最初のチャネルである `papernet` の詳細です。
Line 41: `orderers:`	41行目: `orderers:`
Details of all the orderers for `papernet` follow.	`papernet` のすべてのOrdererの詳細です。
You can see in line 45 that the orderer for this channel is `orderer1.magnetocorp.example.com`.	45行目で、このチャネルのOrdererが `orderer1.magnetocorp.example.com` であることがわかります。
This is just a logical name;	これは単なる論理名です。
later in the connection profile (lines 134 - 147), there will be details of how to connect to this orderer.	コネクションプロファイルの後半 (134行目から147行目) に、このOrdererへの接続方法の詳細が記載されています。
Notice that `orderer2.digibank.example.com` is not in this list;	`orderer2.digibank.example.com` がこのリストには含まれていないことに注意してください。
it makes sense that applications use their own organization's orderers, rather than those from a different organization.	アプリケーションが別の組織のOrdererではなく、自組織のOrdererを使用することは理にかなっています。
Line 49: `peers:`	49行目: `peers:`
Details of all the peers for `papernet` will follow.	`papernet` のすべてのピアの詳細です。
You can see three peers listed from MagnetoCorp: `peer1.magnetocorp.example.com`, `peer2.magnetocorp.example.com` and `peer3.magnetocorp.example.com`.	MagnetoCorpからリストされている3つのピア `peer1.magnetocorp.example.com`, `peer2.magnetocorp.example.com`, `peer3.magnetocorp.example.com` を確認できます。
It's not necessary to list all the peers in MagnetoCorp, as has been done here.	ここで行われているようにMagnetoCorpのすべてのピアをリストする必要はありません。
You can see only one peer listed from DigiBank: `peer9.digibank.example.com`; including this peer starts to imply that the endorsement policy requires MagnetoCorp and DigiBank to endorse transactions, as we'll now confirm.	DigiBankからリストされているピア `peer9.digibank.example.com` は1つだけです。このDigiBankのピアを含めることは、これから確認するように、エンドースメントポリシーが、MagnetoCorpとDigiBankがトランザクションをエンドースすることを要求していることを暗示し始めます。
It's good practice to have multiple peers to avoid single points of failure.	単一障害点を回避するために、複数のピアを用意することは良い方法です。
Underneath each peer you can see four non-exclusive roles: endorsingPeer, chaincodeQuery, ledgerQuery and eventSource.	各ピアの下には、endorsingPeer、chaincodeQuery、ledgerQuery、およびeventSourceという4つの非排他的な役割が表示されています。
See how `peer1` and `peer2` can perform all roles as they host `papercontract`.	スマートコントラクト `papercontract` をホストするときに、 `peer1` と `peer2` が どのようにすべての役割を実行できるかをご覧ください。
Contrast to `peer3`, which can only be used for notifications, or ledger queries that access the blockchain component of the ledger rather than the world state, and hence do not need to have smart contracts installed.	対照的に、 `peer3` は通知、あるいはワールドステートではなく台帳のブロックチェーンコンポーネントにアクセスする台帳クエリ (ledger query) にのみ使用でき、スマートコントラクトをインストールする必要はありません。
Notice how `peer9` should not be used for anything other than endorsement, because those roles are better served by MagnetoCorp peers.	`peer9` は、MagnetoCorpのピアによってより適切に提供されるため、エンドースメント以外の目的で使用することはできません。
Again, see how the peers are described according to their logical names and their roles.	繰り返しになりますが、ピアが論理名と役割に従ってどのように記述されているかを確認してください。
Later in the profile, we'll see the physical information for these peers.	プロファイルの後半で、これらのピアの物理情報を確認します。
Line 97: `organizations:`	97行目: `organizations:`
Details of all the organizations will follow, for all channels.	すべてのチャネルのための、すべての組織の詳細です。
Note that these organizations are for all channels, even though `papernet` is currently the only one listed.	現在リストされているチャネルは `papernet` だけですが、ここで記載されている組織はすべてのチャネルを対象としていることに注意してください。
That's because organizations can be in multiple channels, and channels can have multiple organizations.	これは、組織が複数のチャネルに存在する可能性があり、チャネルが複数の組織を持つ可能性があるためです。
Moreover, some application operations relate to organizations rather than channels.	さらに、一部のアプリケーション操作は、チャネルではなく組織に関連しています。
For example, an application can request notification from one or all peers within its organization, or all organizations within the network -- using [connection options](./connectoptions.html).	たとえば、アプリケーションは、[コネクションオプション](./connectoptions.html) を使用して、1組織内またはネットワーク内のすべての組織の、1つまたはすべてのピアからの通知を要求できます。
For this, there needs to be an organization to peer mapping, and this section provides it.	このためには、組織とピアのマッピングが必要であり、このセクションでそれを提供します。
Line 101: `MagnetoCorp:`	101行目: `MagnetoCorp:`
All peers that are considered part of MagnetoCorp are listed: `peer1`, `peer2` and `peer3`.	MagneticCorpの一部と見なされるすべてのピア (`peer1`、`peer2`、および `peer3`) がリストされています。
Likewise for Certificate Authorities.	認証局についても同様です。
Again, note the logical name usages, the same as the `channels:` section; physical information will follow later in the profile.	ここでも `channels:` セクションと同じように論理名を使用していることに注意してください。物理情報は、プロファイルの後半へ続きます。
Line 121: `DigiBank:`	121行目: `DigiBank:`
Only `peer9` is listed as part of DigiBank, and no Certificate Authorities.	DigiBankの一部としてリストされているのは `peer9` のみであり、認証局はリストされていません。
That's because these other peers and the DigiBank CA are not relevant for users of this connection profile.	これは、DigiBankの他のピアとCAが、このコネクションプロファイルのユーザーに関連していないためです。
Line 134: `orderers:`	134行目: `orderers:`
The physical information for orderers is now listed.	Ordererの物理情報がリストされてます。
As this connection profile only mentioned one orderer for `papernet`, you see `orderer1.magnetocorp.example.com` details listed.	このコネクションプロファイルでは `papernet` 用のOrdererは1つしか記載されていないため、(ここでは) `orderer1.magnetocorp.example.com` の詳細がリストされています。
These include its IP address and port, and gRPC options that can override the defaults used when communicating with the orderer, if necessary.	これには、そのIPアドレスとポート、必要に応じてOrdererと通信する際に使用されるデフォルト値を上書きできるgRPCオプションが含まれます。
As with `peers:`, for high availability, specifying more than one orderer is a good idea.	`peers:` と同様に、高可用性を実現するには、複数のOrdererを指定することは良い考えです。
Line 152: `peers:`	152行目: `peers:`
The physical information for all previous peers is now listed.	前述したすべてのピアの物理情報がリストされています。
This connection profile has three peers for MagnetoCorp: `peer1`, `peer2`, and `peer3`; for DigiBank, a single peer `peer9` has its information listed.	このコネクションプロファイルには、MagnetoCorpに関しては3つのピア (`peer1`、 `peer2`、および `peer3`)DigiBankに関しては、単一のピア `peer9` があり、それらの情報がリストされています。
For each peer, as with orderers, their IP address and port is listed, together with gRPC options that can override the defaults used when communicating with a particular peer, if necessary.	Ordererと同様に、ピアごとに、そのIPアドレスとポートが、必要に応じて特定のピアと通信する際に使用されるデフォルト値を上書きできるgRPCオプションとともに表示されています。
Line 194: `certificateAuthorities:`	194行目: `certificateAuthorities:`
The physical information for certificate authorities is now listed.	認証局の物理情報がリストされています。
The connection profile has a single CA listed for MagnetoCorp, `ca1-magnetocorp`, and its physical information follows.	コネクションプロファイルには、MagnetoCorp用にリストされた単一のCA `ca1-magnetocorp` があり、その物理情報が続きます。
As well as IP details, the registrar information allows this CA to be used for Certificate Signing Requests (CSR).	IPの詳細だけでなく、登録者 (Registrar) 情報により、このCAを証明書署名要求（CSR）に使用できます。
These are used to request new certificates for locally generated public/private key pairs.	これらは、ローカルで生成された公開鍵と秘密鍵のペアの新しい証明書を要求するために使用されます。
Now you've understood a connection profile for MagnetoCorp, you might like to look at a [corresponding](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml) profile for DigiBank.	これでMagnetoCorpのコネクションプロファイルを理解したところで、DigiBankの[対応するプロファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml) を見てみてください。
Locate where the profile is the same as MagnetoCorp's, see where it's similar, and finally where it's different.	MagnetoCorpのプロファイルと同じところ、似ているところ、そして最後に違うところを確認してください。
Think about why these differences make sense for DigiBank applications.	これらの違いがDigiBankアプリケーションにとって意味がある理由を考えてみてください。
That's everything you need to know about connection profiles.	コネクションプロファイルについて知っておく必要があるのはこれだけです。
In summary, a connection profile defines sufficient channels, organizations, peers, orderers and certificate authorities for an application to configure a gateway.	要約すると、コネクションプロファイルは、アプリケーションがゲートウェイを構成するのに十分なチャネル、組織、ピア、Orderer、および認証局を定義します。
The gateway allows the application to focus on business logic rather than the details of the network topology.	ゲートウェイを使用することで、アプリケーションはネットワークトポロジの詳細ではなく、ビジネスロジックに集中することができます。
This file is reproduced inline from the GitHub commercial paper [sample](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml).	このファイルはGitHub上のコマーシャルペーパーの[サンプル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml) をインラインで転載したものです。
[Required]. A connection profile contains information about a set of network components.	[必須]. コネクションプロファイルには、一連のネットワークコンポーネントに関する情報が含まれています。
It is typically used to configure gateway, allowing applications interact with a network channel without worrying about the underlying topology.	これは通常、ゲートウェイを設定するために使用され、アプリケーションが基礎となるトポロジを気にすることなくネットワークチャネルとやりとりできるようにします。
A connection profile is normally created by an administrator who understands this topology.	コネクションプロファイルは通常、このトポロジを理解している管理者によって作成されます。
[Optional]. Analogous to HTTP, properties with an "x-" prefix are deemed "application-specific", and ignored by the gateway.	[任意]. HTTPと同様に、プレフィックスが「x-」のプロパティは「アプリケーション固有」と見なされ、ゲートウェイによって無視されます。
For example, property "x-type" with value "hlfv1" was originally used to identify a connection profile for Fabric 1.x rather than 0.x.	たとえば、値が「hlfv1」のプロパティ「x-type」は、元々、Fabric 0.xではなくFabric 1.xのコネクションプロファイルであることを識別するために使用されていました。
[Required]. A short description of the connection profile	[必須]. コネクションプロファイルの簡単な説明
[Required]. Connection profile schema version.	[必須]. コネクションプロファイルのスキーマのバージョン。
Used by the gateway to interpret these data.	ゲートウェイがこれらのデータを解釈するために使用します。
[Optional]. A logical description of each network channel; its peer and orderer names and their roles within the channel.	[任意]. 各ネットワークチャネルの論理的な説明 (そのピア名とOrderer名、およびチャネル内でのそれらの役割)。
The physical details of these components (e.g. peer IP addresses) will be specified later in the profile; we focus first on the logical, and then the physical.	これらのコンポーネントの物理的な詳細(ピアのIPアドレスなど) は、プロファイルの後半で指定されます。最初に論理情報に焦点を合わせ、その後に物理情報に焦点を合わせます。
[Optional]. papernet is the only channel in this connection profile	[任意]. papernet はこのコネクションプロファイルに含まれる唯一のチャネルとなります
[Optional]. Channel orderers for PaperNet.	[任意]. PaperNet のチャネルOrderer。
Details of how to connect to them is specified later, under the physical "orderers:" section	それらに接続する方法の詳細は後述の物理情報を示す「orderers:」セクションで指定されます。
[Required]. Orderer logical name	[必須]. Ordererの論理名
[Optional]. Peers and their roles	[任意]. ピアとその役割
[Required]. Peer logical name	[必須]. ピアの論理名
[Optional]. Is this an endorsing peer? (It must have chaincode installed.)	[任意]. このピアがエンドーシングピアかどうか (チェーンコードがインストールされている必要あり)。
Default: true	デフォルト値: true
[Optional]. Is this peer used for query? (It must have chaincode installed.)	[任意]. このピアがクエリするために使われるかどうか (チェーンコードがインストールされている必要あり)。
Default: true	デフォルト値: true
[Optional]. Is this peer used for non-chaincode queries?	[任意]. このピアがチェーンコード以外のクエリに使われるかどうか。
All peers support these types of queries, which include queryBlock(), queryTransaction(), etc.	すべてのピアは、 queryBlock()、queryTransaction() 等を含むこれらのタイプのクエリをサポートします。
Default: true	デフォルト値: true
[Optional]. Is this peer used as an event hub?	[任意]. このピアがイベントハブ (Event Hub) として使われるかどうか。
All peers can produce events.	すべてのピアはイベントを生成できます。
Default: true	デフォルト値: true
[Required]. List of organizations for all channels.	[必須]. すべてのチャネルのための組織のリスト。
At least one organization is required.	少なくとも1つ以上の組織が必要となります。
[Required]. Organizational information for MagnetoCorp	[必須]. MagnetoCorp用の組織情報
[Required]. The MSPID used to identify MagnetoCorp	[必須]. TMagnetoCorpの識別に使用されるMSP ID
[Required]. The MagnetoCorp peers	[必須]. MagnetoCorpのピア
[Optional]. Fabric-CA Certificate Authorities.	[任意]. 認証局 (Fabric CA)
[Optional]. Organizational information for DigiBank	[任意]. DigiBank用の組織情報
[Required]. The MSPID used to identify DigiBank	[必須]. DigiBankの識別に使用されるMSP ID
[Required]. The DigiBank peers	[必須]. DigiBankのピア
[Optional]. Orderer physical information, by orderer name	[任意]. Ordererの物理情報 (Orderer名ごと)
[Required]. Name of MagnetoCorp orderer	[必須]. MagnetoCorpのOrdererの名前
[Required]. This orderer's IP address	[必須]. このOrdererのIPアドレス
[Optional]. gRPC connection properties used for communication	[任意]. 通信に使用するgRPCコネクションプロパティ
[Required]. Peer physical information, by peer name.	[必須]. ピアの物理情報 (ピア名ごと)
At least one peer is required.	少なくとも1つ以上のピアが必要となります。
[Required]. First MagetoCorp peer physical properties	[必須]. MagetoCorpの1つ目のピアの物理プロパティ
[Required]. Peer's IP address	[必須]. Peer's IP address
[Optional]. gRPC connection properties used for communication	[任意]. 通信に使用するgRPCコネクションプロパティ
[Optional]. Other MagnetoCorp peers	[任意]. MagnetoCorpのその他のピア
[Required]. Digibank peer physical properties	[必須]. Digibankのピアの物理プロパティ
[Optional]. Fabric-CA Certificate Authority physical information, by name.	[任意]. 認証局 (Fabric CA) の物理情報 (名前ごと)
This information can be used to (e.g.) enroll new users.	この情報は (たとえば) 新しいユーザーを登録するために使用できます。
Communication is via REST, hence options relate to HTTP rather than gRPC.	通信はRESTを介して行われるため、オプションはgRPCではなくHTTPに関連します。
[Required]. MagnetoCorp CA	[必須]. MagnetoCorp用のCA
[Required]. CA IP address	[必須]. CAのIPアドレス
[Optioanl]. HTTP connection properties used for communication	[任意]. 通信に使うHTTPコネクションプロパティ
[Optional]. Fabric-CA supports Certificate Signing Requests (CSRs).	[任意]. Fabric CA は証明書署名要求 (Certificate Signing Request, CSR) をサポートします。
A registrar is needed to enroll new users.	登録者情報 (registrar) は新しいユーザを登録するために必要です。
[Optional]. The name of the CA.	[任意]. CAの名前
**Audience**: Architects, Application and smart contract developers	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者
An application can interact with a blockchain network by submitting transactions to a ledger or querying ledger content.	アプリケーションは、台帳に対するトランザクションを送信したり台帳の内容のクエリを行うことで、ブロックチェーンネットワークとやりとりします。
This topic covers the mechanics of how an application does this;	このトピックでは、アプリケーションがこれを行う仕組みについて取り上げます。
in our scenario, organizations access PaperNet using applications which invoke issue, buy and redeem transactions defined in a commercial paper smart contract.	ここでのシナリオにおいては、組織は、コマーシャルぺーパーのスマートコントラクトで定義された、発行、購入、現金化のトランザクションを実行するアプリケーションを用いてPaperNetにアクセスします。
Even though MagnetoCorp's application to issue a commercial paper is basic, it covers all the major points of understanding.	MagnetoCorpのアプリケーションがコマーシャルペーパーを発行するアプリケーションは基本的なものですが、理解に必要な重要な点をすべて扱っています。
In this topic, we're going to cover:	このトピックでは、以下の項目について取り上げます。
[The application flow to invoke a smart contract](#basic-flow)	[スマートコントラクトを実行するアプリケーションのフロー](#basic-flow)
[How an application uses a wallet and identity](#wallet)	[アプリケーションのウォレットとアイデンティティの使い方](#wallet)
[How an application connects using a gateway](#gateway)	[アプリケーションのゲートウェイを用いた接続の仕方](#gateway)
[How to access a particular network](#network-channel)	[特定のネットワークへのアクセスの仕方](#network-channel)
[How to construct a transaction request](#construct-request)	[トランザクション要求の作成の仕方](#construct-request)
[How to submit a transaction](#submit-transaction)	[トランザクションの送信の仕方](#submit-transaction)
[How to process a transaction response](#process-response)	[トランザクション応答の処理の仕方](#process-response)
To help your understanding, we'll make reference to the commercial paper sample application provided with Hyperledger Fabric.	理解を助けるために、以降ではHyperledger Fabricで提供されているコマーシャルペーパーのサンプルアプリケーションを参照していきます。
You can [download it](../install.html) and [run it locally](../tutorial/commercial_paper.html).	[このアプリケーションをダウンロードして](../install.html)、[ローカルで実行することができます](../tutorial/commercial_paper.html)。
It is written in both JavaScript and Java, but the logic is quite language independent, so you'll easily be able to see what's going on!	アプリケーションは、JavaScriptとJavaの両方で書かれていますが、ロジックは言語にあまり依存していないので、何が起きているかを簡単に理解することができるでしょう。
The sample will become available for Go as well.	Go版も提供される予定です。
An application interacts with a blockchain network using the Fabric SDK.	アプリケーションは、ブロックチェーンネットワークとFabric SDKを用いてやりとりを行います。
Here's a simplified diagram of how an application invokes a commercial paper smart contract:	下記の図は、アプリケーションがコマーシャルペーパーのスマートコントラクトをどのように実行するかを単純化したものです。
A PaperNet application invokes the commercial paper smart contract to submit an issue transaction request.	PaperNetアプリケーションが、発行トランザクション要求を送信するために、コマーシャルペーパーのスマートコントラクトを実行します。
An application has to follow six basic steps to submit a transaction:	アプリケーションはトランザクションを送信するために、次の6つの基本的なステップに従わなければなりません。
Select an identity from a wallet	ウォレットからアイデンティティを選択する
Connect to a gateway	ゲートウェイに接続する
Access the desired network	目的のネットワークにアクセスする
Construct a transaction request for a smart contract	スマートコントラクトに対するトランザクション要求を作成する
Submit the transaction to the network	トランザクションをネットワークに送信する
Process the response	応答を処理する
You're going to see how a typical application performs these six steps using the Fabric SDK.	これから、典型的なアプリケーションがFabric SDKを用いてこの6つのステップをどのように実行するかを見ていきます。
You'll find the application code in the `issue.js` file.	`issue.js`に、このアプリケーションのコードが含まれています。
[View it](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/application/issue.js) in your browser, or open it in your favourite editor if you've downloaded it.	ブラウザで[見る](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/application/issue.js)か、ダウンロードしているならお好きなエディタで開いて見てください。
Spend a few moments looking at the overall structure of the application; even with comments and spacing, it's only 100 lines of code!	アプリケーションの全体構造を確認してみてください。コメントやスペースも含んでさえ、たったの100行のコードです!
Towards the top of `issue.js`, you'll see two Fabric classes are brought into scope:	`issue.js`の冒頭の方で、2つのFabricのクラスがスコープに取り込まれているのがわかります。
You can read about the `fabric-network` classes in the [node SDK documentation](https://hyperledger.github.io/fabric-sdk-node/{BRANCH}/module-fabric-network.html), but for now, let's see how they are used to connect MagnetoCorp's application to PaperNet.	`fabric-network`に含まれるクラスについては、[Node SDKのドキュメント](https://hyperledger.github.io/fabric-sdk-node/{BRANCH}/module-fabric-network.html)で参照することができますが、今のところは、MagnetoCorpのアプリケーションがPaperNetに接続するのに、どのようにこれらのクラスを用いているかを見ていきましょう。
The application uses the Fabric Wallet class as follows:	アプリケーションは、FabricのWalletクラスを次のように使っています。
See how `wallet` locates a [wallet](./wallet.html) in the local filesystem.	`wallet`に対して、ローカルファイルシステムの[ウォレット](./wallet.html)がどのように指定されているかがわかるでしょうか。
The identity retrieved from the wallet is clearly for a user called Isabella, who is using the `issue` application.	ウォレットから取得されるアイデンティティは、明らかにIsabellaと呼ばれるユーザーのもので、このユーザーが`issue`アプリケーションを使用しています。
The wallet holds a set of identities -- X.509 digital certificates -- which can be used to access PaperNet or any other Fabric network.	ウォレットは、アイデンティティのセット、すなわち複数のX.509デジタル証明書を保持し、PaperNetやそのほかのFabricネットワークにアクセスするために使うことができます。
If you run the tutorial, and look in this directory, you'll see the identity credentials for Isabella.	もし、チュートリアルを動かしてこのディレクトリの中を見てみると、Isabellaに対するアイデンティティの資格情報があることがわかるでしょう。
Think of a [wallet](./wallet.html) holding the digital equivalents of your government ID, driving license or ATM card.	[ウォレット](./wallet.html)は、政府発行の身分証明書や運転免許証やATMカードのデジタル版を保持しているものと考えてください。
The X.509 digital certificates within it will associate the holder with a organization, thereby entitling them to rights in a network channel.	その中のX.509デジタル証明書は、それを保持しているものと組織を関連付けるもので、すなわち、ネットワークのチャネルへのアクセスする権利を与えているものということになります。
For example, `Isabella` might be an administrator in MagnetoCorp, and this could give her more privileges than a different user -- `Balaji` from DigiBank.	例えば、`Isabella`はMagnetoCorpの管理者であるかもしれません。この場合、DigiBankの`Balaji`といったほかのユーザーとは異なる特権を与えられているかもしれません。
Moreover, a smart contract can retrieve this identity during smart contract processing using the [transaction context](./transactioncontext.html).	さらに、スマートコントラクトは、その処理の際に、[トランザクション・コンテキスト](./transactioncontext.html)を用いて、このアイデンティティを取得することができます。
Note also that wallets don't hold any form of cash or tokens -- they hold identities.	ウォレットは、いかなる形の現金やトークンも保持しておらず、アイデンティティを保持するものであることに注意してください。
The second key class is a Fabric Gateway.	二つ目の重要なFabricのクラスは、Gatewayです。
Most importantly, a [gateway](./gateway.html) identifies one or more peers that provide access to a network -- in our case, PaperNet.	もっとも重要なことは、[ゲートウェイ](./gateway.html)は、ネットワーク(ここでは、PaperNet)に対するアクセスを提供する、1つあるいは複数のピアを認識しているということです。
See how `issue.js` connects to its gateway: `gateway.connect()` has two important parameters: connectionProfile: the file system location of a [connection profile](./connectionprofile.html) that identifies a set of peers as a gateway to PaperNet connectionOptions: a set of options used to control how `issue.js` interacts with PaperNet	以下のようにして、`issue.js`はゲートウェイに接続を行っています。`gateway.connect()`には、2つの重要なパラメータがあります。connectionProfile: PaperNetへのゲートウェイとなるピアのセットの情報を含む[コネクションプロファイル](./connectionprofile.html)のファイルシステム上での位置　connectionOptions: `issue.js`がPaperNetとのやりとりする際に用いられるオプション
See how the client application uses a gateway to insulate itself from the network topology, which might change.	クライアントアプリケーションがゲートウェイを使って、変化しうるネットワークトポロジーの影響を直接受けないようにしているのがわかるでしょうか。
The gateway takes care of sending the transaction proposal to the right peer nodes in the network using the [connection profile](./connectionprofile.html) and [connection options](./connectionoptions.html).	ゲートウェイは、[コネクションプロファイル](./connectionprofile.html)と[オプション](./connectionoptions.html)を用いて、トランザクション提案を適切なピアノードに送信する処理の面倒をみます。
Spend a few moments examining the connection [profile](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml) `./gateway/connectionProfile.yaml`.	コネクション[プロファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/gateway/networkConnection.yaml)の`./gateway/connectionProfile.yaml` を少し確認してみてください。
It uses [YAML](http://yaml.org/spec/1.2/spec.html#Preview), making it easy to read.	読むのが簡単なように[YAML](http://yaml.org/spec/1.2/spec.html#Preview)を用いています。
It was loaded and converted into a JSON object:	このファイルは、オブジェクトに変換されてロードされます。
Right now, we're only interested in the `channels:` and `peers:` sections of the profile: (We've modified the details slightly to better explain what's happening.)	今ここでは、下記に示す、`channels:`と`peers:`セクションだけが重要なセクションです。(説明を簡単にするために多少改変してあります)
See how `channel:` identifies the `PaperNet:` network channel, and two of its peers.	`channel:`でネットワークチャネルの`PaperNet:`と、その二つのピアが定義されているのがわかるでしょうか。
MagnetoCorp has `peer1.magenetocorp.com` and DigiBank has `peer2.digibank.com`, and both have the role of endorsing peers.	MagnetoCorpは`peer1.magenetocorp.com`を持ち、DigiBankは`peer2.digibank.com`を持ち、二つのピアともにエンドーシングピアのロールを持っています。
Link to these peers via the `peers:` key, which contains details about how to connect to them, including their respective network addresses.	これらのピアは、ネットワークアドレスなどの接続のための方法などの詳細を含んでいる`peers:`キーに関連付けられます。
The connection profile contains a lot of information -- not just peers -- but network channels, network orderers, organizations, and CAs, so don't worry if you don't understand all of it!	コネクションプロファイルは、ピアだけでなく、ネットワークチャネル、Orderer、組織、CAなど、非常に多くの情報を含んでいますので、全部が理解できなくても心配する必要はありません！
Let's now turn our attention to the `connectionOptions` object:	では次に、`connectionOptions`オブジェクトのほうを見ていきましょう。
See how it specifies that identity, `userName`, and wallet, `wallet`, should be used to connect to a gateway.	ゲートウェイに接続するのに使う必要のある、`userName`というアイデンティティ、`wallet`というウォレットが、オプションで指定されているのがわかるでしょうか。
These were assigned values earlier in the code.	これらの変数は、この前のコードで値が代入されています。
There are other [connection options](./connectionoptions.html) which an application could use to instruct the SDK to act intelligently on its behalf.	このほかにも、[コネクションオプション](./connectionoptions.html)があり、アプリケーションがSDKに対してその挙動をより細かく指示するのに使うことができます。
For example:	例:
Here, `commitTimeout` tells the SDK to wait 100 seconds to hear whether a transaction has been committed.	ここでは、`commitTimeout`によって、トランザクションがコミットされたかどうかの結果を、100秒間まで待つようにSDKに指示しています。
And `strategy: EventStrategies.MSPID_SCOPE_ANYFORTX` specifies that the SDK can notify an application after a single MagnetoCorp peer has confirmed the transaction, in contrast to `strategy: EventStrategies.NETWORK_SCOPE_ALLFORTX` which requires that all peers from MagnetoCorp and DigiBank to confirm the transaction.	そして、`strategy: EventStrategies.MSPID_SCOPE_ANYFORTX`は、MagnetoCorpの1つのピアがトランザクションを確認した時点で、SDKはアプリケーションに通知してよいということを表しています。これに対して、`strategy: EventStrategies.NETWORK_SCOPE_ALLFORTX`では、MagnetoCorpとDigiBankのすべてのピアがトランザクションを確認するまで待つ必要があります。
If you'd like to, [read more](./connectionoptions.html) about how connection options allow applications to specify goal-oriented behaviour without having to worry about how it is achieved.	コネクションオプションによって、アプリケーションが目的に応じた挙動を、実現方法を気にせずに指定することができます。もし必要であれば、[詳細を確認することができます](./connectionoptions.html)。
The peers defined in the gateway `connectionProfile.yaml` provide `issue.js` with access to PaperNet.	`connectionProfile.yaml`のゲートウェイで定義されたピアによって、`issue.js`はPaperNetにアクセスできます。
Because these peers can be joined to multiple network channels, the gateway actually provides the application with access to multiple network channels!	これらのピアは、複数のネットワークチャネルに参加することができるので、アプリケーションはゲートウェイによって複数のネットワークチャネルへのアクセスを得ることができます。
See how the application selects a particular channel:	アプリケーションが特定のチャネルをどのように選択するかを見てください。
From this point onwards, `network` will provide access to PaperNet.	これ以降では、`network`はPaperNetへのアクセスを提供します。
Moreover, if the application wanted to access another network, `BondNet`, at the same time, it is easy:	さらに、もしアプリケーションが他のネットワーク`BondNet`へのアクセスが同時に必要であったなら、下記のように簡単にできます。
Now our application has access to a second network, `BondNet`, simultaneously with `PaperNet`!	これでアプリケーションは、二つ目のネットワーク`BondNet`へのアクセスが、`PaperNet`と同時に可能になります！
We can see here a powerful feature of Hyperledger Fabric -- applications can participate in a network of networks, by connecting to multiple gateway peers, each of which is joined to multiple network channels.	ここに、Hyperledger Fabricの強力な機能を見ることができます。すなわち、それぞれが複数ネットワークチャネルに参加している、複数のゲートウェイのピアに接続することで、アプリケーションはネットワークのネットワークに参加することができる、ということです。
Applications will have different rights in different channels according to their wallet identity provided in `gateway.connect()`.	アプリケーションは、`gateway.connect()`で提供したウォレットのアイデンティティに応じて、それぞれのチャネルで異なる権利を有します。
The application is now ready to issue a commercial paper.	さて、アプリケーションはコマーシャルペーパーを発行することができるようになりました。
To do this, it's going to use `CommercialPaperContract` and again, its fairly straightforward to access this smart contract:	これを行うには、`CommercialPaperContract`を使うことになりますが、スマートコントラクトへのアクセスもまた非常に簡単です。
Note how the application provides a name -- `papercontract` -- and an explicit contract name: `org.papernet.commercialpaper`!	アプリケーションが`papercontract`という名前と、明示的にコントラクトの名前`org.papernet.commercialpaper`を指定していることに注目してください。
We see how a [contract name](./contractname.html) picks out one contract from the `papercontract.js` chaincode file that contains many contracts.	複数のコントラクトを含むチェーンコード `papercontract.js`から、1つのコントラクトを、[コントラクト名](./contractname.html)によって選んでいることがわかるでしょうか。
In PaperNet, `papercontract.js` was installed and deployed to the channel with the name `papercontract`, and if you're interested, read [how](../chaincode_lifecycle.html) to deploy a chaincode containing multiple smart contracts.	PaperNetでは、`papercontract.js`が、`papercontract`という名前でチャネルにインストールされデプロイされていました。もし興味があれば、複数のスマートコントラクトを含むチェーンコードを[どのように](../chaincode_lifecycle.html)デプロイするのかのドキュメントを参照してください。
If our application simultaneously required access to another contract in PaperNet or BondNet this would be easy:	もしアプリケーションが同時に、PaperNetやBondNetの他のコントラクトへのアクセスが必要だったなら、これも下記のように簡単に行えるでしょう。
In these examples, note how we didn't use a qualifying contract name -- we have only one smart contract per file, and `getContract()` will use the first contract it finds.	この例では、コントラクト名を使用していないことに注意してください。これは、ファイルあたり1つのスマートコントラクトしかないからで、`getContract()`は最初にみつけたコントラクトを使用します。
Recall the transaction MagnetoCorp uses to issue its first commercial paper:	最初のコマーシャルペーパーを発行するのに、`MagnetoCorp`が下記のようなトランザクションを用いたことを思い出してください。
Let's now submit this transaction to PaperNet!	それでは、このトランザクションをPaperNetに送信しましょう！
Submitting a transaction is a single method call to the SDK:	トランザクションの送信は、下記の通り、SDKの1つのメソッドの呼び出しで行えます。
See how the `submitTransaction()` parameters match those of the transaction request.	`submitTransaction()`のパラメータが、トランザクション要求のそれに一致しているのがわかります。
It's these values that will be passed to the `issue()` method in the smart contract, and used to create a new commercial paper.	この値が、スマートコントラクトの`issue()`メソッドに渡され、新しいコマーシャルペーパーを作成するのに使用されます。
Recall its signature:	このメソッドのシグネチャを思い出してください。
It might appear that a smart contract receives control shortly after the application issues `submitTransaction()`, but that's not the case.	アプリケーションが、`submitTransaction()`を発行すると、すぐにスマートコントラクトに制御が移るように見えるかもしれませんが、それは違います。
Under the covers, the SDK uses the `connectionOptions` and `connectionProfile` details to send the transaction proposal to the right peers in the network, where it can get the required endorsements.	SDKが裏では、`connectionOptions`と`connectionProfile`の詳細を使用して、必要なエンドースメントを得られるネットワークの適切なピア群にトランザクション提案を送信しています。
But the application doesn't need to worry about any of this -- it just issues `submitTransaction` and the SDK takes care of it all!	しかし、アプリケーションはこういったことを気にする必要はなく、ただ`submitTransaction`を呼び出すだけで、SDKが後の面倒は見てくれます！
Note that the `submitTransaction` API includes a process for listening for transaction commits.	`submitTransaction` APIには、トランザクションのコミットを待つというプロセスが含まれていることに注目してください。
Listening for commits is required because without it, you will not know whether your transaction has successfully been orderered, validated, and committed to the ledger.	コミットを待つことは必要不可欠で、もし、これがなければ、トランザクションの順序付け、検証、台帳へのコミットが成功したかどうかを知ることができないでしょう。
Let's now turn our attention to how the application handles the response!	次は、アプリケーションが応答をどのように処理するかを見ていきましょう！
Recall from `papercontract.js` how the issue transaction returns a commercial paper response:	`papercontract.js`で、下記のように、issueトランザクションがコマーシャルペーパーの応答を返していたのを思い出しましょう。
You'll notice a slight quirk -- the new `paper` needs to be converted to a buffer before it is returned to the application.	ここでちょっとしたクセがあることに気づくでしょう。新しい`paper`はbufferに変換してから、アプリケーションに返さなければならないということです。
Notice how `issue.js` uses the class method `CommercialPaper.fromBuffer()` to rehydrate the response buffer as a commercial paper:	`issue.js`では、クラスメソッド`CommercialPaper.fromBuffer()`を用いて、応答のbufferからコマーシャルペーパーに復元しているのに注目してください。
This allows `paper` to be used in a natural way in a descriptive completion message:	これによって、下記のように、完了メッセージの説明文で`paper`を自然な形で使うことができます。
See how the same `paper` class has been used in both the application and smart contract -- if you structure your code like this, it'll really help readability and reuse.	アプリケーションとスマートコントラクトで、同じ`paper`クラスが使われていることがわかります。コードの構造をこのようにすることで、非常に読みやすく、また再利用しやすくすることができます。
As with the transaction proposal, it might appear that the application receives control soon after the smart contract completes, but that's not the case.	トランザクション提案の場合と同様に、スマートコントラクトが完了するとすぐにアプリケーションに制御が移るように見えるかもしれませんが、これも違います。
Under the covers, the SDK manages the entire consensus process, and notifies the application when it is complete according to the `strategy` connectionOption.	SDKが、裏で合意形成プロセス全体を処理し、connectionOptionsの`strategy`にしたがって、完了した時点でアプリケーションに通知します。
If you're interested in what the SDK does under the covers, read the detailed [transaction flow](../txflow.html).	もし、SDKが実際に裏で何をしているかに興味ある場合には、詳細な[トランザクションのフロー](../txflow.html)を参照してください。
That’s it!	以上です！
In this topic you’ve understood how to call a smart contract from a sample application by examining how MagnetoCorp's application issues a new commercial paper in PaperNet.	このトピックで、MagnetoCorpのアプリケーションがPaperNetで新しいコマーシャルペーパーを発行するやり方を通じて、サンプルアプリケーションからスマートコントラクトをどのように呼ぶかが理解できたでしょう。
Now examine the key ledger and smart contract data structures are designed by in the [architecture topic](./architecture.html) behind them.	[アーキテクチャのトピック](./architecture.html)で、これらの背後にある、重要な台帳やスマートコントラクトのデータ構造を見てみましょう。
In order to create and transfer assets on a Hyperledger Fabric network, an organization needs to join a channel.	Hyperledger Fabricのネットワークでアセットを作成して転送するには、組織がチャネルに参加する必要があります。
Channels are a private layer of communication between specific organizations and are invisible to other members of the network.	チャネルは、特定の組織間の通信のプライベート・レイヤーであり、ネットワークの他の組織からは見えません。
Each channel consists of a separate ledger that can only be read and written to by channel members, who are allowed to join their peers to the channel and receive new blocks of transactions from the ordering service.	各チャネルは、チャネルに参加している組織のみが読取りおよび書込みできる個別の台帳で構成されます。チャネルの参加組織はチャネルにピアを加入し、オーダリングサービスから新しいトランザクションブロックを受け取れます。
While the peers, nodes, and Certificate Authorities form the physical infrastructure of the network, channels are the process by which organizations connect with each other and interact.	ピア、オーダリングノード、CAがネットワークの物理的なインフラストラクチャを形成する一方で、チャネルは組織が相互に接続してやりとりするプロセスです。
Because of the fundamental role that channels play in the operation and governance of Fabric, we provide a series of tutorials that will cover different aspects of how channels are created.	チャネルはFabricの運用と管理において基本的な役割を果たすため、チャネルの作成方法についてさまざまな側面から説明する一連のチュートリアルを紹介します。
The `create_channel` tutorial describes the operational steps that need to be taken by a network administrator.	`Creating a new channel <create_channel>` では、ネットワーク管理者が実行する必要がある操作手順について説明します。
The `create_channel_config` tutorial introduces the conceptual aspects of creating a channel, followed by a separate discussion of :doc:`channel_policies`.	`Using configtx.yaml to build a channel configuration <create_channel_config>` では、チャネルの作成に関する概念について説明した後、`Channel Policies <channel_policies>` について個別に説明します。
**Audience**: Architects, application and smart contract developers, administrators	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者、管理者
A chaincode is a generic container for deploying code to a Hyperledger Fabric blockchain network.	チェーンコードは、コードをHyperledger Fabricのブロックチェーンネットワークにデプロイするための一般的なコンテナです。
One or more related smart contracts are defined within a chaincode.	一つあるいは複数の関係するスマートコントラクトがチェーンコード内で定義されます。
Every smart contract has a name that uniquely identifies it within a chaincode.	各スマートコントラクトは、チェーンコード内で一意に識別できる名前を持ちます。
Applications access a particular smart contract within a chaincode using its contract name.	アプリケーションは、このコントラクト名を用いて、チェーンコード内の特定のスマートコントラクトにアクセスします。
In this topic, we're going to cover:	このトピックでは、下記について扱います。
[How a chaincode contains multiple smart contracts](#chaincode)	[複数のスマートコントラクトがチェーンコードにどのように含まれているか](#chaincode)
[How to assign a smart contract name](#name)	[どのようにスマートコントラクト名を与えるか](#name)
[How to use a smart contract from an application](#application)	[アプリケーションからどのようにスマートコントラクトを使うか](#application)
[The default smart contract](#default-contract)	[デフォルトのスマートコントラクト](#default-contract)
In the [Developing Applications](./developing_applications.html) topic, we can see how the Fabric SDKs provide high level programming abstractions which help application and smart contract developers to focus on their business problem, rather than the low level details of how to interact with a Fabric network.	[アプリケーション開発](./developing_applications.html)のトピックにおいては、Fabric SDKがハイレベルなプログラミングの抽象化を提供し、それによって、アプリケーションやスマートコントラクト開発者が、Fabricネットワークとのやりとりの低レベルの詳細ではなく、ビジネスの問題に集中する助けとなることがわかります。
Smart contracts are one example of a high level programming abstraction, and it is possible to define smart contracts within in a chaincode container.	スマートコントラクトは、高レベルのプログラミングの抽象化の一つの例であり、複数のスマートコントラクトをチェーンコードコンテナ内に定義することが可能です。
When a chaincode is installed on your peer and deployed to a channel, all the smart contracts within it are made available to your applications.	チェーンコードがピアにインストールされ、チャネルにデプロイされると、チェーンコード内のスマートコントラクトは全てアプリケーションから利用可能になります。
Multiple smart contracts can be defined within a chaincode.	複数のスマートコントラクトをチェーンコード内に定義することが可能です。
Each is uniquely identified by their name within a chaincode.	それぞれのスマートコントラクトは、名前でチェーンコード内で一意に識別されます。
In the diagram [above](#chaincode), chaincode A has three smart contracts defined within it, whereas chaincode B has four smart contracts.	[上の](#chaincode)図では、チェーンコードAは、その中に3つのスマートコントラクトが定義されており、チェーンコードBには4つのスマートコントラクトがあります。
See how the chaincode name is used to fully qualify a particular smart contract.	特定のスマートコントラクトを表すのにチェーンコード名が使われているのがわかるでしょう。
The ledger structure is defined by a set of deployed smart contracts.	台帳の構造は、デプロイされているスマートコントラクト群によって定義されます。
That's because the ledger contains facts about the business objects of interest to the network (such as commercial paper within PaperNet), and these business objects are moved through their lifecycle (e.g. issue, buy, redeem) by the transaction functions defined within a smart contract.	これは、台帳は、ネットワークにおいて対象となるビジネスデータ(PaperNetにおけるコマーシャルペーパーのように)に関する事実を含み、そのビジネスデータは、スマートコントラクトで定義されたトランザクション関数によってライフサイクル(例えば、発行、購入、現金化など)の中で遷移するからです。
In most cases, a chaincode will only have one smart contract defined within it.	多くの場合では、チェーンコード内で定義されているスマートコントラクトは一つだけでしょう。
However, it can make sense to keep related smart contracts together in a single chaincode.	しかし、関連する複数のスマートコントラクトを一つのチェーンコードにまとめることは、理にかなっていることがあります。
For example, commercial papers denominated in different currencies might have contracts `EuroPaperContract`, `DollarPaperContract`, `YenPaperContract` which might need to be kept synchronized with each other in the channel to which they are deployed.	例えば、別の通貨のコマーシャルペーパーには、`EuroPaperContract`・`DollarPaperContract`・`YenPaperContract`というコントラクトを使い、それらは、デプロイされたチャネルで互いに同期していることが必要になるかもしれません。
Each smart contract within a chaincode is uniquely identified by its contract name.	チェーンコード内のそれぞれのスマートコントラクトは、コントラクト名によって一意に識別されます。
A smart contract can explicitly assign this name when the class is constructed, or let the `Contract` class implicitly assign a default name.	スマートコントラクトは、クラスのコンストラクタで名前を明示的に指定することもできますし、`Contract`クラスによって与えられる暗黙的なデフォルトの名前を使うこともできます。
xamine the `papercontract.js` chaincode [file](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js#L31): 	チェーンコードの`papercontract.js`[ファイル](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js#L31)を確認してみましょう。
Unique name when multiple contracts per chaincode file	チェーンコードファイル内に複数のスマートコントラクトがある場合には一意となる名前
See how the `CommercialPaperContract` constructor specifies the contract name as `org.papernet.commercialpaper`.	CommercialPaperContract`のコンストラクタが`org.papernet.commercialpaper`をコントラクト名として指定しているのがわかるでしょう。
The result is that within the `papercontract` chaincode, this smart contract is now associated with the contract name `org.papernet.commercialpaper`.	その結果、この`papercontract`チェーンコードにおいては、このスマートコントラクトは、`org.papernet.commercialpaper`というコントラクト名に結びつけられることとなります。
If an explicit contract name is not specified, then a default name is assigned -- the name of the class.	もし、明示的なコントラクト名が指定されなければ、クラス名がデフォルトの名前として与えられます。
In our example, the default contract name would be `CommercialPaperContract`.	この例では、デフォルトのコントラクト名は、`CommercialPaperContract`となるでしょう。
Choose your names carefully.	名前を選ぶ際にはよく考えてください。
It's not just that each smart contract must have a unique name;	それぞれのスマートコントラクトの名前は一意でなくてはならないというだけではありません。
a well-chosen name is illuminating.	良く選択された名前は、わかりやすいものです。
Specifically, using an explicit DNS-style naming convention is recommended to help organize clear and meaningful names;	具体的には、明らかで意味のある名前を構成しやすくするものとして、DNSスタイルの命名規則を用いることをお勧めします。
`org.papernet.commercialpaper` conveys that the PaperNet network has defined a standard commercial paper smart contract.	`org.papernet.commercialpaper`という名前は、PaperNetネットワークが標準のコマーシャルペーパーのスマートコントラクトを定義しているという意味を表しています。
Contract names are also helpful to disambiguate different smart contract transaction functions with the same name in a given chaincode.	コントラクト名は、あるチェーンコード内の別のスマートコントラクトの同じ名前のトランザクション関数を区別するのに役立ちます。
This happens when smart contracts are closely related; their transaction names will tend to be the same.	これは、複数のスマートコントラクトが密接に関係がある場合に起こります。それらのトランザクションの名前は同じものである傾向にあるからです。
We can see that a transaction is uniquely defined within a channel by the combination of its chaincode and smart contract name.	チャネルにおいて、チェーンコードとスマートコントラクト名の組み合わせによって、トランザクションが一意に定義されることがわかります。
Contract names must be unique within a chaincode file.	コントラクト名は、チェーンコードファイル内において一意でなければなりません。
Some code editors will detect multiple definitions of the same class name before deployment.	コードエディタによっては、デプロイの前に、同じ名前のクラスが複数存在するのを検知するものもあるでしょう。
Regardless the chaincode will return an error if multiple classes with the same contract name are explicitly or implicitly specified.	いずれにしても、複数のクラスが明示的であれ暗黙的であれ同じスマートコントラクト名を与えられている場合、チェーンコードはエラーを返すでしょう。
Once a chaincode has been installed on a peer and deployed to a channel, the smart contracts in it are accessible to an application:	チェーンコードがピアにインストールされ、チャネルにデプロイされると、チェーンコード内のスマートコントラクトは、アプリケーションから次のようにアクセス可能になります。
See how the application accesses the smart contract with the `network.getContract()` method.	アプリケーションが、`network.getContract()`メソッドを使ってスマートコントラクトにアクセスしているのがわかるでしょう。
The `papercontract` chaincode name `org.papernet.commercialpaper` returns a `contract` reference which can be used to submit transactions to issue commercial paper with the `contract.submitTransaction()` API.	チェーンコード`papercontract`における名前`org.papernet.commercialpaper`で、`contract`への参照が返され、それを使って`contract.submitTransaction()` APIを用いることでコマーシャルペーパーを発行するトランザクションを送信することができます。
The first smart contract defined in a chaincode is called the default smart contract.	チェーンコードで最初に定義されているスマートコントラクトは、デフォルトスマートコントラクトと呼ばれます。
A default is helpful because a chaincode will usually have one smart contract defined within it; a default allows the application to access those transactions directly -- without specifying a contract name.	チェーンコードは普通一つのスマートコントラクトしか定義していないため、デフォルトというのは便利です。アプリケーションがコントラクト名を指定しなくとも、直接そのトランザクションにアクセスすることができるからです。
A default smart contract is the first contract defined in a chaincode.	デフォルトスマートコントラクトは、チェーンコードで定義された最初のコントラクトです。
In this diagram, `CommercialPaperContract` is the default smart contract.	この図では、`CommercialPaperContract`がデフォルトのスマートコントラクトです。
Even though we have two smart contracts, the default smart contract makes our [previous](#application) example easier to write:	二つのスマートコントラクトがありますが、デフォルトスマートコントラクトによって、[先ほどの](#application)例は、次のように、より簡単に書くことができます。
This works because the default smart contract in `papercontract` is `CommercialPaperContract` and it has an `issue` transaction.	`papercontract`のデフォルトのスマートコントラクトは、`CommercialPaperContract`であり、それには`issue`トランザクションがあるため、このコードはうまく動きます。
Note that the `issue` transaction in `BondContract` can only be invoked by explicitly addressing it.	`BondContract`の`issue`トランザクションを実行するには、明示的に指定しなければならないということに注意してください。
Likewise, even though the `cancel` transaction is unique, because `BondContract` is *not* the default smart contract, it must also be explicitly addressed.	同様に、`cancel`トランザクションは、`BondContract`にしかないものであっても、デフォルトスマートコントラクトではないので、これも明示的に指定する必要があります。
In most cases, a chaincode will only contain a single smart contract, so careful naming of the chaincode can reduce the need for developers to care about chaincode as a concept.	多くの場合では、チェーンコードはスマートコントラクトを一つだけしか持たないため、チェーンコードの名前をよく考えて決めることで、開発者がチェーンコードという概念を意識する必要を減らすことができます。
In the example code [above](#default-contract) it feels like `papercontract` is a smart contract.	[上の](#default-contract)コードの例では、`papercontract`がスマートコントラクトとして感じられるでしょう。
In summary, contract names are a straightforward mechanism to identify individual smart contracts within a given chaincode.	まとめると、コントラクト名は、あるチェーンコード内において各スマートコントラクトを識別する簡単な仕組みです。
Contract names make it easy for applications to find a particular smart contract and use it to access the ledger.	コントラクト名によって、アプリケーションは簡単に特定のスマートコントラクトを見つけ、台帳にアクセスするのに使うことができます。
This section elaborates the key features for client application and smart contract development found in Hyperledger Fabric.	この節では、Hyperledger Fabricにおけるクライアントアプリケーションとスマートコントラクトの開発のための重要な機能について述べます。
A solid understanding of the features will help you design and implement efficient and effective solutions.	これらの機能に対する理解を深めることで、効率的で効果的なソリューションの設計と実装が行えるようになるでしょう。
**Audience**: Architects, application and smart contract developers, administrators	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者、管理者
A chaincode namespace allows it to keep its world state separate from other chaincodes.	チェーンコードネームスペースによって、チェーンコードのワールドステートは他のチェーンコードと分離することが可能になります。
Specifically, smart contracts in the same chaincode share direct access to the same world state, whereas smart contracts in different chaincodes cannot directly access each other's world state.	具体的にいうと、同じチェーンコード内のスマートコントラクトは、同じワールドステートに直接アクセスすることができますが、異なるチェーンコードのスマートコントラクトは、互いのワールドステートには直接アクセスすることができません。
If a smart contract needs to access another chaincode world state, it can do this by performing a chaincode-to-chaincode invocation.	もしスマートコントラクトが、他のチェーンコードのワールドステートにアクセスすることが必要な場合は、チェーンコード間呼び出しを行うことで可能です。
Finally, a blockchain can contain transactions which relate to different world states.	そして、ブロックチェーンは異なるワールドステートに関するトランザクションを格納することができます。
In this topic, we're going to cover:	このトピックでは、次の項目について述べます。
[The importance of namespaces](#motivation)	[ネームスペースの重要性](#motivation)
[What is a chaincode namespace](#scenario)	[チェーンコードネームスペースとは何か](#scenario)
[Channels and namespaces](#channels)	[チャネルとネームスペース](#channels)
[How to use chaincode namespaces](#usage)	[チェーンコードネームスペースの使い方](#usage)
[How to access world states across smart contracts](#cross-chaincode-access)	[チェーンコードをまたいだワールドステートのアクセスのしかた](#cross-chaincode-access)
[Design considerations for chaincode namespaces](#considerations)	[チェーンコードネームスペースに関する設計上の留意点](#considerations)
A namespace is a common concept.	ネームスペースは、一般的な概念です。
We understand that Park Street, New York and Park Street, Seattle are different streets even though they have the same name.	*ニューヨークのパークストリートとシアトルのパークストリートは、同じ名前であっても違う通りであるということがわかります。
The city forms a namespace for Park Street, simultaneously providing freedom and clarity.	パークストリートに対して、都市名はネームスペースを構成していて、同時に自由度とわかりやすさを与えています。
It's the same in a computer system.	コンピュータシステムにおいても同様です。
Namespaces allow different users to program and operate different parts of a shared system, without getting in each other's way.	ネームスペースによって、別々のユーザーが、互いに邪魔をすることなく、共有システムの異なる部分でプログラム及び処理を行うことができます。
Many programming languages have namespaces so that programs can freely assign unique identifiers, such as variable names, without worrying about other programs doing the same.	多くのプログラミング言語は、ネームスペースをもっています。これによって、プログラムは、例えば変数名といった固有の識別子を自由に使うことができ、ほかのプログラムのことを心配する必要がありません。
We'll see that Hyperledger Fabric uses namespaces to help smart contracts keep their ledger world state separate from other smart contracts.	Hyperledger Fabricでは、ネームスペースによって、スマートコントラクトがその台帳ワールドステートを、他のスマートコントラクトとは分離できていることを、これから見ていきましょう。
Let's examine how the ledger world state organizes facts about business objects that are important to the organizations in a channel using the diagram below.	それでは、台帳ワールドステートにおいて、チャネルの組織に対して重要なビジネスデータに関する事実をどのように構成しているかを、下記の図を用いて詳しく見ていきましょう。
Whether these objects are commercial papers, bonds, or vehicle registrations, and wherever they are in their lifecycle, they are maintained as states within the ledger world state database.	これらのデータがコマーシャルペーパーか債権か自動車登録かに関わらず、また、ライフサイクル上のどこに位置していても、台帳ワールドステートデータベース内に保持されています。
A smart contract manages these business objects by interacting with the ledger (world state and blockchain), and in most cases this will involve it querying or updating the ledger world state.	スマートコントラクトは、これらのデータを台帳(ワールドステートおよびブロックチェーン)とのやりとりを行うことで管理し、ほとんどの場合には、台帳ワールドステートのクエリや更新を行います。
It's vitally important to understand that the ledger world state is partitioned according to the chaincode of the smart contract that accesses it, and this partitioning, or namespacing is an important design consideration for architects, administrators and programmers.	台帳ワールドステートが、アクセスするスマートコントラクトのチェーンコードに応じて分割されていると理解することが極めて重要です。そしてこの分割、すなわちネームスペースをもつことは、アーキテクトや管理者やプログラマにとってきわめて重要な設計上の留意点となります。
The ledger world state is separated into different namespaces according to the chaincode that accesses it.	台帳ワールドステートは、アクセスするチェーンコードに応じて分割されています。
Within a given channel, smart contracts in the same chaincode share the same world state, and smart contracts in different chaincodes cannot directly access each other's world state.	あるチャネルにおいて、同じチェーンコード内のスマートコントラクトは同じワールドステートを共有し、異なるチェーンコードのスマートコントラクトは互いのワールドステートに直接アクセスすることはできません。
Likewise, a blockchain can contain transactions that relate to different chaincode world states.	このように、ブロックチェーンは、異なるチェーンコードワールドステートに関するトランザクションを格納することができます。
In our example, we can see four smart contracts defined in two different chaincodes, each of which is in their own chaincode container.	ここでの例では、2つのチェーンコードで定義された4つのスマートコントラクトがあることがわかります。それぞれのチェーンコードは、その専用のチェーンコードコンテナ内にあります。
The `euroPaper` and `yenPaper` smart contracts are defined in the `papers` chaincode.	`euroPaper`と`yenPaper`の2つのスマートコントラクトは、`papers`チェーンコード内に定義されています。
The situation is similar for the `euroBond` and `yenBond` smart contracts  -- they are defined in the `bonds` chaincode.	`euroBond`と`yenBond`の2つのスマートコントラクトも、同様の状況で、`bonds`チェーンコード内に定義されています。
This design helps application programmers understand whether they are working with commercial papers or bonds priced in Euros or Yen, and because the rules for each financial product don't really change for different currencies, it makes sense to manage their deployment in the same chaincode.	この設計によって、アプリケーションプログラマは、ユーロまたは円建てのコマーシャルペーパー(papers)あるいは債権(bonds)を扱っているのかを理解することができます。そして、それぞれの金融商品の規則は、通貨が違ってもあまり変わらないため、同じチェーンコードでデプロイを管理することは理にかなっています。
The [diagram](#scenario) also shows the consequences of this deployment choice.	[この図](#scenario)は、また、このデプロイの方針による結果も表しています。
The database management system (DBMS) creates different world state databases for the `papers` and `bonds` chaincodes and the smart contracts contained within them.	データベース管理システム(DBMS)は、`papers`と`bonds`のチェーンコードとそれに含まれるスマートコントラクトのために、チェーンコードごとに別のワールドステートデータベースを作成します。
`World state A` and `world state B` are each held within distinct databases;	`world state A`と`world state B`は、それぞれ別のデータベースに格納されています。
the data are isolated from each other such that a single world state query (for example) cannot access both world states.	データは互いに隔離されており、例えば1つのワールドステートのクエリでは、両方のワールドステートにアクセスすることはできません。
The world state is said to be namespaced according to its chaincode.	ワールドステートは、チェーンコードに応じてネームスペースに分かれているということができます。
See how `world state A` contains two lists of commercial papers `paperListEuro` and `paperListYen`.	`world state A`が、2つのコマーシャルペーパーのリスト `paperListEuro`、`paperListYen`を含んでいるのがわかるでしょうか。
The states `PAP11` and `PAP21` are instances of each paper managed by the `euroPaper` and `yenPaper` smart contracts respectively.	ステート`PAP11`と`PAP21`は、それぞれ`euroPaper`と`yenPaper`スマートコントラクトによって管理されているコマーシャルペーパーのインスタンスです。
Because they share the same chaincode namespace, their keys (`PAPxyz`) must be unique within the namespace of the `papers` chaincode, a little like a street name is unique within a town.	この二つのステートは、同じチェーンコードネームスペースにあるため、キー(`PAPxyz`)は、`papers`チェーンコードのネームスペース内で一意でなくてはなりません。これは、町の中で通りの名前が一意であるのと少し似ています。
Notice how it would be possible to write a smart contract in the `papers` chaincode that performed an aggregate calculation over all the commercial papers -- whether priced in Euros or Yen -- because they share the same namespace.	`papers`チェーンコードで、ユーロ建てか円建てかにかかわらず、すべてのコマーシャルペーパーを集計するスマートコントラクトを書くことができることに注意してください。これは、コマーシャルペーパーが同じネームスペースを共有しているためです。
The situation is similar for bonds -- they are held within `world state B` which maps to a separate `bonds` database, and their keys must be unique.	債権についても状況は同様で、債権は`world state B`に格納されており、これは別の`bonds`データベースにマップされており、キーはこの中でユニークでなくてはなりません。
Just as importantly, namespaces mean that `euroPaper` and `yenPaper` cannot directly access `world state B`, and that `euroBond` and `yenBond` cannot directly access `world state A`.	そして同じように重要なのは、ネームスペースがあるということは、`euroPaper`と`yenPaper`は直接`world state B`にはアクセスできず、`euroBond`と`yenBond`は直接`world state A`にアクセスすることができないということです。
This isolation is helpful, as commercial papers and bonds are very distinct financial instruments; they have different attributes and are subject to different rules.	コマーシャルペーパーと債権は大きく異なる金融商品であり、異なる属性をもち異なるルールに従うため、この隔離は有用なものです。
It also means that `papers` and `bonds` could have the same keys, because they are in different namespaces.	また、異なるネームスペースにあるため、`papers`と`bonds`は、同じキーを持つこともできることを意味します。
This is helpful; it provides a significant degree of freedom for naming.	名前付けに関して大きな自由度を与えるため、これも有用なものです。
Use this freedom to name different business objects meaningfully.	この自由度を使って、ビジネスデータに意味のある名前付けをするのに役立てましょう。
Most importantly, we can see that a blockchain is associated with the peer operating in a particular channel, and that it contains transactions that affect both `world state A` and `world state B`.	さらに重要なことに、ブロックチェーンは、あるチャネルで動作するピアに結びつけられるものであり、`world state A`と`world state B`両方に影響するトランザクションを含んでいるのがわかります。
That's because the blockchain is the most fundamental data structure contained in a peer.	これは、ブロックチェーンは、ピアに格納される最も基本的なデータ構造であるためです。
The set of world states can always be recreated from this blockchain, because they are the cumulative results of the blockchain's transactions.	ワールドステートは、ブロックチェーンのトランザクションの積み重なった結果であるので、いつでもブロックチェーンから再構成することが可能です。
A world state helps simplify smart contracts and improve their efficiency, as they usually only require the current value of a state.	ワールドステートは、スマートコントラクトが通常必要なのはステートの現在の値であるので、スマートコントラクトを単純にしその効率を改善するのに役立つものです。
Keeping world states separate via namespaces helps smart contracts isolate their logic from other smart contracts, rather than having to worry about transactions that correspond to different world states.	ワールドステートをネームスペースによって分離しておくことは、スマートコントラクトが別のスマートコントラクトとロジックを隔離し、別のワールドステートに対するトランザクションの心配をする必要をなくすのに役立ちます。
For example, a `bonds` contract does not need to worry about `paper` transactions, because it cannot see their resultant world state.	たとえば、`bonds`のコントラクトは、`paper`のトランザクションを心配する必要がありません。なぜならば、`bonds`からは、`paper`のトランザクションの結果のワールドステートは見ることができないからです。
It's also worth noticing that the peer, chaincode containers and DBMS all are logically different processes.	また、ピアとチェーンコードコンテナ、DBMSは全て論理的に別のプロセスであるということも注目しておくべきでしょう。
The peer and all its chaincode containers are always in physically separate operating system processes, but the DBMS can be configured to be embedded or separate, depending on its [type](../ledger/ledger.html#world-state-database-options).	ピアとそのチェーンコードコンテナは、常にOSの物理的に別のプロセスですが、DBMSはその[種類](../ledger/ledger.html#world-state-database-options)によって、設定で組み込みか分離するかを変更することができます。
For LevelDB, the DBMS is wholly contained within the peer, but for CouchDB, it is a separate operating system process.	LevelDBでは、DBMSは完全にピア内に含まれますが、CouchDBでは別のOSのプロセスになります。
It's important to remember that namespace choices in this example are the result of a business requirement to share commercial papers in different currencies but isolate them separate from bonds.	ここでの例において、ネームスペースの選択は、異なる通貨のコマーシャルペーパーは共有し、債権からは分離するというビジネス上の要件から来ているものであることは覚えておきましょう。
Think about how the namespace structure would be modified to meet a business requirement to keep every financial asset class separate, or share all commercial papers and bonds? If a peer is joined to multiple channels, then a new blockchain is created and managed for each channel.	全ての金融資産の種類を別々にするようなビジネス要件、あるいは、コマーシャルペーパーと債権を共有するようなビジネス要件であったなら、どのようにネームスペースの構造が変わっていたかを考えてみましょう。ピアが複数のチャネルに参加した場合、各チャネルに対して新しいブロックチェーンが作られ管理されます。
Moreover, every time a chaincode is deployed to a new channel, a new world state database is created for it.	加えて、新しいチャネルにチェーンコードがデプロイされるたびに、新しいワールドステートデータベースが作られます。
It means that the channel also forms a kind of namespace alongside that of the chaincode for the world state.	これは、ワールドステートにおけるチェーンコードのネームスペースに加えて、チャネルが一種のネームスペースを構成することを意味しています。
However, the same peer and chaincode container processes can be simultaneously joined to multiple channels -- unlike blockchains, and world state databases, these processes do not increase with the number of channels joined.	しかし、同じピアとチェーンコードコンテナプロセスは、複数のチャネルに同時に参加することができるため、ブロックチェーンやワールドステートデータベースと異なり、これらのプロセスは参加しているチャネルの数に応じて増えはしません。
For example, if you deployed the `papers` and `bonds` chaincode to a new channel, there would a totally separate blockchain created, and two new world state databases created.	例えば、`papers`と`bonds`チェーンコードを新しいチャネルにデプロイしたとすると、完全に別のブロックチェーンと、2つのワールドステートデータベースが作られるでしょう。
However, the peer and chaincode containers would not increase; each would just be connected to multiple channels.	しかし、ピアとチェーンコードコンテナは増加せず、ただ複数のチャネルに接続されるだけでしょう。
Let's use our commercial paper [example](#scenario) to show how an application uses a smart contract with namespaces.	コマーシャルペーパーの[例](#scenario)を用いて、アプリケーションがどのようにネームスペースとスマートコントラクトを使うのかを見てみましょう。
It's worth noting that an application communicates with the peer, and the peer routes the request to the appropriate chaincode container which then accesses the DBMS.	アプリケーションがピアと通信し、ピアは要求を適切なチェーンコードコンテナにルーティングし、チェーンコードがDBMSにアクセスする、ということは触れておくべきでしょう。
This routing is done by the peer core component shown in the diagram.	このルーティングは、図に示されているピアのコアコンポーネントによって行われます。
Here's the code for an application that uses both commercial papers and bonds, priced in Euros and Yen.	以下が、ユーロ建てと円建てのコマーシャルペーパー及び債権を用いるアプリケーションのコードです。
The code is fairly self-explanatory: 	このコードは、説明が不要なほど十分わかりやすいでしょう。
See how the application: 	このアプリケーションについて下記のことがわかります。
Accesses the `euroPaper` and `yenPaper` contracts using the `getContract()` API specifying the `papers` chaincode.	`papers`チェーンコードを指定して`getContract()`APIを使うことで、`euroPaper`と`yenPaper`コントラクトにアクセスしていること。
See interaction points 1a and 2a.	1aと2aを参照してください。
Accesses the `euroBond` and `yenBond` contracts using the `getContract()` API specifying the `bonds` chaincode.	`bonds`チェーンコードを指定して`getContract()`APIを使うことで、`euroBond`と`yenBond`コントラクトにアクセスしていること。
See interaction points 3a and 4a.	3aと4aを参照してください。
Submits an `issue` transaction to the network for commercial paper `PAP11` using the `euroPaper` contract.	`euroPaper`コントラクトを用いて、コマーシャルペーパー`PAP11`の`issue`(発行)トランザクションを送信していること。
See interaction point 1a.	1aを参照してください。
This results in the creation of a commercial paper represented by state `PAP11` in `world state A`; interaction point 1b.	そして、その結果`world state A`内の`PAP11`ステートで表現されるコマーシャルペーパーが作成されます(1b)。
This operation is captured as a transaction in the blockchain at interaction point 1c.	この処理は、ブロックチェーンで1cのトランザクションとして表現されています。
Submits a `redeem` transaction to the network for commercial paper `PAP21` using the `yenPaper` contract.	`yenPaper`コントラクトを用いて、コマーシャルペーパー`PAP21`の`redeem`(現金化)トランザクションを送信していること。
See interaction point 2a.	2aを参照してください。
This results in the creation of a commercial paper represented by state `PAP21` in `world state A`; interaction point 2b.	そして、その結果`world state A`内の`PAP21`ステートで表現されるコマーシャルペーパーが更新されます(2b)。
This operation is captured as a transaction in the blockchain at interaction point 2c.	この処理は、ブロックチェーンで2cのトランザクションとして表現されています。
Submits a `buy` transaction to the network for bond `BON31` using the `euroBond` contract.	`euroBond`コントラクトを用いて、コマーシャルペーパー`BON31`の`buy`(購入)トランザクションを送信していること。
See interaction point 3a.	3aを参照してください。
This results in the creation of a bond represented by state `BON31` in `world state B`; interaction point 3b.	そして、その結果`world state B`内の`BON31`ステートで表現される債権が更新されます(3b)。
This operation is captured as a transaction in the blockchain at interaction point 3c.	この処理は、ブロックチェーンで3cのトランザクションとして表現されています。
Submits a `sell` transaction to the network for bond `BON41` using the `yenBond` contract.	`yenBond`コントラクトを用いて、コマーシャルペーパー`BON41`の`sell`(売却)トランザクションを送信していること。
See interaction point 4a.	4aを参照してください。
This results in the creation of a bond represented by state `BON41` in `world state B`; interaction point 4b.	そして、その結果`world state B`内の`BON41`ステートで表現される債権が更新されます(4b)。
This operation is captured as a transaction in the blockchain at interaction point 4c.	この処理は、ブロックチェーンで4cのトランザクションとして表現されています。
See how smart contracts interact with the world state: 	スマートコントラクトのワールドステートとのやりとりについて下記のことがわかります。
`euroPaper` and `yenPaper` contracts can directly access `world state A`, but cannot directly access `world state B`.	`euroPaper`と`yenPaper`コントラクトは、`world state A`に直接アクセスできますが、`world state B`には直接アクセスできません。
`World state A` is physically held in the `papers` database in the database management system (DBMS) corresponding to the `papers` chaincode.	`world state A`は、物理的には`papers`チェーンコードに対応するデータベース管理システム(DBMS)の`papers`データベースに格納されています。
`euroBond` and `yenBond` contracts can directly access `world state B`, but cannot directly access `world state A`.	`euroBond`と`yenBond`コントラクトは、`world state B`に直接アクセスできますが、`world state A`には直接アクセスできません。
`World state B` is physically held in the `bonds` database in the database management system (DBMS) corresponding to the `bonds` chaincode.	`world state B`は、物理的には`bonds`チェーンコードに対応するデータベース管理システム(DBMS)の`bonds`データベースに格納されています。
See how the blockchain captures transactions for all world states: 	ブロックチェーンの、全てのワールドステートに関するトランザクションを格納するやりかたについて下記のことがわかります。
Interactions 1c and 2c correspond to transactions create and update commercial papers `PAP11` and `PAP21` respectively.	1cと2cのやりとりは、コマーシャルペーパー`PAP11`の作成、`PAP21`の更新を行うトランザクションにそれぞれ対応します。
These are both contained within `world state A`.	これらは、ともに`world state A`に含まれます。
Interactions 3c and 4c correspond to transactions both update bonds `BON31` and `BON41`.	3cと4cのやりとりは、債権`BON31`及び`BON41`の更新を行うトランザクションに対応します。
These are both contained within `world state B`.	これらは、ともに`world state B`に含まれます。
If `world state A` or `world state B` were destroyed for any reason, they could be recreated by replaying all the transactions in the blockchain.	`world state A`あるいは`world state B`が何らかの理由で失われることがあったとしたら、ブロックチェーンに含まれるトランザクションをすべて再実行することで再度作成することができるでしょう。
As we saw in our example [scenario](#scenario), `euroPaper` and `yenPaper` cannot directly access `world state B`.	ここでの例の[シナリオ](#scenario)で見たように、`euroPaper`と`yenPaper`は`world state B`に直接アクセスすることができません。
That's because we have designed our chaincodes and smart contracts so that these chaincodes and world states are kept separately from each other.	これは、チェーンコードとスマートコントラクトが、チェーンコードとワールドステートが互いに別々となるように設計されているためです。
However, let's imagine that `euroPaper` needs to access `world state B`.	しかし、`euroPaper`が`world state B`にアクセスする必要がある場合を考えてみましょう。
Why might this happen? Imagine that when a commercial paper was issued, the smart contract wanted to price the paper according to the current return on bonds with a similar maturity date.	どういった場合にこのようなことがあるでしょうか？スマートコントラクトがコマーシャルペーパーを発行するとき、近い満期日の債権の現在のリターンに応じた価格をコマーシャルペーパーにつけたいという場合を考えてみてください。
In this case it will be necessary for the `euroPaper` contract to be able to query the price of bonds in `world state B`.	この場合、`euroPaper`コントラクトが`world state B`にある債権の価格をクエリできることが必要でしょう。
Look at the following diagram to see how we might structure this interaction.	このやりとりをどのように実現するかを、下記の図を見てみましょう。
How chaincodes and smart contracts can indirectly access another world state -- via its chaincode.	チェーンコードとスマートコントラクトが間接的に、チェーンコードを介して他のワールドステートにアクセスする方法
Notice how:	以下のことに注目してください。
the application submits an `issue` transaction in the `euroPaper` smart contract to issue `PAP11`.	アプリケーションが`PAP11`を発行するために、`euroPaper`スマートコントラクトに`issue`トランザクションを送信します。
See interaction 1a.	1aを参照してください。
the `issue` transaction in the `euroPaper` smart contract calls the `query` transaction in the `euroBond` smart contract.	`euroPaper`スマートコントラクト内の`issue`トランザクションは、`euroBond`スマートコントラクトの`query`トランザクションを呼び出します。
See interaction point 1b.	1bを参照してください。
the `query`in `euroBond` can retrieve information from `world state B`.	`euroBond`の`query`は、`world state B`から情報を取得します。
See interaction point 1c.	1cを参照してください。
when control returns to the `issue` transaction, it can use the information in the response to price the paper and update `world state A` with information.	`issue`トランザクションに制御が戻ったとき、`issue`は、応答にある情報を使ってコマーシャルペーパーの価格を決め、`world state A`を更新します。
See interaction point 1d.	1dを参照してください。
the flow of control for issuing commercial paper priced in Yen is the same.	円建てのコマーシャルペーパーを発行する際の制御フローは同じです。
See interaction points 2a, 2b, 2c and 2d.	2a・2b・2c・2dを参照してください。
Control is passed between chaincode using the `invokeChaincode()` [API](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor).	`invokeChaincode()` [API](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#invokeChaincode__anchor)によって、チェーンコード間を制御が渡ります。
This API passes control from one chaincode to another chaincode.	このAPIは、あるチェーンコードから別のチェーンコードに制御を渡します。
Although we have only discussed query transactions in the example, it is possible to invoke a smart contract which will update the called chaincode's world state.	この例ではクエリトランザクションについてのみ述べましたが、呼ばれた側のチェーンコードのワールドステートを更新するスマートコントラクトを実行(invoke)することも可能です。
See the [considerations](#considerations) below.	次の[留意点](#considerations)を参照してください。
In general, each chaincode will have a single smart contract in it.	一般的には、各チェーンコードがもつスマートコントラクトは一つだけです。
Multiple smart contracts should only be deployed in the same chaincode if they are very closely related.	非常に深く関係する場合のみ、複数のスマートコントラクトを一つのチェーンコード内にデプロイするべきです。
Usually, this is only necessary if they share the same world state.	通常は、同じワールドステートを共有する場合にのみ必要となります。
Chaincode namespaces provide isolation between different world states.	チェーンコードネームスペースは、異なるワールドステート間を分離します。
In general it makes sense to isolate unrelated data from each other.	一般的に、関係ないデータを互いに分離するのは意味があります。
Note that you cannot choose the chaincode namespace;	チェーンコードネームスペースを自分で選ぶことができないことに注意してください。
it is assigned by Hyperledger Fabric, and maps directly to the name of the chaincode.	これは、Hyperledger Fabricによって割り当てられ、チェーンコード名に直接マップされるものです。
For chaincode to chaincode interactions using the `invokeChaincode()` API, both chaincodes must be installed on the same peer.	`invokeChaincode()` APIを用いたチェーンコード間のやりとりには、両方のチェーンコードが同じピア上にインストールされていなければなりません。
For interactions that only require the called chaincode's world state to be queried, the invocation can be in a different channel to the caller's chaincode.	呼ばれたチェーンコードのワールドステートのクエリのみが必要なやりとりには、呼び出し元のチェーンコードとは異なるチャネルに対して行うことができます。
For interactions that require the called chaincode's world state to be updated, the invocation must be in the same channel as the caller's chaincode.	呼ばれたチェーンコードのワールドステートを更新する必要のあるやりとりには、呼び出し元のチェーンコードと同じチャネルで行わなければなりません。
**Audience:** Architects, application and smart contract developers, administrators	**対象読者:** アーキテクト、アプリケーション開発者、スマートコントラクト開発者、管理者
This tutorial will show you how to install and use a commercial paper sample application and smart contract.	このチュートリアルでは、コマーシャルペーパー(訳注:短期の無担保手形)のサンプルアプリケーションおよびスマートコントラクトをインストールして使用する方法について説明します。
It is a task-oriented topic, so it emphasizes procedures above concepts.	これはタスク指向のトピックであるため、概念よりも手順が強調されています。
When you’d like to understand the concepts in more detail, you can read the [Developing Applications](../developapps/developing_applications.html) topic.	概念をより詳細に理解するには、[Developing Applications](../developapps/developing_applications.html)トピックを参照してください。
In this tutorial two organizations, MagnetoCorp and DigiBank, trade commercial paper with each other using PaperNet, a Hyperledger Fabric blockchain network.	このチュートリアルでは、MagnetoCorpとDigiBankの2つの組織が、Hyperledger FabricブロックチェーンネットワークであるPaperNetを使用してコマーシャルペーパーを相互に取引します。
Once you've set up the test network, you'll act as Isabella, an employee of MagnetoCorp, who will issue a commercial paper on its behalf.	テストネットワークを設定したら、MagnetoCorpの従業員であるIsabellaの役を演じます。Isabellaの代わりにコマーシャルペーパーを発行します。
You'll then switch roles to take the role of Balaji, an employee of DigiBank, who will buy this commercial paper, hold it for a period of time, and then redeem it with MagnetoCorp for a small profit.	次に、DigiBankの従業員であるBalajiの役を演じるように役割を切り替えます。Balajiはコマーシャルペーパーを購入し、一定期間保持した後、少しの利益をMagnetoCorpで償還します。
You'll act as a developer, end user, and administrator, each in different organizations, performing the following steps designed to help you understand what it's like to collaborate as two different organizations working independently, but according to mutually agreed rules in a Hyperledger Fabric network.	開発者、エンドユーザー、および管理者として、それぞれ異なる組織で作業します。次の手順を実行して、Hyperledger Fabricネットワークで相互に合意したルールに従って、独立して作業する2つの異なる組織として共同作業することの意味を理解します。
[Set up machine](#prerequisites) and [download samples](#download-samples)	[マシンのセットアップ](#prerequisites)と[サンプルのダウンロード](#download-samples)
[Create the network](#create-the-network)	[ネットワークを作成](#create-the-network)
[Examine the commercial paper smart contract](#examine-the-commercial-paper-smart-contract)	[コマーシャルペーパースマートコントラクトの実装を確認](#examine-the-commercial-paper-smart-contract)
[Deploy the smart contract to the channel](#deploy-the-smart-contract-to-the-channel) by approving the chaincode definition as MagnetoCorp and Digibank.	チェーンコード定義をMagnetoCorpおよびDigibankとして承認することで、[チャネルにスマートコントラクトをデプロイ](#deploy-the-smart-contract-to-the-channel)
Understand the structure of a MagnetoCorp [application](#application-structure), including its [dependencies](#application-dependencies)	[依存関係](#application-dependencies)を含むMagnetoCorp[アプリケーション](#application-structure)の構造理解
Configure and use a [wallet and identities](#wallet)	[ウォレットとID](#wallet)の構成と使用
Run a MagnetoCorp application to [issue a commercial paper](#issue-application)	[コマーシャルペーパーを発行](#issue-application)するMagnetoCorpアプリケーションを実行
Understand how DigiBank uses the smart contract in their [applications](#digibank-applications)	DigiBankが[アプリケーション](#digibank-applications)でスマートコントラクトを使用する方法を理解
As Digibank, run applications that [buy](#buy-application) and [redeem](#redeem-application) commercial paper This tutorial has been tested on MacOS and Ubuntu, and should work on other Linux distributions.	Digibankで、コマーシャルペーパーを[購入](#buy-application)および[償還](#redeem-application)するアプリケーションを実行このチュートリアルは、MacOSおよびUbuntuでテストされており、他のLinuxディストリビューションでも動作するはずです。
A Windows version is under development.	Windows版は開発中です。
Before you start, you must install some prerequisite technology required by the tutorial.	作業を開始する前に、チュートリアルで必要な前提条件となるテクノロジをいくつかインストールする必要があります。
We've kept these to a minimum so that you can get going quickly.	読者が迅速に作業を進められるように、これらは最小限にしています。
You must have the following technologies installed:	次のテクノロジがインストールされている必要があります:
The Node.js SDK README contains the up to date list of prerequisites.	The Node.js SDK READMEには、前提条件の最新のリストが含まれています。
You will find it helpful to install the following technologies:	次のテクノロジをインストールすると便利です:
A source code editor, such as [Visual Studio Code](https://code.visualstudio.com/) version 1.28, or higher.	[Visual Studio Code](https://code.visualstudio.com/)バージョン1.28以降などのソースコードエディタ。
VS Code will help you develop and test your application and smart contract.	VS Codeは、アプリケーションとスマートコントラクトの開発とテストに役立ちます。
Install VS Code [here](https://code.visualstudio.com/Download).	[ここ](https://code.visualstudio.com/Download)からVS Codeをインストールしてください。
Many excellent code editors are available including [Atom](https://atom.io/), [Sublime Text](http://www.sublimetext.com/) and [Brackets](http://www.sublimetext.com/).	[Atom](https://atom.io/)、[Sublime Text](http://www.sublimetext.com/)、[Brackets](http://brackets.io/)など、多くの優れたコードエディターが利用可能です。
You may find it helpful to install the following technologies as you become more experienced with application and smart contract development.	アプリケーションおよびスマートコントラクト開発の経験が深まるにつれて、次のテクノロジをインストールすると便利な場合があります。
There's no requirement to install these when you first run the tutorial:	チュートリアルを最初に実行するときに、これらをインストールする必要はありません:
[Node Version Manager](https://github.com/creationix/nvm).	[Nodeバージョンマネージャ](https://github.com/creationix/nvm)。
NVM helps you easily switch between different versions of node --	NVMを使用すると、異なるバージョンのNodeを簡単に切り替えることができます。
it can be really helpful if you're working on multiple projects at the same time.	複数のプロジェクトで同時に作業する場合に便利です。
Install NVM [here](https://github.com/creationix/nvm#installation).	[ここ](https://github.com/creationix/nvm#installation)からNVMをインストールします。
The commercial paper tutorial is one of the samples in the `fabric-samples` repository.	コマーシャルペーパーチュートリアルは、`fabric-samples`リポジトリ内のサンプルの1つです。
Before you begin this tutorial, ensure that you have followed the instructions to install the Fabric [Prerequisites](../prereqs.html) and [Download the Samples, Binaries and Docker Images](../install.html).	このチュートリアルを開始する前に、Fabric [Prerequisites](../prereqs.html)をインストールし、[Download the Samples, Binaries and Docker Images](../install.html)の手順に従っていることを確認してください。
When you are finished, you will have cloned the `fabric-samples` repository that contains the tutorial scripts, smart contract, and application files.	その手順が完了すると、チュートリアルスクリプト、スマートコントラクトおよびアプリケーションファイルを含む`fabric-samples`リポジトリのクローンが作成されます。
Download the `fabric-samples` GitHub repository to your local machine.	`fabric-samples` GitHubリポジトリをローカルマシンにダウンロードしてください。
After downloading, feel free to examine the directory structure of `fabric-samples`:	ダウンロードしたら、`fabric-samples`のディレクトリ構造を自由に確認してください:
Notice the `commercial-paper` directory --	`commercial-paper`ディレクトリに注目してください。
that's where our sample is located! You've now completed the first stage of the tutorial!	ここに我々のサンプルが格納されています!これで、チュートリアルの第1段階が完了しました。
As you proceed, you'll open multiple command windows for different users and components.	次に、異なるユーザーおよびコンポーネントの複数のコマンドウィンドウを開きます。
For example:	次に例を示します:
To show peer, orderer and CA log output from your network.	ネットワーク経由でピア、orderer、およびCAのログを出力するためのウィンドウ
To approve the chaincode as an administrator from MagnetoCorp and as an administrator from DigiBank.	MagnetoCorpの管理者およびDigiBankの管理者として、チェーンコードを承認するためのウィンドウ
To run applications on behalf of Isabella and Balaji, who will use the smart contract to trade commercial paper with each other.	スマートコントラクトを利用して、コマーシャルペーパーを相互に交換するIsabellaとBalajiの代理でアプリケーションを実行するためのウィンドウ
We'll make it clear when you should run a command from particular command window;	特定のコマンドウィンドウからコマンドを実行するタイミングを明確にします。
for example:	たとえば、次のようになります:
indicates that you should run the `ls` command from Isabella's window.	上記は、Isabellaのウィンドウから`ls`コマンドを実行する必要があることを示しています。
This tutorial will deploy a smart contract using the Fabric test network.	このチュートリアルでは、Fabricテストネットワークを使用してスマートコントラクトをデプロイします。
The test network consists of two peer organizations and one ordering organization.	テストネットワークは、2つのピア組織と1つのオーダリング組織で構成されます。
The two peer organizations operate one peer each, while the ordering organization operates a single node Raft ordering service.	2つのピア組織はそれぞれ1つのピアを運営し、オーダー組織は単一ノードのRaftオーダリングサービスを運営します。
We will also use the test network to create a single channel named `mychannel` that both peer organizations will be members of.	また、テストネットワークを使用して、`mychannel`という名前の単一チャネルを作成し、両方のピア組織をメンバーにします。
The Fabric test network is comprised of two peer organizations, Org1 and Org2, and one ordering organization.	Fabricテストネットワークは、Org1とOrg2の2つのピア組織と1つのオーダー組織で構成されます。
Each component runs as a Docker container.	各コンポーネントはDockerコンテナとして動作します。
Each organization runs their own Certificate Authority.	各組織は独自の認証局を実行します。
The two peers, the [state databases](../ledger/ledger.html#world-state-database-options), the ordering service node, and each organization CA each run in their own Docker container.	2つのピア、[ステートデータベース](../ledger/ledger.html#world-state-database-options)、オーダリングサービスノード、および各組織のCAは、それぞれ独自のDockerコンテナで実行されます。
In production environments, organizations typically use existing CAs that are shared with other systems;	本番環境では、組織は通常、他のシステムと共有されている既存のCAを使用します。
they're not dedicated to the Fabric network.	そのCAはFabricネットワーク専用ではありません。
The two organizations of the test network allow us to interact with a blockchain ledger as two organizations that operate separate peers.	テストネットワークの2つの組織を使用すると、ブロックチェーン台帳を、別々のピアを操作する2つの組織として操作できます。
In this tutorial, we will operate Org1 of the test network as DigiBank and Org2 as MagnetoCorp.	このチュートリアルでは、テストネットワークのOrg1をDigiBank、Org2をMagnetoCorpとして操作します。
You can start the test network and create the channel with a script provided in the commercial paper directory.	コマーシャルペーパーディレクトリに用意されているスクリプトを使用して、テストネットワークを開始し、チャネルを作成できます。
Change to the `commercial-paper` directory in the `fabric-samples`:	`fabric-samples`の`commercial-paper`ディレクトリに移動します:
Then use the script to start the test network:	次に、スクリプトを使用してテストネットワークを起動します:
While the script is running, you will see logs of the test network being deployed.	スクリプトの実行中に、デプロイされているテストネットワークのログが表示されます。
When the script is complete, you can use the `docker ps` command to see the Fabric nodes running on your local machine:	スクリプトが完了したら、`docker ps`コマンドを使用して、ローカルマシン上で実行されているFabricノードを表示できます:
See if you can map these containers to the nodes of the test network (you may need to horizontally scroll to locate the information):	これらのコンテナをテストネットワークのノードにマッピングできるかどうかを確認します(情報を検索するには、水平方向にスクロールする必要があります):
The Org1 peer, `peer0.org1.example.com`, is running in container `a86f50ca1907`	Org1ピア `peer0.org1.example.com` がコンテナ `a86f50ca1907`で実行されている
The Org2 peer, `peer0.org2.example.com`, is running in container `77d0fcaee61b`	Org2ピア `peer0.org2.example.com` がコンテナ `77d0fcaee61b`で実行されている
The CouchDB database for the Org1 peer, `couchdb0`, is running in container `7eb5f64bfe5f`	Org1ピアのCouchDBデータベース `couchdb0` がコンテナ `7eb5f64bfe5f`で実行されている
The CouchDB database for the Org2 peer, `couchdb1`, is running in container `2438df719f57`	Org2ピアのCouchDBデータベース `couchdb1` がコンテナ `2438df719f57`で実行されている
The Ordering node, `orderer.example.com`, is running in container `03373d116c5a`	Orderingノード `orderer.example.com` がコンテナ `03373d116c5a`で実行されている
The Org1 CA, `ca_org1`, is running in container `87aef6062f23`	Org1CA `ca_org1` がコンテナ `87aef6062f23`で実行されている
The Org2 CA, `ca_org2`, is running in container `6b4d87f65909`	Org2CA `ca_org2` がコンテナ `6b4d87f65909`で実行されている
The Ordering Org CA, `ca_orderer`, is running in container `7b01f5454832`	オーダリング組織CA `ca_orderer` がコンテナ `7b01f5454832`で実行されている
These containers all form a [Docker network](https://docs.docker.com/network/) called `net_test`.	これらのコンテナはすべて`net_test`という[Dockerネットワーク](https://docs.docker.com/network/)を形成しています。
You can view the network with the `docker network` command:	ネットワークを表示するには、`docker network`コマンドを使用します:
See how the eight containers use different IP addresses, while being part of a single Docker network.	1つのDockerネットワークの一部でありながら、8つのコンテナがどのように異なるIPアドレスを使用しているかを見てください。
We've abbreviated the output for clarity.	わかりやすくするために出力を省略しています。
Because we are operating the test network as DigiBank and MagnetoCorp, `peer0.org1.example.com` will belong to the DigiBank organization while `peer0.org2.example.com` will be operated by MagnetoCorp.	私たちはテストネットワークをDigiBankとMagnetoCorpとして運営しているので、`peer0.org1.example.com`はDigiBank組織に属し、`peer0.org2.example.com`はMagnetoCorpによって運営されます。
Now that the test network is up and running, we can refer to our network as PaperNet from this point forward.	テストネットワークが稼動しているので、私たちのネットワークはこの時点からPaperNetと呼ぶことができます。
To recap:	要約すると:
you've downloaded the Hyperledger Fabric samples repository from GitHub and you've got a Fabric network running on your local machine.	GitHubからHyperledger Fabricサンプルリポジトリをダウンロードして、ローカルマシン上でFabricネットワークを稼働させています。
Let's now start to play the role of MagnetoCorp, who wishes to issue and trade commercial paper.	それでは、コマーシャルペーパーの発行取引を行うMagnetoCorpの役割を果たしてみましょう。
The commercial paper tutorial allows you to act as two organizations by providing two separate folders for DigiBank and MagnetoCorp.	コマーシャルペーパーチュートリアルでは、DigiBankとMagnetoCorpの2つの個別フォルダを提供することで、2つの組織として機能できます。
The two folders contain the smart contracts and application files for each organization.	2つのフォルダには、各組織のスマートコントラクトおよびアプリケーションファイルが含まれます。
Because the two organizations have different roles in the trading of the commercial paper, the application files are different for each organization.	2つの組織はコマーシャルペーパーの取引で異なる役割を持つため、アプリケーションファイルは組織ごとに異なります。
Open a new window in the `fabric-samples` repository and use the following command to change into the MagnetoCorp directory:	`fabric-samples`リポジトリで新しいウィンドウを開き、次のコマンドを使用してMagnetoCorpディレクトリに移動します:
The first thing we are going to do as MagnetoCorp is monitor the components of PaperNet.	MagnetoCorpとして最初にやることは、PaperNetのコンポーネントをモニターすることです。
An administrator can view the aggregated output from a set of Docker containers using the `logspout` [tool](https://github.com/gliderlabs/logspout#logspout).	管理者は`logspout`[ツール](https://github.com/gliderlabs/logspout#logspout)を使って、Dockerコンテナの集合からの集約出力を見ることができます。
The tool collects the different output streams into one place, making it easy to see what's happening from a single window.	このツールは、異なる出力ストリームを1つの場所に集め、1つのウィンドウで何が起きているかを簡単に見ることができます。
This can be really helpful for administrators when installing smart contracts or for developers when invoking smart contracts, for example.	これは、スマートコントラクトをインストールする管理者や、スマートコントラクトを起動する開発者にとって、非常に便利です。
In the MagnetoCorp directory, run the following command to run the `monitordocker.sh`  script and start the `logspout` tool for the containers associated with PaperNet running on `net_test`:	MagnetoCorpディレクトリで、次のコマンドを実行して`monitordocker.sh`スクリプトを実行し、`net_test`で実行されているPaperNetに関連付けられたコンテナの`logspout`ツールを起動します:
Note that you can pass a port number to the above command if the default port in `monitordocker.sh` is already in use.	`monitordocker.sh`のデフォルトポートがすでに使用されている場合は、上記のコマンドにポート番号を渡すことができます。
This window will now show output from the Docker containers for the remainder of the tutorial, so go ahead and open another command window.	このウィンドウには、チュートリアルの残りの部分で使用するDockerコンテナの出力が表示されるので、別のコマンドウィンドウを開きます。
The next thing we will do is examine the smart contract that MagnetoCorp will use to issue to the commercial paper.	次に、MagnetoCorpがコマーシャルペーパーに発行するために使用するスマートコントラクトを見ていきます。
`issue`, `buy` and `redeem` are the three functions at the heart of the commercial paper smart contract.	`issue`、`buy`および`redeem`は、コマーシャルペーパースマートコントラクトの中心となる3つの機能です。
It is used by applications to submit transactions which correspondingly issue, buy and redeem commercial paper on the ledger.	これらはそれぞれ台帳でコマーシャルペーパーを発行、購買および償却するためのトランザクションをサブミットするのにアプリケーションで使用されます。
Our next task is to examine this smart contract.	次のタスクは、このスマートコントラクトの中身を確認します。
Open a new terminal in the `fabric-samples` directory and change into the MagnetoCorp folder to act as the MagnetoCorp developer.	`fabric-samples`ディレクトリで新しい端末を開き、MagnetoCorpフォルダに移動してMagnetoCorp開発者として操作します。
You can then view the smart contract in the `contract` directory using your chosen editor (VS Code in this tutorial):	次に、選択したエディタ(このチュートリアルではVS Code)を使用して、`contract`ディレクトリ内のスマートコントラクトを表示できます:
In the `lib` directory of the folder, you'll see `papercontract.js` file --	そのフォルダの`lib`ディレクトリには、`papercontract.js`ファイルがあります。
this contains the commercial paper smart contract!	これにはコマーシャルペーパーのスマートコントラクトが含まれています!
An example code editor displaying the commercial paper smart contract in `papercontract.js` `papercontract.js` is a JavaScript program designed to run in the Node.js environment.	`papercontract.js`のコマーシャルペーパースマートコントラクトを表示するサンプルコードエディタ`papercontract.js`は、Node.js環境で実行するように設計されたJavaScriptプログラムです。
Note the following key program lines:	次の主要なプログラム行に注目してください:
This statement brings into scope two key Hyperledger Fabric classes that will be used extensively by the smart contract  -- `Contract` and `Context`.	このステートメントは、スマートコントラクトで広く使用される2つの主要なHyperledgerFabricクラス(`Contract`と`Context`)を利用可能にします。
You can learn more about these classes in the [`fabric-shim` JSDOCS](https://hyperledger.github.io/fabric-chaincode-node/).	これらのクラスの詳細については、[`fabric-shim`JSDOCS](https://hyperledger.github.io/fabric-chaincode-node/)を参照してください。
This defines the smart contract class `CommercialPaperContract` based on the built-in Fabric `Contract` class.	これにより、組込みFabric `Contract`クラスに基づいてスマートコントラクトクラス`CommercialPaperContract`が定義されます。
The methods which implement the key transactions to `issue`, `buy` and `redeem` commercial paper are defined within this class.	コマーシャルペーパーの`issue`、`buy`および`redeem`のための主要トランザクションを実装するメソッドは、このクラス内で定義されます。
This method defines the commercial paper `issue` transaction for PaperNet.	このメソッドは、PaperNetのコマーシャルペーパー`issue`トランザクションを定義します。
The parameters that are passed to this method will be used to create the new commercial paper.	このメソッドに渡されたパラメータは、新しいコマーシャルペーパーの作成に使用されます。
Locate and examine the `buy` and `redeem` transactions within the smart contract.	スマートコントラクト内の`buy`トランザクションと`redeem`トランザクションを検索して確認します。
Within the `issue` transaction, this statement creates a new commercial paper in memory using the `CommercialPaper` class with the supplied transaction inputs.	`issue`トランザクション内で、この文により指定されたトランザクション入力を持つ`CommercialPaper`クラスを使用して、メモリー内に新しいコマーシャルペーパーを作成します。
Examine the `buy` and `redeem` transactions to see how they similarly use this class.	このクラスを同様に使用する方法を確認するには、`buy`トランザクションと`redeem`トランザクションを調べます。
This statement adds the new commercial paper to the ledger using `ctx.paperList`, an instance of a `PaperList` class that was created when the smart contract context `CommercialPaperContext` was initialized.	この文は、`ctx.paperList`(スマートコントラクトコンテキスト`CommercialPaperContext`が初期化されたときに作成された`PaperList`クラスのインスタンス)を使用して、新しいコマーシャルペーパーを台帳に追加します。
Again, examine the `buy` and `redeem` methods to see how they use this class.	このクラスの使用方法を確認するには、再度、`buy`メソッドと`redeem`メソッドを調べます。
This statement returns a binary buffer as response from the `issue` transaction for processing by the caller of the smart contract.	この文は、`issue`トランザクションからの応答としてバイナリバッファを返し、スマートコントラクトの呼び出し側で処理します。
Feel free to examine other files in the `contract` directory to understand how the smart contract works, and read in detail how `papercontract.js` is designed in the [smart contract processing](../developapps/smartcontract.html) topic.	`contract`ディレクトリ内の他のファイルを自由に調べてスマートコントラクトの仕組みを理解し、`papercontract.js`が[スマートコントラクト処理](../developapps/smartcontract.html)のトピックでどのように設計されているかを詳しく読んでください。
Before `papercontract` can be invoked by applications, it must be installed onto the appropriate peer nodes of the test network and then defined on the channel using the [Fabric chaincode lifecycle](../chaincode_lifecycle.html#chaincode-lifecycle).	`papercontract`をアプリケーションから起動するには、テストネットワークの適切なピアノードにインストールしてから、[Fabric chaincode lifecycle](../chaincode_lifecycle.html#chaincode-lifecycle)を使用してチャネル上で定義する必要があります。
The Fabric chaincode lifecycle allows multiple organizations to agree to the parameters of a chaincode before the chaincode is deployed to a channel.	Fabric チェーンコードライフサイクルを使用すると、チャネルにチェーンコードを配布する前に、複数の組織がチェーンコードのパラメータに同意できます。
As a result, we need to install and approve the chaincode as administrators of both MagnetoCorp and DigiBank.	その結果、MagnetoCorpとDigiBankの両方の管理者としてチェーンコードをインストールして承認する必要があります。
A MagnetoCorp administrator installs a copy of the `papercontract` onto a MagnetoCorp peer.	MagnetoCorp管理者は、`papercontract`のコピーをMagnetoCorpピアにインストールします。
Smart contracts are the focus of application development, and are contained within a Hyperledger Fabric artifact called [chaincode](../chaincode.html).	スマートコントラクトはアプリケーション開発の焦点であり、[chaincode](../chaincode.html)と呼ばれるHyperledgerFabricアーティファクト内に含まれています。
One or more smart contracts can be defined within a single chaincode, and installing a chaincode will allow them to be consumed by the different organizations in PaperNet.	1つ以上のスマートコントラクトを単一のチェーンコード内で定義でき、チェーンコードをインストールすると、PaperNetの様々な組織でそれらを使用できます。
It means that only administrators need to worry about chaincode; everyone else can think in terms of smart contracts.	つまり、管理者のみがチェーンコードについて心配する必要があり、他のすべての人がスマートコントラクトについて考えることができます。
We will first install and approve the smart contract as the MagnetoCorp admin.	まず、MagnetoCorp管理者としてスマートコントラクトをインストールし、承認します。
Make sure that you are operating from the `magnetocorp` folder, or navigate back to that folder using the following command:	`magnetocorp`フォルダから操作していることを確認するか、次のコマンドを使用してそのフォルダに戻ります:
A MagnetoCorp administrator can interact with PaperNet using the `peer` CLI.	MagnetoCorp管理者は、`peer` CLIを使用してPaperNetと対話できます。
However, the administrator needs to set certain environment variables in their command window to use the correct set of `peer` binaries, send commands to the address of the MagnetoCorp peer, and sign requests with the correct cryptographic material.	ただし、管理者は、コマンドウィンドウで特定の環境変数を設定して、正しい`peer`バイナリセットを使用し、MagnetoCorpピアのアドレスにコマンドを送信し、正しい暗号化マテリアルで要求に署名する必要があります。
You can use a script provided by the sample to set the environment variables in your command window.	サンプルで提供されているスクリプトを使用して、コマンドウィンドウで環境変数を設定できます。
Run the following command in the `magnetocorp` directory:	`magnetocorp`のディレクトリで次のコマンドを実行します:
You will see the full list of environment variables printed in your window.	環境変数の完全なリストがウィンドウに表示されます。
We can now use this command window to interact with PaperNet as the MagnetoCorp administrator.	このコマンドウィンドウを使用して、MagnetoCorp管理者としてPaperNetと対話できます。
The first step is to install the `papercontract` smart contract.	最初のステップは、`papercontract`スマートコントラクトをインストールすることです。
The smart contract can be packaged into a chaincode using the `peer lifecycle chaincode package` command.	スマートコントラクトは、`peer lifecycle chaincode package`コマンドを使用して、チェーンコードにパッケージ化できます。
In the MagnetoCorp administrator's command window, run the following command to create the chaincode package:	MagnetoCorp管理者のコマンドウィンドウで、次のコマンドを実行して、チェーンコードパッケージを作成します:
The MagnetoCorp admin can now install the chaincode on the MagnetoCorp peer using the `peer lifecycle chaincode install` command:	MagnetoCorp管理者は、`peer lifecycle chaincode install`コマンドを使用して、MagnetoCorpピアにチェーンコードをインストールできるようになりました:
When the chaincode package is installed, you will see messages similar to the following printed in your terminal:	チェーンコードパッケージをインストールすると、次のようなメッセージが端末に出力されます:
Because the MagnetoCorp admin has set `CORE_PEER_ADDRESS=localhost:9051` to target its commands to `peer0.org2.example.com`, the `INFO 001 Installed remotely...` indicates that `papercontract` has been successfully installed on this peer.	MagnetoCorp管理者は`CORE_PEER_ADDRESS=localhost:9051`を設定して、コマンドのターゲットを`peer0.org2.example.com`に設定しているため、`INFO 001 Installed remotely...`は、`papercontract`がこのピアに正常にインストールされたことを示します。
After we install the smart contract, we need to approve the chaincode definition for `papercontract` as MagnetoCorp.	スマートコントラクトをインストールした後、`papercontract`のチェーンコード定義をMagnetoCorpとして承認する必要があります。
The first step is to find the packageID of the chaincode we installed on our peer.	最初のステップは、ピアにインストールしたチェーンコードのパッケージIDを検索することです。
We can query the packageID using the `peer lifecycle chaincode queryinstalled` command:	`peer lifecycle chaincode queryinstalled`コマンドを使用してパッケージIDを照会できます:
The command will return the same package identifier as the install command.	このコマンドは、installコマンド実行時と同じパッケージ識別子(パッケージID)を返します。
You should see output similar to the following:	次のような出力が表示されます:
We will need the package ID in the next step, so we will save it as an environment variable.	次の手順ではパッケージIDが必要になるため、パッケージIDを環境変数として保存します。
The package ID may not be the same for all users, so you need to complete this step using the package ID returned from your command window.	パッケージIDはすべてのユーザーで同じではない可能性があるため、あなたのコマンドウィンドウから返されたパッケージIDを使用してこのステップを完了する必要があります。
The admin can now approve the chaincode definition for MagnetoCorp using the `peer lifecycle chaincode approveformyorg` command:	管理者は、`peer lifecycle chaincode approveformyorg`コマンドを使用して、MagnetoCorpのチェーンコード定義を承認できるようになりました:
One of the most important chaincode parameters that channel members need to agree to using the chaincode definition is the chaincode [endorsement policy](../endorsement-policies.html).	チャネルメンバーがチェーンコード定義の使用に同意する必要がある最も重要なチェーンコードパラメータの1つは、チェーンコード[エンドースメントポリシー](../endorsement-policies.html)です。
The endorsement policy describes the set of organizations that must endorse (execute and sign) a transaction before it can be determined to be valid.	エンドースメントポリシーは、トランザクションが有効であると判断する前にトランザクションをエンドース(実行および署名)する必要がある組織のセットを記述します。
By approving the `papercontract` chaincode without the ``--policy`` flag, the MagnetoCorp admin agrees to using the channel's default `Endorsement` policy, which in the case of the `mychannel` test channel requires a majority of organizations on the channel to endorse a transaction.	``--policy``フラグを使用せずに`papercontract`チェーンコードを承認すると、MagnetoCorp管理者はチャネルのデフォルトの`エンドースメント`ポリシーを使用することに同意します。これは、`mychannel`テストチャネルの場合、チャネル上の過半数の組織がトランザクションを保証することを要求します。
All transactions, whether valid or invalid, will be recorded on the [ledger blockchain](../ledger/ledger.html#blockchain), but only valid transactions will update the [world state](../ledger/ledger.html#world-state).	すべてのトランザクションは、有効か無効かにかかわらず[台帳ブロックチェーン](../ledger/ledger.html#blockchain)に記録されますが、有効なトランザクションのみが[ワールドステート](../ledger/ledger.html#world-state)を更新します。
Based on the `mychannel` `LifecycleEndorsement` policy, the Fabric Chaincode lifecycle will require a majority of organizations on the channel to agree to the chaincode definition before the chaincode can be committed to the channel.	`mychannel`の`LifecycleEndorsement`ポリシーに基づくと、Fabricチェーンコードライフサイクルでは、チャネルにチェーンコードをコミットする前に、チャネル上の過半数の組織がチェーンコード定義に同意する必要があります。
This implies that we need to approve the `papernet` chaincode as both MagnetoCorp and DigiBank to get the required majority of 2 out of 2.	これは、2つのうちの2つの必要な過半数を取得するために、MagnetoCorpとDigiBankの両方で`papernet`チェーンコードを承認する必要があることを意味します。
Open a new terminal window in the `fabric-samples` and navigate to the folder that contains the DigiBank smart contract and application files:	`fabric-samples`で新しいターミナルウィンドウを開き、DigiBankスマートコントラクトファイルとアプリケーションファイルが格納されているフォルダに移動します:
Use the script in the DigiBank folder to set the environment variables that will allow you to act as the DigiBank admin:	DigiBankフォルダのスクリプトを使用して、DigiBank管理者として機能するための環境変数を設定します:
We can now install and approve `papercontract` as the DigiBank.	これで、`papercontract`をDigiBankとしてインストールし、承認することができます。
Run the following command to package the chaincode:	次のコマンドを実行して、チェーンコードをパッケージ化します:
The admin can now install the chaincode on the DigiBank peer:	これで、管理者はDigiBankピアにチェーンコードをインストールできます:
We then need to query and save the packageID of the chaincode that was just installed:	次に、インストールされたばかりのチェーンコードのパッケージIDを照会して保存する必要があります:
Save the package ID as an environment variable.	パッケージIDを環境変数として保存します。
Complete this step using the package ID returned from your console.	コンソールから返されたパッケージIDを使用して、この手順を完了します。
The Digibank admin can now approve the chaincode definition of `papercontract`:	Digibankの管理者は、`papercontract`のチェーンコード定義を承認できるようになりました:
Now that DigiBank and MagnetoCorp have both approved the `papernet` chaincode, we have the majority we need (2 out of 2) to commit the chaincode definition to the channel.	DigiBankとMagnetoCorpの両方が`papernet`チェーンコードを承認したので、チャネルにチェーンコード定義をコミットするために必要な過半数(2つのうち2つ)の承認があります。
Once the chaincode is successfully defined on the channel, the `CommercialPaper` smart contract inside the `papercontract` chaincode can be invoked by client applications on the channel.	チャネルでチェーンコードが正常に定義されると、`papercontract`チェーンコード内の`CommercialPaper`のスマートコントラクトをチャネルのクライアントアプリケーションから起動できます。
Since either organization can commit the chaincode to the channel, we will continue operating as the DigiBank admin:	どちらの組織でもチェーンコードをチャネルにコミットできるため、DigiBank管理者として操作を続行します:
After the DigiBank administrator commits the definition of the `papercontract` chaincode to the channel, a new Docker chaincode container will be created to run `papercontract` on both PaperNet peers	DigiBank管理者が`papercontract`チェーンコードの定義をチャネルにコミットした後、新しいDockerチェーンコードコンテナが、PaperNetの両方のピア上で`papercontract`を実行するために作成されます
The DigiBank administrator uses the `peer lifecycle chaincode commit` command to commit the chaincode definition of `papercontract` to `mychannel`:	DigiBank管理者は、`peer lifecycle chaincode commit`コマンドを使用して、`papercontract`のチェーンコード定義を`mychannel`にコミットします:
The chaincode container will start after the chaincode definition has been committed to the channel.	チェーンコードコンテナは、チェーンコード定義がチャネルにコミットされた後に起動します。
You can use the `docker ps` command to see `papercontract` container starting on both peers.	`docker ps`コマンドを使用すると、`papercontract`コンテナが両方のピアで起動されているのを確認できます。
Notice that the containers are named to indicate the peer that started it, and the fact that it's running `papercontract` version `0`.	コンテナには、そのコンテナを起動したピア、そして`papercontract`バージョン`0`を実行していることを示す名前が付けられることに注意してください。
Now that we have deployed the `papercontract` chaincode to the channel, we can use the MagnetoCorp application to issue the commercial paper.	チャネルに`papercontract`チェーンコードをデプロイしたので、MagnetoCorpアプリケーションを使用してコマーシャルペーパーを発行できます。
Let's take a moment to examine the application structure.	アプリケーションの構造を確認します。
The smart contract contained in `papercontract` is called by MagnetoCorp's application `issue.js`.	`papercontract`に含まれるスマートコントラクトは、MagnetoCorpのアプリケーション`issue.js`によって呼び出されます。
Isabella uses this application to submit a transaction to the ledger which issues commercial paper `00001`.	Isabellaはこのアプリケーションを使用して、コマーシャルペーパー`00001`を発行するトランザクションを台帳にサブミットします。
Let's quickly examine how the `issue` application works.	`issue`アプリケーションがどのように機能するかを簡単に調べてみましょう。
allows an application to focus on transaction generation, submission and response.	*ゲートウェイを使用すると、アプリケーションはトランザクションの生成、送信、および応答に集中できます。
It coordinates transaction proposal, ordering and notification processing between the different network components.	ゲートウェイは、異なるネットワークコンポーネント間でトランザクションの提案、順序付け、および通知処理を調整します。
Because the `issue` application submits transactions on behalf of Isabella, it starts by retrieving Isabella's X.509 certificate from her [wallet](../developapps/wallet.html), which might be stored on the local file system or a Hardware Security Module [HSM](https://en.wikipedia.org/wiki/Hardware_security_module).	`issue`アプリケーションは、Isabellaに代わってトランザクションをサブミットするため、まずIsabellaの[ウォレット](../developapps/wallet.html)からX.509証明書を取得します。この証明書は、ローカルファイルシステムまたはハードウェアセキュリティモジュール[HSM](https://en.wikipedia.org/wiki/Hardware_security_module)に格納されている可能性があります。
The `issue` application is then able to utilize the gateway to submit transactions on the channel.	`issue`アプリケーションは、ゲートウェイを使用してチャネル上のトランザクションをサブミットできます。
The Hyperledger Fabric SDK provides a [gateway](../developapps/gateway.html) abstraction so that applications can focus on application logic while delegating network interaction to the gateway.	Hyperledger Fabric SDKは[ゲートウェイ](../developapps/gateway.html)抽象化を提供するため、アプリケーションはアプリケーションロジックに集中しながら、ゲートウェイにネットワーク間の対話を委任できます。
Gateways and wallets make it straightforward to write Hyperledger Fabric applications.	ゲートウェイとウォレットを使用すると、Hyperledger Fabricアプリケーションを簡単に記述できます。
So let's examine the `issue` application that Isabella is going to use.	では、Isabellaが使用する`issue`アプリケーションを調べてみましょう。
Open a separate terminal window for her, and in `fabric-samples` locate the MagnetoCorp `/application` folder:	Isabella用に別のターミナルウィンドウを開き、`fabric-samples`でMagnetoCorp`/application`フォルダを見つけます:
`addToWallet.js` is the program that Isabella is going to use to load her identity into her wallet, and `issue.js` will use this identity to create commercial paper `00001` on behalf of MagnetoCorp by invoking `papercontract`.	`addToWallet.js`は、Isabellaが自分のアイデンティティをウォレットにロードするために使用するプログラムで、`issue.js`はこのアイデンティティを使用して、`papercontract`を呼び出すことでMagnetoCorpの代わりにコマーシャルペーパー`00001`を作成します。
Change to the directory that contains MagnetoCorp's copy of the application `issue.js`, and use your code editor to examine it:	アプリケーション`issue.js`のMagnetoCorpのコピーを含むディレクトリに移動し、コードエディタを使用して確認します:
Examine this directory; it contains the issue application and all its dependencies.	このディレクトリには、issueアプリケーションとそのすべての依存関係が含まれています。
displaying the contents of the commercial paper application directory.	コマーシャルペーパーアプリケーションディレクトリの内容を表示するコードエディタ。
Note the following key program lines in `issue.js`:	`issue.js`の以下の主要なプログラム行に注意してください:
This statement brings two key Hyperledger Fabric SDK classes into scope --	`Wallet` and `Gateway`.このステートメントは、`Wallet`と`Gateway`という2つの主要なHyperledger Fabric SDKクラスをスコープに入れます。
This statement identifies that the application will use `isabella` wallet when it connects to the blockchain network channel.	この文は、アプリケーションがブロックチェーンネットワークチャネルに接続するときに、`isabella`のウォレットを使用することを示します。
Because Isabella's X.509 certificate is in the local file system, the application creates a new `FileSystemWallet`.	`Isabella`のX.509証明書はローカルファイルシステムにあるため、アプリケーションは新規`FileSystemWallet`を作成します。
The application will select a particular identity within `isabella` wallet.	アプリケーションは、isabellaのウォレット内の特定のアイデンティティを選択します。
This line of code connects to the network using the gateway identified by `connectionProfile`, using the identity referred to in `ConnectionOptions`.	このコード行は、`ConnectionOptions`で参照される識別を使用して、`connectionProfile`で識別されるゲートウェイを使用してネットワークに接続します。
See how `../gateway/networkConnection.yaml` and `User1@org1.example.com` are used for these values respectively.	これらの値に`../gateway/networkConnection.yaml`および`User1@org1.example.com`がどのように使われているか参照してください。
This connects the application to the network channel `mychannel`, where the `papercontract` was previously deployed.	これにより、アプリケーションがネットワークチャネル`mychannel`に接続されます。mychannelには、以前に`papercontract`がデプロイされています。
This statement gives the application access to the `papercontract` chaincode.	このステートメントは、アプリケーションに`papercontract`チェーンコードへのアクセスを許可します。
Once an application has issued getContract, it can submit to any smart contract transaction implemented within the chaincode.	アプリケーションがgetContractを発行すると、チェーンコード内に実装されたスマートコントラクトトランザクションにサブミットできます。
This line of code submits the a transaction to the network using the `issue` transaction defined within the smart contract.	このコード行では、スマートコントラクト内で定義された`issue`トランザクションを使用して、ネットワークにトランザクションをサブミットします。
`MagnetoCorp`, `00001`... are the values to be used by the `issue` transaction to create a new commercial paper.	`MagnetoCorp`、`00001`... は、新しいコマーシャルペーパーを作成するために`issue`トランザクションで使用される値です。
This statement processes the response from the `issue` transaction.	この文は、`issue`トランザクションからの応答を処理します。
The response needs to deserialized from a buffer into `paper`, a `CommercialPaper` object which can interpreted correctly by the application.	応答は、バッファから`ペーパー`(アプリケーションが正しく解釈できる`CommercialPaper`オブジェクト)にデシリアライズする必要があります。
Feel free to examine other files in the `/application` directory to understand how `issue.js` works, and read in detail how it is implemented in the application [topic](../developapps/application.html).	`/application`ディレクトリにある他のファイルを調べて、`issue.js`がどのように動作するかを理解し、アプリケーション[トピック](../developapps/application.html)でその実装方法を詳しく読んでください。
The `issue.js` application is written in JavaScript and designed to run in the Node.js environment that acts as a client to the PaperNet network.	`issue.js`アプリケーションはJavaScriptで作成され、PaperNetネットワークのクライアントとして機能するNode.js環境で実行されるように設計されています。
As is common practice, MagnetoCorp's application is built on many external node packages --- to improve quality and speed of development.	一般的に、MagnetoCorpのアプリケーションは多くの外部Node.jsパッケージ上に構築され、開発の品質と速度が向上しています。
Consider how `issue.js` includes the `js-yaml` [package](https://www.npmjs.com/package/js-yaml) to process the YAML gateway connection profile, or the `fabric-network` [package](https://www.npmjs.com/package/fabric-network) to access the `Gateway` and `Wallet` classes:	YAMLゲートウェイコネクションプロファイルを処理する`js-yaml`[パッケージ](https://www.npmjs.com/package/js-yaml)、または`Gateway`および`Wallet`クラスにアクセスする`fabric-network`[パッケージ](https://www.npmjs.com/package/fabric-network)が、`issue.js`にどのように含まれているかを考慮してください:
These packages have to be downloaded from [npm](https://www.npmjs.com/) to the local file system using the `npm install` command.	これらのパッケージは、`npm install`コマンドを使用して[npm](https://www.npmjs.com/)からローカルファイルシステムにダウンロードする必要があります。
By convention, packages must be installed into an application-relative `/node_modules` directory for use at runtime.	通常、パッケージは実行時に使用するために、アプリケーションディレクトリからの相対パスで`/node_modules`ディレクトリにインストールする必要があります。
Open the `package.json` file to see how `issue.js` identifies the packages to download and their exact versions by examining the "dependencies" section of the file.	`package.json`ファイルを開き、ファイルの"dependencies"セクションを調べて、`issue.js`がダウンロードするパッケージとその正確なバージョンを識別する方法を確認します。
npm versioning is very powerful;	npmのバージョン管理は非常に強力です。
you can read more about it [here](https://docs.npmjs.com/getting-started/semantic-versioning).	詳しくは[こちら](https://docs.npmjs.com/getting-started/semantic-versioning)をご覧ください。
Let's install these packages with the `npm install` command --	`npm install`コマンドを使用して、これらのパッケージをインストールしてみましょう。
this may take up to a minute to complete:	インストールが完了するまで、1分ほどかかる場合があります:
See how this command has updated the directory:	このコマンドでディレクトリが更新されたことを確認してください:
Examine the `node_modules` directory to see the packages that have been installed.	`node_modules`ディレクトリを調べて、インストールされているパッケージを確認します。
There are lots, because `js-yaml` and `fabric-network` are themselves built on other npm packages!	`js-yaml`と`fabric-network`はそれ自体が他のnpmパッケージ上に構築されているので、たくさんあります! 
Helpfully, the `package-lock.json` [file](https://docs.npmjs.com/files/package-lock.json) identifies the exact versions installed, which can prove invaluable if you want to exactly reproduce environments; to test, diagnose problems or deliver proven applications for example.	`package-lock.json`[ファイル](https://docs.npmjs.com/files/package-lock.json)はインストールされている正確なバージョンを識別するので、テストや問題の診断、実績のあるアプリケーションの提供など、環境を正確に再現したい場合には非常に役立ちます。
Isabella is almost ready to run `issue.js` to issue MagnetoCorp commercial paper `00001`;	Isabellaは、`issue.js`を実行してMagnetoCorpのコマーシャルペーパー`00001`を発行する準備がほぼ整いました。
there's just one remaining task to perform!	実行するタスクはあと1つだけ残っています。
As `issue.js` acts on behalf of Isabella, and therefore MagnetoCorp, it will use identity from her [wallet](../developapps/wallet.html) that reflects these facts.	`issue.js`はIsabellaの代理として動作するため、MagnetoCorpはこれらの事実を反映する彼女の[wallet](../developapps/wallet.html)からのアイデンティティを使用します。
We now need to perform this one-time activity of generating the appropriate X.509 credentials to her wallet.	ここで、ウォレットに適切なX.509資格証明を生成する、この1回限りのアクティビティを実行する必要があります。
The MagnetoCorp Certificate Authority running on PaperNet, `ca_org2`, has an application user that was registered when the network was deployed.	PaperNet上のMagnetoCorpの証明機関`ca_org2`には、ネットワークのデプロイ時に登録されたアプリケーションユーザーがあります。
Isabella can use the identity name and secret to generate the X.509 cryptographic material for the `issue.js` application.	Isabellaは、アイデンティティ名とシークレットを使用して、`issue.js`アプリケーションのX.509暗号化マテリアルを生成できます。
The process of using a CA to generate client side cryptographic material is referred to as enrollment.	CAを使用してクライアント側の暗号化マテリアルを生成するプロセスは、エンロールメントと呼ばれます。
In a real word scenario, a network operator would provide the name and secret of a client identity that was registered with the CA to an application developer.	実際のシナリオでは、ネットワークオペレータが、CAに登録されたクライアントアイデンティティの名前とシークレットをアプリケーション開発者に提供します。
The developer would then use the credentials to enroll their application and interact with the network.	開発者は、資格証明を使用してアプリケーションをエンロールし、ネットワークと対話します。
The `enrollUser.js` program uses the `fabric-ca-client` class to generate a private and public key pair, and then issues a Certificate Signing Request to the CA.	`enrollUser.js`プログラムは`fabric-ca-client`クラスを使用して秘密鍵と公開鍵のペアを生成し、認証局に証明書署名要求を発行します。
If the identiy name and secret submitted by Isabella match the credentials registered with the CA, the CA will issue and sign a certificate that encodes the public key, establishing that Isabella belongs to MagnetoCorp.	Isabellaによって送信されたアイデンティティの名とシークレットが認証局に登録された資格証明と一致した場合、認証局は公開鍵をエンコードする証明書を発行して署名し、IsabellaがMagnetoCorpに属していることを証明します。
When the signing request is complete, `enrollUser.js` stores the private key and signing certificate in Isabella's wallet.	署名要求が完了すると、`enrollUser.js`はIsabellaのウォレットに秘密鍵と署名証明書を格納します。
You can examine the `enrollUser.js` file to learn more about how the Node SDK uses the `fabric-ca-client` class to complete these tasks.	Node SDKが`fabric-ca-client`クラスを使用してこれらのタスクを完了する方法については、`enrollUser.js`ファイルを参照してください。
In Isabella's terminal window, run the `enrollUser.js` program to add identity information to her wallet:	Isabellaのターミナルウィンドウで、`enrollUser.js`プログラムを実行して、Isabellaのウォレットにアイデンティティ情報を追加します:
We can now turn our focus to the result of this program --- the contents of the wallet which will be used to submit transactions to PaperNet:	次に、このプログラムの結果、つまりPaperNetへのトランザクションのサブミットに使用されるウォレットの内容に注目します:
Isabella can store multiple identities in her wallet, though in our example, she only uses one.	Isabellaは複数のアイデンティティをウォレットに格納できますが、この例では1つのアイデンティティしか使用しません。
The `wallet` folder contains an `isabella.id` file that provides the information that Isabella needs to connect to the network.	`wallet`フォルダには、Isabellaがネットワークに接続するために必要な情報を提供する`isabella.id`ファイルが含まれています。
Other identities used by Isabella would have their own file.	Isabellaが使用する他のIDには、独自のファイルがあります。
You can open this file to see the identity information that `issue.js` will use on behalf of Isabella inside a JSON file.	このファイルを開くと、`issue.js`がIsabellaに代わって使用するアイデンティティ情報をJSONファイル内で確認できます。
The output has been formatted for clarity.	出力はわかりやすいようにフォーマットされています。
In the file you can notice the following:	このファイルでは、次のことがわかります:
a `"privateKey":` used to sign transactions on Isabella's behalf, but not distributed outside of her immediate control.	`"privateKey":` Isabellaに代わってトランザクションに署名するために使用されるが、彼女の直接のコントロールの外には配布されません。
a `"certificate":` which contains Isabella's public key and other X.509 attributes added by the Certificate Authority at certificate creation.	`"証明書":` 証明書の作成時に認証局によって追加されたIsabellaの公開鍵と他のX.509属性を含みます。
This certificate is distributed to the network so that different actors at different times can cryptographically verify information created by Isabella's private key.	この証明書はネットワークに配布されます。これにより、異なる時に異なるアクターが、Isabellaの秘密鍵によって作成された情報を暗号で検証できます。
You can Learn more about certificates [here](../identity/identity.html#digital-certificates).	証明書の詳細については、[こちら](../identity/identity.html#digital-certificates)から更に学ぶことができます。
In practice, the certificate file also contains some Fabric-specific metadata such as Isabella's organization and role -- read more in the [wallet](../developapps/wallet.html) topic.	実際には、証明書ファイルには、Isabellaの組織や役割などのFabric固有のメタデータも含まれています。詳細については、[ウォレット](../developapps/wallet.html)のトピックを参照してください。
Isabella can now use `issue.js` to submit a transaction that will issue MagnetoCorp commercial paper `00001`:	Isabellaは、`issue.js`を使って、MagnetoCorpのコマーシャルペーパー`00001`を発行するトランザクションをサブミットすることができるようになりました:
The `node` command initializes a Node.js environment, and runs `issue.js`.	`node`コマンドは、Node.js環境を初期化し、`issue.js`を実行します。
We can see from the program output that MagnetoCorp commercial paper 00001 was issued with a face value of 5M USD.	プログラムの出力から、MagnetoCorpコマーシャルペーパー 00001 が額面500万米ドルで発行されたことがわかります。
As you've seen, to achieve this, the application invokes the `issue` transaction defined in the `CommercialPaper` smart contract within `papercontract.js`.	ここまで見てきた通り、これを実現するために、アプリケーションは`papercontract.js`内の`CommercialPaper`スマートコントラクトで定義された`issue`トランザクションを起動します。
The smart contract interacts with the ledger via the Fabric APIs, most notably `putState()` and `getState()`, to represent the new commercial paper as a vector state within the world state.	スマートコントラクトは、Fabric APIを介して台帳と対話し、特に`putState()`および`getState()`を使用して、新しいコマーシャルペーパーをワールドステート内のベクトル状態として表します。
We'll see how this vector state is subsequently manipulated by the `buy` and `redeem` transactions also defined within the smart contract.	このベクトル状態が、スマートコントラクト内で定義された`buy`トランザクションおよび`redeem`トランザクションによって後でどのように操作されるかについて説明します。
All the time, the underlying Fabric SDK handles the transaction endorsement, ordering and notification process, making the application's logic straightforward;	常に、基盤となるFabric SDKがトランザクションのエンドースメント、順序付け、通知プロセスを処理し、アプリケーションのロジックを単純化します。
the SDK uses a [gateway](../developapps/gateway.html) to abstract away network details and [connectionOptions](../developapps/connectoptions.html) to declare more advanced processing strategies such as transaction retry.	SDKは[ゲートウェイ](../developapps/gateway.html)を使用してネットワークの詳細を抽象化し、[connectionOptions](../developapps/connectoptions.html)を使用してトランザクションの再試行などのより高度な処理戦略を宣言します。
Let's now follow the lifecycle of MagnetoCorp 00001 by switching our emphasis to an employee of DigiBank, Balaji, who will buy the commercial paper using a DigiBank application.	次に、DigiBankアプリケーションを使用してコマーシャルペーパーを購入するDigiBankの従業員であるBalajiに重点を置き、MagnetoCorp 00001 のライフサイクルを見てみましょう。
Balaji uses DigiBank's `buy` application to submit a transaction to the ledger which transfers ownership of commercial paper `00001` from MagnetoCorp to DigiBank.	Balajiは、DigiBankの`buy`アプリケーションを使用して、コマーシャルペーパー`00001`の所有権をMagnetoCorpからDigiBankに譲渡するトランザクションを台帳にサブミットします。
The `CommercialPaper` smart contract is the same as that used by MagnetoCorp's application, however the transaction is different this time -- it's `buy` rather than `issue`.	`CommercialPaper`のスマート契約は、MagnetoCorpの申請で使用されるものと同じですが、今回はトランザクションが異なります。`issue`ではなく`buy`です。
Let's examine how DigiBank's application works.	DigiBankのアプリケーションがどのように機能するかを調べてみましょう。
Open a separate terminal window for Balaji.	Balaji用の別のターミナルウィンドウを開きます。
In `fabric-samples`, change to the DigiBank application directory that contains the application, `buy.js`, and open it with your editor:	`fabric-samples`で、アプリケーション`buy.js`が格納されているDigiBankアプリケーションディレクトリに移動し、エディタでそれを開きます:
As you can see, this directory contains both the `buy` and `redeem` applications that will be used by Balaji.	ご覧のように、このディレクトリには、Balajiが使用する`buy`アプリケーションと`redeem`アプリケーションの両方が含まれています。
DigiBank's commercial paper directory containing the `buy.js` and `redeem.js` applications.	`buy.js`と`redeem.js`のアプリケーションを含むDigiBankのコマーシャルペーパーディレクトリ。
DigiBank's `buy.js` application is very similar in structure to MagnetoCorp's `issue.js` with two important differences:	DigiBankの`buy.js`アプリケーションは、MagnetoCorpの`issue.js`と構造がよく似ていますが、2つの重要な違いがあります:
Identity:	アイデンティティ:
the user is a DigiBank user `Balaji` rather than MagnetoCorp's `Isabella` See how the application uses the `balaji` wallet when it connects to the PaperNet network channel.	ユーザーがMagnetoCorpの`Isabella`ではなくDigiBankのユーザーである`Balaji`アプリケーションがPaperNetのネットワークチャネルに接続するときに、`baraji`のウォレットをどのように使用するかを見てください。
`buy.js` selects a particular identity within `balaji` wallet.	`buy.js`は`baraji`ウォレット内の特定のアイデンティティを選択します。
Transaction:	トランザクション:
the invoked transaction is `buy` rather than `issue` A `buy` transaction is submitted with the values `MagnetoCorp`, `00001`, ..., that are used by the `CommercialPaper` smart contract class to transfer ownership of commercial paper `00001` to DigiBank.	起動されたトランザクションは、`issue`ではなく`buy`です`MagnetoCorp`,`00001`, ...の値を持つ`buy`トランザクションがサブミットされ、これらの値は、コマーシャルペーパー`00001`の所有権をDigiBankに移転するために`CommercialPaper`スマートコントラクトクラスによって使用されます。
Feel free to examine other files in the `application` directory to understand how the application works, and read in detail how `buy.js` is implemented in the application [topic](../developapps/application.html).	`application`ディレクトリにある他のファイルを調べて、アプリケーションの動作を理解し、アプリケーション[トピック](../developapps/application.html)で`buy.js`がどのように実装されているかを詳細に読んでください。
The DigiBank applications which buy and redeem commercial paper have a very similar structure to MagnetoCorp's issue application.	コマーシャルペーパーを購入および償還するDigiBankのアプリケーションは、MagnetoCorpのissueアプリケーションと非常によく似た構造を持っています。
Therefore, let’s install their dependencies and set up Balaji's wallet so that he can use these applications to buy and redeem commercial paper.	したがって、これらのアプリケーションをコマーシャルペーパーの購入および償還に使用できるように、これらのアプリケーションの依存関係をインストールし、Balajiのウォレットを設定します。
Like MagnetoCorp, Digibank must the install the required application packages using the ``npm install`` command, and again, this make take a short time to complete.	MagnetoCorpの場合と同様に、Digibankは``npm install``コマンドを使用して必要なアプリケーションパッケージをインストールする必要がありますが、これも短時間で完了します。
In the DigiBank administrator window, install the application dependencies:	DigiBank管理者ウィンドウで、アプリケーションの依存関係をインストールします:
In Balaji's command window, run the `enrollUser.js` program to generate a certificate and private key and them to his wallet:	Balajiのコマンドウィンドウで、`enrollUser.js`プログラムを実行して証明書と秘密鍵を生成し、ウォレットに渡します:
The `addToWallet.js` program has added identity information for `balaji`, to his wallet, which will be used by `buy.js` and `redeem.js` to submit transactions to `PaperNet`.	`addToWallet.js`プログラムは、彼のウォレットに`balaji`のアイデンティティ情報を追加し、`buy.js`と`redeem.js`が`PaperNet`にトランザクションを送信するために使用します。
Like Isabella, Balaji can store multiple identities in his wallet, though in our example, he only uses one.	Isabellaと同様に、Balajiも複数のアイデンティティをウォレットに格納できますが、この例では1つのアイデンティティしか使用していません。
His corresponding id file at `digibank/identity/user/balaji/wallet/balaji.id` is very similar Isabella's ---	`digibank/identity/user/balaji/wallet/balaji.id`にある対応するIDファイルは、Isabellaと非常によく似ています。
feel free to examine it.	自由に調べてみてください。
Balaji can now use `buy.js` to submit a transaction that will transfer ownership of MagnetoCorp commercial paper 00001 to DigiBank.	Balajiは`buy.js`を使ってMagnetoCorpのコマーシャルペーパー 00001 の所有権をDigiBankに譲渡するトランザクションを行うことが今できる状態です。
Run the `buy` application in Balaji's window:	Balajiのウィンドウで`buy`アプリケーションを実行します:
You can see the program output that MagnetoCorp commercial paper 00001 was successfully purchased by Balaji on behalf of DigiBank.	MagnetoCorpのコマーシャルペーパー 00001 がDigiBankの代理としてBalajiによって正常に購入されたというプログラム出力を見ることができます。
`buy.js` invoked the `buy` transaction defined in the `CommercialPaper` smart contract which updated commercial paper `00001` within the world state using the `putState()` and `getState()` Fabric APIs.	`buy.js`は、`CommercialPaper`のスマートコントラクトで定義された`buy`トランザクションを呼び出しました。このスマートコントラクトでは、`putState()`と`getState()`のFabric APIを使用して、ワールドステート内でコマーシャルペーパー`00001`を更新しました。
As you've seen, the application logic to buy and issue commercial paper is very similar, as is the smart contract logic.	これまで見てきたように、コマーシャルペーパーを購入して発行するアプリケーションロジックは、スマートコントラクトロジックと非常によく似ています。
The final transaction in the lifecycle of commercial paper 00001 is for DigiBank to redeem it with MagnetoCorp.	コマーシャルペーパー 00001 のライフサイクルにおける最後のトランザクションは、DigiBankがそれをMagnetoCorpで償還することです。
Balaji uses `redeem.js` to submit a transaction to perform the redeem logic within the smart contract.	Balajiは、スマートコントラクト内で償還ロジックを実行するために、`redeem.js`を使用してトランザクションをサブミットします。
Run the `redeem` transaction in Balaji's window:	Balajiのウィンドウで`redeem`トランザクションを実行します:
Again, see how the commercial paper 00001 was successfully redeemed when `redeem.js` invoked the `redeem` transaction defined in `CommercialPaper`.	ここでも、`redeem.js`が`CommercialPaper`で定義された`redeem`トランザクションを起動したときに、コマーシャルしてコマーシャルペーパー 00001 が正常に償還されたかを見てください。
Again, it updated commercial paper `00001` within the world state to reflect that the ownership returned to MagnetoCorp, the issuer of the paper.	ここでも、ワールドステート内のコマーシャルペーパー`00001`を更新して、所有権がそのペーパーの発行者であるMagnetoCorpに戻ったことを反映しています。
When you are finished using the Commercial Paper tutorial, you can use a script to clean up your environment.	コマーシャルペーパーのチュートリアルを終了する時には、スクリプトを使用して環境をクリーンアップできます。
Use a command window to navigate back to the root directory of the commercial paper sample:	コマンドウィンドウを使用して、コマーシャルペーパーのサンプルのルートディレクトリに戻ります:
You can then bring down the network with the following command:	その後、次のコマンドを使用してネットワークを停止できます:
This command will bring down the peers, CouchDB containers, and ordering node of the network, in addition to the logspout tool.	このコマンドは、logspoutツールに加えて、ネットワークのピア、CouchDBコンテナ、およびオーダリングノードを停止します。
It will also remove the identities that we created for Isabella and Balaji.	また、IsabellaとBalajiのために作成したアイデンティティも削除します。
Note that all of the data on the ledger will be lost.	台帳のデータはすべて失われることに注意してください。
If you want to go through the tutorial again, you will start from a clean initial state.	チュートリアルをもう一度実行する場合は、クリーンな初期状態から開始します。
To understand how applications and smart contracts shown in this tutorial work in more detail, you'll find it helpful to read [Developing Applications](../developapps/developing_applications.html).	このチュートリアルで示されているアプリケーションとスマートコントラクトがどのように機能するかを詳細に理解するには、[Developing Applications](../developapps/developing_applications.html)を参照してください。
This topic will give you a fuller explanation of the commercial paper scenario, the PaperNet business network, its actors, and how the applications and smart contracts they use work in detail.	このトピックでは、コマーシャルペーパーのシナリオ、 PaperNet のビジネスネットワーク、その関係者、およびアプリケーションとスマートコントラクトがどのように機能するかについて詳しく説明します。
Also feel free to use this sample to start creating your own applications and smart contracts!	また、このサンプルを使用して、独自のアプリケーションやスマートコントラクトの作成を開始することもできます!
**Audience**: Architects, application and smart contract developers	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者
A transaction context performs two functions.	トランザクションコンテキストは、二つの機能を実現します。
Firstly, it allows a developer to define and maintain user variables across transaction invocations within a smart contract.	一つは、開発者がスマートコントラクトでのトランザクションの実行で使えるユーザー変数を定義し管理できるようにするものです。
Secondly, it provides access to a wide range of Fabric APIs that allow smart contract developers to perform operations relating to detailed transaction processing.	もう一つは、スマートコントラクト開発者がより詳細なトランザクション処理に関する操作を行える、幅広いFabric APIに対するアクセスを提供するものです。
These range from querying or updating the ledger, both the immutable blockchain and the modifiable world state, to retrieving the transaction-submitting application's digital identity.	この操作には、台帳、すなわちイミュータブルなブロックチェーンと変更可能なワールドステートの両方のクエリや更新から、トランザクションを送信したアプリケーションのデジタルアイデンティティの取得まで含みます。
A transaction context is created when a smart contract is deployed to a channel and made available to every subsequent transaction invocation.	トランザクションコンテキストは、スマートコントラクトがチャネルにデプロイされ、それ以降のトランザクション呼び出しで利用可能になったときに作成されます。
A transaction context helps smart contract developers write programs that are powerful, efficient and easy to reason about.	トランザクションコンテキストによって、スマートコントラクト開発者は、より強力で効率的で処理がわかりやすいプログラムを作成しやすくなります。
[Why a transaction context is important](#scenario)	[トランザクションコンテキストはなぜ重要なのか](#scenario)
[How to use a transaction context](#programming)	[トランザクションコンテキストの使い方](#programming)
[What's in a transaction context](#structure)	[トランザクションコンテキストには何が含まれているか](#structure)
[Using a context `stub`](#stub)	[コンテキストの`stub`の利用](#stub)
[Using a context `clientIdentity`](#clientIdentity) In the commercial paper sample, [papercontract](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js) initially defines the name of the list of commercial papers for which it's responsible.	[コンテキストの`clientIdentity`の利用](#clientIdentity)コマーシャルペーパーのサンプルでは、[papercontract](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/commercial-paper/organization/magnetocorp/contract/lib/papercontract.js)は、最初に対象のコマーシャルペーパーのリストの名前を定義しています。
Each transaction subsequently refers to this list; the issue transaction adds new papers to it, the buy transaction changes its owner, and the redeem transaction marks it as complete.	以降の各トランザクションはこのリストを参照し、発行トランザクションは新しいコマーシャルペーパーをそれに追加し、購入トランザクションは所有者を変更し、現金化トランザクションは完了したとマークします。
This is a common pattern; when writing a smart contract it's often helpful to initialize and recall particular variables in sequential transactions.	これは共通で使えるパターンで、スマートコントラクトを書く際には、ある変数を初期化し、続くトランザクションでそれを呼び出すことが有用なことが多いです。
A smart contract transaction context allows smart contracts to define and maintain user variables across transaction invocations.	スマートコントラクトのトランザクションコンテキストによって、スマートコントラクトはトランザクション実行で使われるユーザー変数を定義し管理することができます。
Refer to the text for a detailed explanation.	詳細な説明は本文を参照してください。
When a smart contract is constructed, a developer can optionally override the built-in `Context` class `createContext` method to create a custom context:	開発者は、スマートコントラクトが作成される際、カスタムコンテキストを作成するために、組み込みの`Context`クラスと`createContext`メソッドを下記のようにオーバーライドすることができます。
In our example, the `CommercialPaperContext` is specialized for `CommercialPaperContract`.	ここでの例では、`CommercialPaperContext`は、`CommercialPaperContract`のために特化したものです。
See how the custom context, addressed through `this`, adds the specific variable `PaperList` to itself:	下記のように、`this`で参照されているカスタムコンテキストに、特有の変数である`PaperList`を追加しています。
When the createContext() method returns at point (1) in the diagram [above](#scenario), a custom context `ctx` has been created which contains `paperList` as one of its variables.	[上の](#scenario)図の(1)で、createContext()メソッドから返ったときには、カスタムコンテキスト`ctx`は作られており、その変数の一つとして`paperList`を含んでいます。
Subsequently, whenever a smart contract transaction such as issue, buy or redeem is called, this context will be passed to it.	その後、発行、購入、現金化のようなスマートトランザクションが呼ばれるときには常に、このコンテキストが渡されます。
See how at points (2), (3) and (4) the same commercial paper context is passed into the transaction method using the `ctx` variable.	(2)、(3)、(4)で、同じコマーシャルペーパーのコンテキストが`ctx`変数によって、トランザクションメソッドに渡されているのがわかります。
See how the context is then used at point (5):	そして、次のように(5)でコンテキストが使われていることがわかります。
Notice how `paperList` created in `CommercialPaperContext` is available to the issue transaction.	`CommercialPaperContext`に作られた`paperList`が、発行トランザクションで利用可能なことに注目してください。
See how `paperList` is similarly used by the redeem and buy transactions;	現金化や購入トランザクションでも同じように`paperList`が使われているのがわかります。
`ctx` makes the smart contracts efficient and easy to reason about.	`ctx`によって、スマートコントラクトが効率的で処理がわかりやすくなっています。
You can also see that there's another element in the context -- `ctx.stub` -- which was not explicitly added by `CommercialPaperContext`.	また、`CommercialPaperContext`で明示的に追加されていない、コンテキストの別の要素である`ctx.stub`があることもわかります。
That's because `stub` and other variables are part of the built-in context.	これは、`stub`やその他の変数は、組み込みのコンテキストの一部であるからです。
Let's now examine the structure of this built-in context, these implicit variables and how to use them.	それでは、この組み込みのコンテキストの構造と、これらの暗黙的な変数、そしてその使い方を見ていきましょう。
As we've seen from the [example](#programming), a transaction context can contain any number of user variables such as `paperList`.	[この例](#programming)で見たように、トランザクションコンテキストは、`paperList`のような任意の数のユーザー変数をもつことができます。
The transaction context also contains two built-in elements that provide access to a wide range of Fabric functionality ranging from the client application that submitted the transaction to ledger access.	トランザクションコンテキストは、二つの組み込みの要素を持っており、これらはトランザクションを送信したアプリケーションから台帳へのアクセスに至るまで幅広いFabricの機能へのアクセスを提供します。
`ctx.stub` is used to access APIs that provide a broad range of transaction processing operations from `putState()` and `getState()` to access the ledger, to `getTxID()` to retrieve the current transaction ID.	`ctx.stub`は、台帳に対するアクセスを行う`putState()`と`getState()`から、現在のトランザクションのIDを取得する`getTxID()`に至るまで、幅広いトランザクションの処理操作を提供するAPIへのアクセスに使われます。
`ctx.clientIdentity` is used to get information about the identity of the user who submitted the transaction.	`ctx.clientIdentity`は、トランザクションを送信したユーザーのアイデンティティに関する情報を取得するのに使われます。
We'll use the following diagram to show you what a smart contract can do using the `stub` and `clientIdentity` using the APIs available to it:	以降では、スマートコントラクトが`stub`と`clientIdentity`を使って、そのAPIによってなにができるかを下記の図を使って示します。
A smart contract can access a range of functionality in a smart contract via the transaction context `stub` and `clientIdentity`.	スマートコントラクトは、トランザクションコンテキストの`stub`と`clientIdentity`を用いて様々なスマートコントラクトの機能にアクセスすることができます。
Refer to the text for a detailed explanation.	詳細は本文を参照してください。
The APIs in the stub fall into the following categories:	stubのAPIは、次のように分類されます。
World state data APIs.	ワールドステートデータAPI
See interaction point (1).	(1)を参照してください。
These APIs enable smart contracts to get, put and delete state corresponding to individual objects from the world state, using their key:	スマートコントラクトは、次のAPIによって、キーを用いてワールドステートから個々のオブジェクトに対応するステートを取得、書き込み、削除することができます。
These basic APIs are complemented by query APIs which enable contracts to retrieve a set of states, rather than an individual state.	これらの基本的なAPIに加えて、一つのステートでなく、ステートの集合をコントラクトが取得することができるクエリAPIがあります。
See interaction point (2).	(2)を参照してください。
The set is either defined by a range of key values, using full or partial keys, or a query according to values in the underlying world state [database](../ledger/ledger.html#world-state-database-options).	集合は、キーの全体あるいは一部によるキーバリューの範囲として、あるいは、ワールドステート[データベース](../ledger/ledger.html#world-state-database-options)の値に応じたクエリとして定義されます。
For large queries, the result sets can be paginated to reduce storage requirements:	クエリ結果が大きい場合、必要なストレージを削減するためにページネーションすることができます。
Private data APIs.	プライベートデータAPI.
See interaction point (3).	(3)を参照してください。
These APIs enable smart contracts to interact with a private data collection.	スマートコントラクトは、これらのAPIによってプライベートデータコレクションとやりとりすることができます。
They are analogous to the APIs for world state interactions, but for private data.	ワールドステートとやりとりするAPIと類似していて、これらはプライベートデータに対するAPIです。
There are APIs to get, put and delete a private data state by its key:	以下のAPIで、キーによってプライベートデータを取得、書き込み、削除することができます。
This set is complemented by set of APIs to query private data (4).	このAPIに加えて、プライベートデータをクエリするAPI((4))があります。
These APIs allow smart contracts to retrieve a set of states from a private data collection, according to a range of key values, either full or partial keys, or a query according to values in the underlying world state [database](../ledger/ledger.html#world-state-database-options).	これらのAPIによって、スマートコントラクトは、キーの全部または一部によるキーバリューの範囲、あるいは、ワールドステート[データベース](../ledger/ledger.html#world-state-database-options)の値に対するクエリに従って、プライベートデータコレクションからからステートの集合をクエリすることができます。
There are currently no pagination APIs for private data collections.	現在のところ、プライベートデータコレクションに対するページネーションに対応したAPIはありません。
Transaction APIs.	トランザクションAPI.
See interaction point (5).	(5)を参照してください。
These APIs are used by a smart contract to retrieve details about the current transaction proposal being processed by the smart contract.	これらのAPIは、スマートコントラクトが、現在処理しているトランザクション提案に関する詳細を取得するのに使われます。
This includes the transaction identifier and the time when the transaction proposal was created.	これには、トランザクションの識別子及びトランザクション提案が作られたときの時刻を含みます。
[getTxID()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getTxID__anchor) returns the identifier of the current transaction proposal (5).	[getTxID()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getTxID__anchor)は、現在のトランザクション提案の識別子(5)を返します。
[getTxTimestamp()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getTxTimestamp__anchor) returns the timestamp when the current transaction proposal was created by the application (5).	[getTxTimestamp()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getTxTimestamp__anchor)は、現在のトランザクション提案がアプリケーションで作らされた際のタイムスタンプ(5)を返します。
[getCreator()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getCreator__anchor) returns the raw identity (X.509 or otherwise) of the creator of transaction proposal.	[getCreator()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getCreator__anchor)は、トランザクション提案の作成者の生のアイデンティティ(X.509あるいはその他)を返します。
If this is an X.509 certificate then it is often more appropriate to use [`ctx.ClientIdentity`](#clientidentity).	X.509証明書の場合は、[`ctx.clientIdentity`](#clientidentity)を使うほうが多くの場合適切です。
[getSignedProposal()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getSignedProposal__anchor) returns a signed copy of the current transaction proposal being processed by the smart contract.	[getSignedProposal()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getSignedProposal__anchor)は、スマートコントラクトによって現在処理されているトランザクション提案の署名付きコピーを返します。
[getBinding()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getBinding__anchor) is used to prevent transactions being maliciously or accidentally replayed using a nonce.	[getBinding()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getBinding__anchor)は、ノンスを用いて、故意あるいは間違いによってトランザクションがリプレイされるのを防ぐのに使われます。
For practical purposes, a nonce is a random number generated by the client application and incorporated in a cryptographic hash.	実用的には、ノンスはクライアントアプリケーションによって生成された乱数で、暗号的ハッシュに含まれます
For example, this API could be used by a smart contract at (1) to detect a replay of the transaction (5).	例えば、このAPIはスマートコントラクト(1)が、トランザクション(5)のリプレイを検出するために使うことができるでしょう。
[getTransient()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getTransient__anchor) allows a smart contract to access the transient data an application passes to a smart contract.	[getTransient()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ChaincodeStub.html#getTransient__anchor)によって、スマートコントラクトは、アプリケーションが渡す一時的データにアクセスすることができます。
See interaction points (9) and (10).	(9)と(10)を参照してください。
Transient data is private to the application-smart contract interaction.	一時的データは、アプリケーションとスマートコントラクトのやりとりでのみアクセスできます。
It is not recorded on the ledger and is often used in conjunction with private data collections (3).	台帳には記録されず、プライベートデータコレクション(3)とともによく使われます。
Key APIs are used by smart contracts to manipulate state key in the world state or a private data collection.	キーAPIは、スマートコントラクトがワールドステートもしくはプライベートデータコレクションのステートのキーを操作するのに使われます。
See interaction points 2 and 4.	図中の(2)と(4)を参照してください。
The simplest of these APIs allows smart contracts to form and split composite keys from their individual components.	これらのAPIのうち、もっとも単純なものは、スマートコントラクトがコンポジットキーを作成あるいは分解するのに使われます。
Slightly more advanced are the `ValidationParameter()` APIs which get and set the state based endorsement policies for world state (2) and private data (4).	もう少し高度なものとして、`ValidationParameter()`API群があり、これは、ワールドステート(2)およびプライベートデータ(4)に関するステートベースのエンドースメントポリシーを取得および設定するものです。
Finally, `getHistoryForKey()` retrieves the history for a state by returning the set of stored values, including the transaction identifiers that performed the state update, allowing the transactions to be read from the blockchain (10).	最後に、`getHistoryForKey()`は、ステートの履歴を取得するもので、格納された値を返します。これには、そのステート更新を行ったトランザクションの識別子を含んでおり、これによってブロックチェーン(10)からそのトランザクションを取得することができます。
Event APIs are used to manage event processing in a smart contract.	イベントAPIは、スマートコントラクトでイベント処理を管理するのに使用されます。
Smart contracts use this API to add user events to a transaction response.	スマートコントラクトは、トランザクション応答にユーザーイベントを加えるのに、このAPIを使います。
See interaction point (5).	図の(5)を参照してください。
These events are ultimately recorded on the blockchain and sent to listening applications at interaction point (11).	イベントは、最終的にはブロックチェーンに記録され、listenしているアプリケーションに送信されます (11)。
Utility APIs are a collection of useful APIs that don't easily fit in a pre-defined category, so we've grouped them together!	ユーティリティAPIは、便利なAPIを集めたもので、上記には分類しにくいのでここに集めています。
They include retrieving the current channel name and passing control to a different chaincode on the same peer.	これには、現在のチャネル名を取得したり、同じピアの別のチェーンコードに処理を渡すものが含まれます。
See interaction point (13).	図の(13)を参照してください。
A smart contract running on any peer can use this API to determined on which channel the application invoked the smart contract.	どのピアでも、スマートコントラクトはこのAPIを用いて、アプリケーションがどのチャネルでスマートコントラクトを実行したかを判断することができます。
See interaction point (14).	図の(14)を参照してください。
Peer3 owned by MagnetoCorp has multiple smart contracts installed on it.	MagnetoCorpが所有するPeer3には、複数のスマートコントラクトがインストールされています。
These smart contracts are able to call each other using this API.	これらのスマートコントラクトは、このAPIを使って互いを呼び出すことができます。
The smart contracts must be collocated; it is not possible to call a smart contract on a different peer.	スマートコントラクトは同じ場所になくてはならず、異なるピア上のスマートコントラクトを呼び出すことはできません。
Some of these utility APIs are only used if you're using low-level chaincode, rather than smart contracts.	ユーティリティAPIのいくつかは、スマートコントラクトでなく、低レベルなチェーンコードを用いている場合にのみ使われます。
These APIs are primarily for the detailed manipulation of chaincode input; the smart contract `Contract` class does all of this parameter marshalling automatically for developers.	これらのAPIは、主にチェーンコードの入力値の詳細な操作のためのもので、スマートコントラクトの`Contract`クラスは、パラメータの変換を開発者のために自動的に行います。
In most cases, the application submitting a transaction will be using an X.509 certificate.	ほとんどの場合、トランザクションを送信するアプリケーションは、X.509証明書を使用するでしょう。
In the [example](#structure), an X.509 certificate (6) issued by `CA1` (7) is being used by `Isabella` (8) in her application to sign the proposal in transaction `t6` (5).	この[例](#structure)では、`CA1` (7)によって発行されたX.509証明書 (6) が、`Isabella` (8)がアプリケーションで、トランザクション`t6` (5)の提案に署名するのに使われています。
`ClientIdentity` takes the information returned by `getCreator()` and puts a set of X.509 utility APIs on top of it to make it easier to use for this common use case.	`ClientIdentity`は、`getCreator()`によって返される情報をもとに、この一般的なユースケースで簡単に使えるように、X.509のユーティリティAPI群を持っているものです。
[getX509Certificate()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getX509Certificate__anchor) returns the full X.509 certificate of the transaction submitter, including all its attributes and their values.	[getX509Certificate()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getX509Certificate__anchor)は、トランザクションの送信者の、全ての属性と値を含むX.509証明書全体を返します。
See interaction point (6).	(6)を参照してください。
[getAttributeValue()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getAttributeValue__anchor) returns the value of a particular X.509 attribute, for example, the organizational unit `OU`, or distinguished name `DN`.	[getAttributeValue()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getAttributeValue__anchor)は、例えば、組織単位(`OU`)や、識別名(`DN`)といったX.509の特定の属性の値を返します。
See interaction point (6).	(6)を参照してください。
[assertAttributeValue()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#assertAttributeValue__anchor) returns `TRUE` if the specified attribute of the X.509 attribute has a specified value.	[assertAttributeValue()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#assertAttributeValue__anchor)は、指定したX.509属性が指定した値を持っている場合に`TRUE`を返します。
See interaction point (6).	(6)を参照してください。
[getID()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getID__anchor) returns the unique identity of the transaction submitter, according to their distinguished name and the issuing CA's distinguished name.	[getID()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getID__anchor)は、その識別名と発行したCAの識別名に従って、トランザクション送信者のユニークな識別子を返します。
The format is `x509::{subject DN}::{issuer DN}`.	フォーマットは、`x509::{subject DN}::{issuer DN}`です。
See interaction point (6).	(6)を参照してください。
[getMSPID()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getMSPID__anchor) returns the channel MSP of the transaction submitter.	[getMSPID()](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-shim.ClientIdentity.html#getMSPID__anchor)は、トランザクション送信者のチャネルMSPを返します。
This allows a smart contract to make processing decisions based on the submitter's organizational identity.	これによって、スマートコントラクトは、送信者の組織のアイデンティティに基づいて処理判断をすることができます。
See interaction point (15) or (16).	図の(15)あるいは(16)を参照してください。
**Audience**: Architects, Application and smart contract developers	**対象読者**: アーキテクト、アプリケーションおよびスマートコントラクト開発者
Transaction handlers allow smart contract developers to define common processing at key points during the interaction between an application and a smart contract.	トランザクションハンドラによって、スマートコントラクト開発者は、アプリケーションとスマートコントラクトのやりとりの中の重要なポイントでの共通処理を定義することができます。
Transaction handlers are optional but, if defined, they will receive control before or after every transaction in a smart contract is invoked.	トランザクションハンドラは必須ではありませんが、定義された場合、スマートコントラクトで各トランザクションが実行される前あるいは後に制御を受け取ることができます。
There is also a specific handler which receives control when a request is made to invoke a transaction not defined in a smart contract.	スマートコントラクトで定義されていないトランザクションを実行しようとする要求があった場合に制御を受け取るハンドラもあります。
Here's an example of transaction handlers for the [commercial paper smart contract sample](./smartcontract.html):	[コマーシャルペーパースマートコントラクトのサンプル](./smartcontract.html)のトランザクションハンドラの例は、下記のとおりです。
Before, After and Unknown transaction handlers.	Before・After・Unknownトランザクションハンドラ。
In this example, `beforeTransaction()` is called before the issue, buy and redeem transactions.	この例では、`beforeTransaction()`は、発行、購入、現金化トランザクションの前に呼ばれます。
`afterTransaction()` is called after the issue, buy and redeem transactions.	`afterTransaction()`は、発行、購入、現金化トランザクションの後に呼ばれます。
`unknownTransaction()` is only called if a request is made to invoke a transaction not defined in the smart contract.	`unknownTransaction()`は、スマートコントラクトで定義されていないトランザクションを実行しようとする要求があった場合にのみ呼ばれます。
The diagram is simplified by not repeating `beforeTransaction` and `afterTransaction` boxes for each transaction.	図は、`beforeTransaction`と`afterTransaction`の箱を各トランザクションごとに繰り返し描かないで簡略化しています
There are three types of transaction handlers which cover different aspects of the interaction between an application and a smart contract:	下記のように、アプリケーションとスマートコントラクトの別々の側面に対応する3種類のトランザクションハンドラがあります。
Before handler: is called before every smart contract transaction is invoked.	Beforeハンドラ: 各スマートコントラクトトランザクションが実行される前に呼ばれます。
The handler will usually modify the transaction context to be used by the transaction.	このハンドラは、トランザクションで使われるトランザクションコンテキストを変更するために通常使われます。
The handler has access to the full range of Fabric APIs; for example, it can issue `getState()` and `putState()`.	ハンドラは、Fabric APIの全てにアクセスすることができ、例えば、`getState()`や`putState()`を実行できます。
After handler: is called after every smart contract transaction is invoked.	Afterハンドラ: 各スマートコントラクトトランザクションが実行された後に呼ばれます。
The handler will usually perform post-processing common to all transactions, and also has full access to the Fabric APIs.	このハンドラは、各トランザクションに共通な後処理を通常行い、これもFabric API全てにアクセスできます。
Unknown handler: is called if an attempt is made to invoke a transaction that is not defined in a smart contract.	Unknownハンドラ: スマートコントラクトに定義されていないトランザクションを実行しようとした場合に呼ばれます。
Typically, the handler will record the failure for subsequent processing by an administrator.	多くの場合、ハンドラは、後で管理者による処理のためにエラーを記録します。
The handler has full access to the Fabric APIs.	このハンドラは、Fabric API全てにアクセスできます。
Defining a transaction handler is optional; a smart contract will perform correctly without handlers being defined.	トランザクションハンドラの定義は、必須ではありません。ハンドラが定義されていない場合でも、スマートコントラクトは正しく動作します。
A smart contract can define at most one handler of each type.	スマートコントラクトは、ハンドラの種類ごとにそれぞれ一つまで定義することができます。
Transaction handlers are added to the smart contract as methods with well defined names.	トランザクションハンドラは、決められた名前のメソッドとして、スマートコントラクトに追加されます。
Here's an example which adds a handler of each type:	下記が、各種類のハンドラを追加する例です。
Write the transaction ID as an informational to the console	トランザクションIDをコンソールに情報として出力します
This handler interacts with the ledger	このハンドラは台帳とやりとりを行います
This handler throws an exception	このハンドラは例外を投げます
The form of a transaction handler definition is the similar for all handler types, but notice how the `afterTransaction(ctx, result)` also receives any result returned by the transaction.	トランザクションハンドラ定義の形式は全てのハンドラの種類で似ていますが、`afterTransaction(ctx, result)`は、トランザクションによって返された結果も受け取ることに注意してください。
The [API documentation](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-contract-api.Contract.html) shows you the exact form of these handlers.	[APIドキュメント](https://hyperledger.github.io/fabric-chaincode-node/{BRANCH}/api/fabric-contract-api.Contract.html)には、これらのハンドラの正確な形式の説明があります。
Once a handler has been added to the smart contract, it will be invoked during transaction processing.	ハンドラがスマートコントラクトに追加されると、ハンドラはトランザクション処理の間に実行されます。
During processing, the handler receives `ctx`, the [transaction context](./transationcontext.md), performs some processing, and returns control as it completes.	処理においては、ハンドラは[トランザクションコンテキスト](./transationcontext.html)である`ctx`を受け取り、何らかの処理を行い、完了時に制御を返します。
Processing continues as follows:	処理は、下記のように続きます。
Before handler: If the handler completes successfully, the transaction is called with the updated context.	Beforeハンドラ: ハンドラが正常に終了した場合、トランザクションが更新されたコンテキストで呼ばれます。
If the handler throws an exception, then the transaction is not called and the smart contract fails with the exception error message.	ハンドラが例外を投げた場合、トランザクションは呼ばれず、スマートコントラクトはその例外のエラーメッセージで失敗します。
After handler: If the handler completes successfully, then the smart contract completes as determined by the invoked transaction.	Afterハンドラ: ハンドラが正常に終了した場合、スマートコントラクトは、実行されたトランザクションの通りに終了します。
If the handler throws an exception, then the transaction fails with the exception error message.	ハンドラが例外を投げた場合、トランザクションはその例外のエラーメッセージで失敗します。
Unknown handler: The handler should complete by throwing an exception with the required error message.	Unknownハンドラ: ハンドラは、必要なエラーメッセージを含む例外を投げて終了するべきです。
If an Unknown handler is not specified, or an exception is not thrown by it, there is sensible default processing; the smart contract will fail with an unknown transaction error message.	Unknownハンドラが指定されなかった場合、あるいは、ハンドラが例外を投げなかった場合には、ちゃんとしたデフォルトの処理があり、スマートコントラクトは、unknown transactionのエラーメッセージで失敗します。
If the handler requires access to the function and parameters, then it is easy to do this: Retrieve details of the transaction	もし、ハンドラが関数及び引数にアクセスする必要がある場合、下記のように簡単に行うことができます。
See how this handler uses the utility API `getFunctionAndParameters` via the [transaction context](./transactioncontext.html#stub).	トランザクションの詳細を取得しますこのハンドラが、[トランザクションコンテキスト](./transactioncontext.html#stub)を通じて、ユーティリティAPIである`getFunctionAndParameters`を呼んでいるのがわかるでしょう。
It is only possible to define at most one handler of each type for a smart contract.	スマートコントラクトに対して、各種類のハンドラについて、最大一つまでしか定義することができません。
If a smart contract needs to invoke multiple functions during before, after or unknown handling, it should coordinate this from within the appropriate function.	もし、スマートコントラクトが、before・after・unknown処理で複数の関数を呼ぶ必要がある場合は、適切なハンドラ関数がそれを管理しなければなりません。
The following instructions assume that you have already set up your :doc:`development environment <devenv>`.	以下の手順は、 :doc:`開発環境 <devenv>` がすでにセットアップされていることを前提としています。
To build Hyperledger Fabric:	Hyperledger Fabric をビルドするには以下を実行します:
If you are contributing to the documentation, you can build the Fabric documentation on your local machine.	もしあなたがドキュメントに貢献している場合は、ローカルマシン上で Fabric ドキュメントをビルドできます。
This allows you to check the formatting of your changes using your web browser before you open a pull request.	これにより、プルリクエストを開く前に、Web ブラウザを使用してあなたの変更のフォーマットを確認できます。
You need to download the following prerequisites before you can build the documentation:	ドキュメントをビルドする前に、次の前提条件をダウンロードする必要があります:
After you make your updates to the documentation source files, you can generate a build that includes your changes by running the following commands:	ドキュメントソースファイルを更新した後、次のコマンドを実行して、あなたの変更を含むビルドを生成できます:
This will generate all the html files in the ``docs/build/html`` folder.	これにより、 ``docs/build/html`` フォルダにすべてのhtmlファイルが生成されます。
You can open any file to start browsing the updated documentation using your browser.	あなたは、任意のファイルを開いて、ブラウザを使用して更新されたドキュメントの閲覧を開始できます。
If you want to make additional edits to the documentation, you can rerun ``make html`` to incorporate the changes.	ドキュメントにさらに追加の編集を加えたい場合は、 ``make html`` を再実行して変更を組み込むことができます。
Use the following command to run all unit tests:	次のコマンドを使用して、すべての単体テストを実行します:
To run a subset of tests, set the TEST_PKGS environment variable.	テストのサブセットを実行するには、 TEST_PKGS 環境変数を設定します。
Specify a list of packages (separated by space), for example:	パッケージのリスト（スペース区切り）を指定します。たとえば、以下の通りです:
To run a specific test use the ``-run RE`` flag where RE is a regular expression that matches the test case name.	特定のテストを実行するには、 ``-run RE`` フラグを使用します。RE は、テストケース名にマッチする正規表現です。
To run tests with verbose output use the ``-v`` flag.	詳細出力でテストを実行するには、 ``-v`` フラグを使用します。
For example, to run the ``TestGetFoo`` test case, change to the directory containing the ``foo_test.go`` and call/execute	たとえば、 ``TestGetFoo`` テストケースを実行するには、 ``foo_test.go`` を含むディレクトリに移動し、以下を呼び出し/実行します:
You must also run the Node.js unit tests to ensure that the Node.js client SDK is not broken by your changes.	また、Node.js 単体テストを実行して、 Node.js クライアント SDK があなたの変更によって壊れていないことを確認する必要があります。
To run the Node.js unit tests, follow the instructions `here <https://github.com/hyperledger/fabric-sdk-node/blob/master/README.md>`__.	Node.js 単体テストを実行するには、 `こちら <https://github.com/hyperledger/fabric-sdk-node/blob/master/README.md>`__ の手順に従ってください。
Configuration utilizes the `viper <https://github.com/spf13/viper>`__ and `cobra <https://github.com/spf13/cobra>`__ libraries.	設定では、 `viper ライブラリ <https://github.com/spf13/viper>`__と `cobra ライブラリ <https://github.com/spf13/cobra>`__ を利用します。
There is a core.yaml file that contains the configuration for the peer process.	ピアプロセスの設定を含むcore.yamlファイルがあります。
Many of the configuration settings can be overridden on the command line by setting ENV variables that match the configuration setting, but by prefixing with 'CORE\_'.	設定の多くは、設定名と一致する環境変数を設定することにより、コマンドライン上で上書きできますが、その際に接頭辞として'CORE\_'を付ける必要があります。
For example, setting `peer.networkId` can be accomplished with:	たとえば、 peer.networkId の設定は次のように行えます:
We code in Go™ and try to follow the best practices and style outlined in `Effective Go <https://golang.org/doc/effective_go.html>`__ and the supplemental rules from the `Go Code Review Comments wiki <https://github.com/golang/go/wiki/CodeReviewComments>`__.	我々は Go™ でコーディングし、 `Effective Go <https://golang.org/doc/effective_go.html>`__ で概説されているベストプラクティスとスタイルおよび `Go Code Review Comments wiki<https://github.com/golang/go/wiki/CodeReviewComments>`__ の補足ルールに従うように努めています。
We also recommend new contributors review the following before submitting pull requests:	また、プルリクエストを送信する前に、新しいコントリビュータが以下を確認することをおすすめします:
The following tools are executed against all pull requests.	次のツールは、すべてのプルリクエストに対して実行されます。
Any errors flagged by these tools must be addressed before the code will be merged:	これらのツールによってフラグが付けられたエラーは、コードをマージする前に対処する必要があります:
Unit tests are expected to accompany all production code changes.	単体テストは、すべての製品コードの変更に付随して行われることが期待されています。
These tests should be fast, provide very good coverage for new and modified code, and support parallel execution.	これらのテストは高速で、新規および変更されたコードに対して非常に優れたカバレッジを提供し、並列実行をサポートしなければなりません。
Two matching libraries are commonly used in our tests.	我々のテストでは、2つのマッチングライブラリ (訳者補足: テストの条件マッチライブラリ) が一般的に使用されます。
When modifying code, please use the matching library that has already been chosen for the package.	コードを変更するときは、パッケージ用にすでに選択されているマッチングライブラリを使用してください。
Any fixtures or data required by tests should generated or placed under version control.	テストに必要なフィクスチャまたはデータは、生成するか、バージョン管理下に置く必要があります。
When fixtures are generated, they must be placed in a temporary directory created by ``ioutil.TempDir`` and cleaned up when the test terminates.	フィクスチャが生成されるとき、それらは  ``ioutil.TempDir`` によって作成された一時ディレクトリに配置され、テストの終了時にクリーンアップされる必要があります。
When fixtures are placed under version control, they should be created inside a ``testdata`` folder; documentation that describes how to regenerate the fixtures should be provided in the tests or a ``README.txt``.	フィクスチャをバージョン管理下に置く場合は、 ``testdata`` フォルダ内に作成する必要があります。フィクスチャを再生成する方法を説明するドキュメントは、テストまたは ``README.txt`` で提供する必要があります。
Sharing fixtures across packages is strongly discouraged.	パッケージ間でフィクスチャを共有することは強くおすすめしません。
When fakes or mocks are needed, they must be generated.	フェイクやモックが必要な場合は、それらを生成する必要があります。
Bespoke, hand-coded mocks are a maintenance burden and tend to include simulations that inevitably diverge from reality.	ハードコードしたモックはメンテナンスの負担であり、必然的に現実から乖離したシミュレーションが含む傾向があります。
Within Fabric, we use ``go generate`` directives to manage the generation with the following tools:	Fabric 内では、 ``go generate`` ディレクティブを使用して、次のツールでその生成を管理します:
The API documentation for Hyperledger Fabric's Go APIs is available in `GoDoc <https://godoc.org/github.com/hyperledger/fabric>`_.	Hyperledger Fabric の Go API の API ドキュメントは、 `GoDoc <https://godoc.org/github.com/hyperledger/fabric>`_ で入手できます。
Hyperledger Fabric uses go modules to manage and vendor its dependencies.	Hyperledger Fabric は、 go モジュール (go modules) を使用して、依存関係を管理およびベンダー化します。
This means that all of the external packages required to build our binaries reside in the ``vendor`` folder at the top of the repository.	これは、バイナリのビルドに必要なすべての外部パッケージが、リポジトリのトップにある ``vendor`` フォルダにあることを意味します。
Go uses the packages in this folder instead of the module cache when ``go`` commands are executed.	Go は、 go コマンドの実行時に、モジュールキャッシュの代わりにこのフォルダ内のパッケージを使用します。
If a code change results in a new or updated dependency, please be sure to run ``go mod tidy`` and ``go mod vendor`` to keep the ``vendor`` folder and dependency metadata up to date.	コードを変更した結果、依存関係が新規または更新された場合は、必ず ``go mod tidy`` と ``go mod vendor`` を実行して、``vendor`` フォルダと依存関係のメタデータを最新の状態に保ってください。
See the `Go Modules Wiki <https://github.com/golang/go/wiki/Modules>`__ for additional information.	詳細については、 `Go Modules Wiki <https://github.com/golang/go/wiki/Modules>`__ を参照してください。
**Audience**: Architects, administrators, application and smart contract developers	**対象読者**: アーキテクト、管理者、アプリケーションおよびスマートコントラクト開発者
Connection options are used in conjunction with a connection profile to control precisely how a gateway interacts with a network.	コネクションオプションは、コネクションプロファイルと一緒に使われ、ゲートウェイがどのようにネットワークとやりとりするかを正確に制御するのに用います。
Using a gateway allows an application to focus on business logic rather than network topology.	ゲートウェイを使うことで、アプリケーションは、ネットワークのトポロジではなく、ビジネスロジックに集中することができます。
In this topic, we're going to cover:	このトピックでは次の項目について扱います。
[Why connection options are important](#scenario)	[なぜコネクションオプションが大切なのか](#scenario)
[How an application uses connection options](#usage)	[アプリケーションがコネクションオプションをどのように使うか](#usage)
[What each connection option does](#options)	[各コネクションオプションの意味](#options)
[When to use a particular connection option](#considerations)	[それぞれのコネクションオプションをいつ使うべきか](#considerations)
A connection option specifies a particular aspect of a gateway's behaviour.	コネクションオプションは、ゲートウェイの振る舞いのある一面を指定するものです。
Gateways are important for [many reasons](./gateway.html), the primary being to allow an application to focus on business logic and smart contracts, while it manages interactions with the many components of a network.	ゲートウェイは[様々な理由](./gateway.html)から重要ですが、その主な理由は、アプリケーションが、ネットワークの多くのコンポーネントとのやりとりを管理するなかで、ビジネスロジックやスマートコントラクトに集中できるようにしていることです。
The different interaction points where connection options control behaviour.	図中のそれぞれの点は、コネクションオプションが振る舞いを制御している部分です。
These options are explained fully in the text.	これらのオプションは、本文で全て説明されています。
One example of a connection option might be to specify that the gateway used by the `issue` application should use identity `Isabella` to submit transactions to the `papernet` network.	コネクションオプションの一つの例としては、`issue`アプリケーションで使われるゲートウェイが、`papernet`ネットワークにトランザクションを送信する際に`Isabella`のアイデンティティを使うよう指示するものがあるでしょう。
Another might be that a gateway should wait for all three nodes from MagnetoCorp to confirm a transaction has been committed returning control.	あるいは、ゲートウェイが制御を返すときに、MagnetoCorpの3つの全てのノードがトランザクションをコミットしたことを確認するまで待つというものもあるでしょう。
Connection options allow applications to specify the precise behaviour of a gateway's interaction with the network.	コネクションオプションによって、アプリケーションは、ゲートウェイがネットワークとやりとりする際の振る舞いを指定することができます。
Without a gateway, applications need to do a lot more work;	ゲートウェイがなければ、アプリケーションははるかに多くの処理をする必要があります。
gateways save you time, make your application more readable, and less error prone.	ゲートウェイによって、時間を節約できますし、アプリケーションを読みやすくそしてエラーを減らすことができます。
We'll describe the [full set](#options) of connection options available to an application in a moment; let's first see how they are specified by the sample MagnetoCorp `issue` application:	アプリケーションが利用可能なコネクションオプションの[全て](#options)は、この後すぐに説明しますが、まずはサンプルのMagnetoCorpの`issue`アプリケーションでどのように指定されているかを見てみましょう。
See how the `identity` and `wallet` options are simple properties of the `connectionOptions` object.	`identity`と`wallet`オプションが、`connectionOption`オブジェクトの単純なプロパティであることがわかるでしょう。
They have values `userName` and `wallet` respectively, which were set earlier in the code.	これらのプロパティはそれぞれ、コードのその前でセットされている`userName`と`wallet`の値をもちます。
Contrast these options with the `eventHandlerOptions` option which is an object in its own right.	それだけで一つのオブジェクトとなっている`eventHandlerOptions`オプションと対比してみてください。
It has two properties: `commitTimeout: 100` (measured in seconds) and `strategy: EventStrategies.MSPID_SCOPE_ANYFORTX`.	これは、`commitTimeOut: 100` (単位は秒)と`strategy: EventStrategies.MSPID_SCOPE_ANYFORTX`という二つのプロパティをもっています。
See how `connectionOptions` is passed to a gateway as a complement to `connectionProfile`;	`connectionOptions`がゲートウェイに対して、`connectionProfile`に加えて渡されているのがわかります。
the network is identified by the connection profile and the options specify precisely how the gateway should interact with it.	コネクションプロファイルでネットワークが識別され、オプションによってゲートウェイがそのネットワークとどのようにやりとりしなければならないかを正確に指定しています。
Let's now look at the available options.	それでは、利用可能なオプションを見ていきましょう。
Here's a list of the available options and what they do.	下記が、利用可能なオプションとその意味のリストです。
`wallet` identifies the wallet that will be used by the gateway on behalf of the application.	`wallet`は、アプリケーションの代わりにゲートウェイが使用するウォレットを識別するものです。
See interaction 1;	図中の1を参照してください。
the wallet is specified by the application, but it's actually the gateway that retrieves identities from it.	ここでは、ウォレットはアプリケーションによって指定されますが、実際にアイデンティティを取得するのはゲートウェイです。
A wallet must be specified;	ウォレットは必ず指定する必要があります。
the most important decision is the [type](./wallet.html#type) of wallet to use, whether that's file system, in-memory, HSM or database.	決めるべき最も重要な点は、ファイルシステムやインメモリやHSMやデータベースといった、使用するウォレットの[種類](./wallet.html#type)です。
`identity` is the user identity that the application will use from `wallet`.	`identity`は、`wallet`の中からアプリケーションが使うユーザーのアイデンティティです。
See interaction 2a;	図中の2aを参照してください。
the user identity is specified by the application and represents the user of the application, Isabella, 2b.	ユーザーのアイデンティティがアプリケーションによって指定され、それはアプリケーションのユーザーであるIsabella(2b)を代表するものです。
The identity is actually retrieved by the gateway.	アイデンティティは、実際にはゲートウェイが取得します。
In our example, Isabella's identity will be used by different MSPs (2c, 2d) to identify her as being from MagnetoCorp, and having a particular role within it.	この例では、Isabellaのアイデンティティは、異なるMSP(2cと2d)によって、彼女がMagnetoCorpの者であり、ある役割を持っていることを識別するのに使われます。
These two facts will correspondingly determine her permission over resources, such as being able to read and write the ledger, for example.	この二つの事実は、それに応じてリソースに対する彼女の権限、たとえば台帳を読んだり書いたりすることができるかどうかを決定します。
A user identity must be specified.	ユーザーのアイデンティティは必ず指定する必要があります。
As you can see, this identity is fundamental to the idea that Hyperledger Fabric is a permissioned network -- all actors have an identity, including applications, peers and orderers, which determines their control over resources.	このアイデンティティは、明らかにHyperledger Fabricが許可型のネットワークであるということの基礎となるものです。アプリケーション、ピア、Orderer含め、全てのアクターはアイデンティティを持ち、それによってリソースに対する制御を決定されます。
You can read more about this idea in the membership services [topic](../membership/membership.html).	この考え方について詳しくは、メンバーシップサービスの[トピック](../membership/membership.html)を参照してください。
`clientTlsIdentity` is the identity that is retrieved from a wallet (3a) and used for secure communications (3b) between the gateway and different channel components, such as peers and orderers.	`clientTlsIdentity`は、ウォレットから取得されるアイデンティ(3a)で、ゲートウェイと、ピアとordererといった様々なチャネルコンポーネントとのセキュア通信で使われます(3b)。
Note that this identity is different to the user identity.	このアイデンティティは、ユーザーのアイデンティティとは異なることに注意してください。
Even though `clientTlsIdentity` is important for secure communications, it is not as foundational as the user identity because its scope does not extend beyond secure network communications.	`clientTlsIdentity`はセキュア通信では重要ですが、ユーザーのアイデンティティのように基礎をなすものではありません。それは、そのスコープがセキュアなネットワーク通信に限られているからです。
`clientTlsIdentity` is optional.	`clientTlsIdentity`はオプショナルです。
You are advised to set it in production environments.	本番環境においてはセットすることをお勧めします。
You should always use a different `clientTlsIdentity` to `identity` because these identities have very different meanings and lifecycles.	`clientTlsIdentity`と`identity`には常に異なるものを使用するべきです。これは、これらのアイデンティティが全く異なる意味とライフサイクルをもつからです。
For example, if your `clientTlsIdentity` was compromised, then so would your `identity`;	例えば、もし`clientTlsIdentity`が漏洩した場合には、`identity`もしてしまうことになるでしょう。
it's more secure to keep them separate.	二つを別々にしておくことによってよりセキュアになります。
`eventHandlerOptions.commitTimeout` is optional.	`eventHandlerOptions.commitTimeout`はオプショナルです。
It specifies, in seconds, the maximum amount of time the gateway should wait for a transaction to be committed by any peer (4a) before returning control to the application.	これは、ゲートウェイがアプリケーションに処理を返す前に、トランザクションがいずれかのピア(4a)でコミットされるまで待つ最大時間を秒単位で指定します。
The set of peers to use for notification is determined by the `eventHandlerOptions.strategy` option.	通知のために使うピアのセットは、`eventHandlerOptions.strategy`オプションで決定されます。
If a commitTimeout is not specified, the gateway will use a timeout of 300 seconds.	もし、commitTimeoutが指定されない場合は、ゲートウェイは300秒のタイムアウトを使用します。
`eventHandlerOptions.strategy` is optional.	`eventHandlerOptions.strategy`はオプショナルです。
It identifies the set of peers that a gateway should use to listen for notification that a transaction has been committed.	これは、ゲートウェイが、トランザクションがコミットされた通知を受け取るのに使うピアのセットを識別します。
For example, whether to listen for a single peer, or all peers, from its organization.	たとえば、一つのピアから受け取るのか、その組織のすべてのピアから受け取るのか、などです。
It can take one of the following values:	以下のいずれかの値をとることができます。
`EventStrategies.MSPID_SCOPE_ANYFORTX`	`EventStrategies.MSPID_SCOPE_ANYFORTX`: 
Listen for any peer within the user's organization.	その組織のいずれかのピアから受け取ります。
In our example, see interaction points 4b;	この例では、4bを参照してください。
any of peer 1, peer 2 or peer 3 from MagnetoCorp can notify the gateway.	MagnetoCorpのPeer 1、Peer 2、Peer 3のどれでもゲートウェイに通知することができます。
`EventStrategies.MSPID_SCOPE_ALLFORTX` This is the default value.	`EventStrategies.MSPID_SCOPE_ALLFORTX`: これがデフォルトの値です。
Listen for all peers within the user's organization.	ユーザーの組織の全てのピアから受け取ります。
In our example peer, see interaction point 4b.	この例では、4bを参照してください。
All peers from MagnetoCorp must all have notified the gateway; peer 1, peer 2 and peer 3.	MagnetoCorpの全てのピア、すなわちPeer 1、Peer 2、Peer 3が全てゲートウェイに通知を行っていなければなりません。
Peers are only counted if they are known/discovered and available;	ピアは、知られている・ディスカバリで発見されている、かつ、利用可能なものだけが対象となります。
peers that are stopped or have failed are not included.	停止していたり、エラーとなったピアは含まれません。
`EventStrategies.NETWORK_SCOPE_ANYFORTX` Listen for any peer within the entire network channel.	`EventStrategies.NETWORK_SCOPE_ANYFORTX`: ネットワークチャネル全体のいずれかのピアから受け取ります。
In our example, see interaction points 4b and 4c;	この例では、4bと4cを参照してください。
any of peer 1-3 from MagnetoCorp or peer 7-9 of DigiBank can notify the gateway.	MagnetoCorpからのPeer 1-3または、DigiBankのPeer 7-9のどれでもゲートウェイに通知することができます。
`EventStrategies.NETWORK_SCOPE_ALLFORTX` Listen for all peers within the entire network channel.	`EventStrategies.NETWORK_SCOPE_ALLFORTX`: ネットワークチャネル全体の全てのピアから受け取ります。
In our example, see interaction points 4b and 4c.	この例では、4bと4cを参照してください。
All peers from MagnetoCorp and DigiBank must notify the gateway; peers 1-3 and peers 7-9.	MagnetoCorpとDigiBakの全てのピア、すなわちPeer1-3とPeer7-9がゲートウェイに通知しなければなりません。
Peers are only counted if they are known/discovered and available;	ピアは、知られている・ディスカバリで発見されている、かつ、利用可能なものだけが対象となります。
peers that are stopped or have failed are not included.	停止していたり、エラーとなったピアは含まれません。
<`PluginEventHandlerFunction`> The name of a user-defined event handler.	<`PluginEventHandlerFunction`>: ユーザー定義のイベントハンドラの名前です。
This allows a user to define their own logic for event handling.	これによって、ユーザーがイベント処理に自前のロジックを定義することができます。
See how to [define](https://hyperledger.github.io/fabric-sdk-node/{BRANCH}/tutorial-transaction-commit-events.html) a plugin event handler, and examine a [sample handler](https://github.com/hyperledger/fabric-sdk-node/blob/{BRANCH}/test/integration/network-e2e/sample-transaction-event-handler.js).	詳しくは、プラグインイベントハンドラの[定義](https://hyperledger.github.io/fabric-sdk-node/{BRANCH}/tutorial-transaction-commit-events.html)の方法や[サンプルハンドラ](https://github.com/hyperledger/fabric-sdk-node/blob/{BRANCH}/test/integration/network-e2e/sample-transaction-event-handler.js)を参照してください。
A user-defined event handler is only necessary if you have very specific event handling requirements;	ユーザー定義のイベントハンドラは、非常に独特なイベントハンドラの要件がある場合にのみ必要となります。
in general, one of the built-in event strategies will be sufficient.	一般的には、組み込みのイベントストラテジのいずれかで十分でしょう。
An example of a user-defined event handler might be to wait for more than half the peers in an organization to confirm a transaction has been committed.	ユーザー定義のイベントハンドラの例としては、トランザクションがコミットされたことの確認のために、ある組織の過半数のピアを待つといったものがあるでしょう。
If you do specify a user-defined event handler, it does not affect your application logic;	もし、ユーザー定義のイベントハンドラを指定しても、アプリケーションロジックには影響しません。
it is quite separate from it.	この二つは切り離されたものです。
The handler is called by the SDK during processing; it decides when to call it, and uses its results to select which peers to use for event notification.	ハンドラは処理の間にSDKによって呼ばれ、SDKはハンドラの結果によってどのピアをイベント通知に使うかを選びます。
The application receives control when the SDK has finished its processing.	アプリケーションは、SDKがその処理を終えてから処理を受け取ります。
If a user-defined event handler is not specified then the default values for `EventStrategies` are used.	もし、ユーザー定義のイベントハンドラが指定されなかった場合には、`EventStrategies`のデフォルト値が使われます。
`discovery.enabled` is optional and has possible values `true` or `false`.	`discovery.enabled`はオプショナルで、`true`か`false`のいずれかの値をとります。
The default is `true`.	デフォルトは、`true`です。
It determines whether the gateway uses [service discovery](../discovery-overview.html) to augment the network topology specified in the connection profile.	これによって、ゲートウェイが[サービスディスカバリ](../discovery-overview.html)を使用して、コネクションプロファイルで指定されたネットワークトポロジを補うかどうかを決めます。
See interaction point 6; peer's gossip information used by the gateway.	図中の6を参照してください。ピアからのゴシップ情報をゲートウェイが使っています。
This value will be overridden by the `INITIALIIZE-WITH-DISCOVERY` environment variable, which can be set to `true` or `false`.	この値は、`INITIALIZE-WITH-DISCOVERY`環境変数によって上書きされ、`true`か`false`を設定することができます。
`discovery.asLocalhost` is optional and has possible values `true` or `false`.	`discovery.asLocalhost`はオプショナルで、`true`か`false`のいずれかの値をとります。
The default is `true`.	デフォルトは、`true`です。
It determines whether IP addresses found during service discovery are translated from the docker network to the local host.	これによって、サービスディスカバリで得られたIPアドレスを、Dockerのネットワークからlocalhostに変換するかどうかを決定します。
Typically developers will write applications that use docker containers for their network components such as peers, orderers and CAs, but that do not run in docker containers themselves.	開発者は、ピア・orderer・CAといったネットワークコンポーネントとしてDockerコンテナを使うアプリケーションを書き、ただし、アプリケーション自身はコンテナで動かさないことが多いでしょう。
This is why `true` is the default;	これが、`true`がデフォルトである理由です。
in production environments, applications will likely run in docker containers in the same manner as network components and therefore address translation is not required.	本番環境においては、アプリケーションはネットワークコンポーネントと同様にDockerコンテナで動作することが多いため、アドレス変換は必要ありません。
In this case, applications should either explicitly specify `false` or use the environment variable override.	この場合、アプリケーションは、明示的に`false`を指定するか、環境変数による上書きを使用しなければなりません。
This value will be overridden by the `DISCOVERY-AS-LOCALHOST` environment variable, which can be set to `true` or `false`.	この値は、`DISCOVERY-AS-LOCALHOST`環境変数によって上書きされ、`true`か`false`を設定することができます。
The following list of considerations is helpful when deciding how to choose connection options.	コネクションオプションをどのように選ぶかを決める際には、以下の考慮すべき事項のリストが役に立つでしょう。
`eventHandlerOptions.commitTimeout` and `eventHandlerOptions.strategy` work together.	`eventHandlerOptions.commitTimeout`と`eventHandlerOptions.strategy`は、組み合わせで意味を持ちます。
For example, `commitTimeout: 100` and `strategy: EventStrategies.MSPID_SCOPE_ANYFORTX` means that the gateway will wait for up to 100 seconds for any peer to confirm a transaction has been committed.	たとえば、`commitTimeout: 100`と`strategy: EventStrategies.MSPID_SCOPE_ANYFORTX`は、ゲートウェイがいずれかのピアがトランザクションがコミットされたことを最大で100秒まで待つ、ということを意味します。
In contrast, specifying `strategy:  EventStrategies.NETWORK_SCOPE_ALLFORTX` means that the gateway will wait up to 100 seconds for all peers in all organizations.	対照的に、`strategy:  EventStrategies.NETWORK_SCOPE_ALLFORTX`は、ゲートウェイは全ての組織の全てのピアを100秒間まで待つということを意味します。
The default value of `eventHandlerOptions.strategy: EventStrategies.MSPID_SCOPE_ALLFORTX` will wait for all peers in the application's organization to commit the transaction.	デフォルトである`eventHandlerOptions.strategy: EventStrategies.MSPID_SCOPE_ALLFORTX`は、アプリケーションの組織の全てのピアがトランザクションをコミットするまで待ちます。
This is a good default because applications can be sure that all their peers have an up-to-date copy of the ledger, minimizing concurrency issues.	これは、アプリケーションが、自分の組織のピアがすべて最新の台帳のコピーを持つことを確認でき、同時実行による問題を最小化することができるので、良いデフォルト値です。
However, as the number of peers in an organization grows, it becomes a little unnecessary to wait for all peers, in which case using a pluggable event handler can provide a more efficient strategy.	しかし、組織内のピア数が増えていくと、全てのピアを待つことは多少不要になってきます。この場合、プラグ可能なイベントハンドラによって、より効率的なストラテジを提供することができます。
For example the same set of peers could be used to submit transactions and listen for notifications, on the safe assumption that consensus will keep all ledgers synchronized.	たとえば、合意形成によって全ての台帳が同期されるという想定に基づいて、トランザクションを送信するのと通知を受け取るのに、同じピアのセットを使うということができるでしょう。
Service discovery requires `clientTlsIdentity` to be set.	サービスディスカバリには、`clientTlsIdentity`が設定されている必要があります。
That's because the peers exchanging information with an application need to be confident that they are exchanging information with entities they trust.	これは、アプリケーションと情報を交換するピアが、情報を交換する相手が信頼している主体であると確信する必要があるためです。
If `clientTlsIdentity` is not set, then `discovery` will not be obeyed, regardless of whether or not it is set.	もし、`clientTlsIdentity`が設定されていなければ、`discovery`は、セットされているかに関わらず無視されるでしょう。
Although applications can set connection options when they connect to the gateway, it can be necessary for these options to be overridden by an administrator.	アプリケーションは、コネクションオプションをゲートウェイに接続する際に指定することができますが、管理者によってこれらのオプションを上書きすることが必要になることがあります。
That's because options relate to network interactions, which can vary over time.	これは、オプションが時間経過によって変化しうるネットワーク上でのやりとりにかかわるからです。
For example, an administrator trying to understand the effect of using service discovery on network performance.	例えば、管理者がサービスディスカバリによるネットワーク性能に対する影響を調べようとする場合です。
A good approach is to define application overrides in a configuration file which is read by the application when it configures its connection to the gateway.	よいアプローチとしては、アプリケーションがゲートウェイへの接続を設定するときに読む設定ファイルにアプリケーションごとの上書きを定義することです。
Because the discovery options `enabled` and `asLocalHost` are most frequently required to be overridden by administrators, the environment variables `INITIALIIZE-WITH-DISCOVERY` and `DISCOVERY-AS-LOCALHOST` are provided for convenience.	ディスカバリに関するオプションである`enabled`と`asLocalhost`は最も頻繁に管理者によって上書きすることが必要になるため、`INITIALIZE-WITH-DISCOVERY`と`DISCOVERY-AS-LOCALHOST`環境変数が簡単のために提供されています。
The administrator should set these in the production runtime environment of the application, which will most likely be a docker container.	管理者は、アプリケーションの本番ランタイム環境ではこれらを設定すべきです。これは、Dockerコンテナであることが最も多いでしょう。
This tutorial will demonstrate the use of collections to provide storage and retrieval of private data on the blockchain network for authorized peers of organizations.	このチュートリアルでは、コレクションを使用して、ブロックチェーンネットワーク上のプライベートデータを認可された組織のピア上に格納および取得する方法について説明します。
The information in this tutorial assumes knowledge of private data stores and their use cases.	このチュートリアルの情報は、プライベートデータストアとその使用例に関する知識を前提としています。
For more information, check out :doc:`private-data/private-data`.	詳細については、 :doc:`private-data/private-data` を参照してください。
These instructions use the new Fabric chaincode lifecycle introduced in the Fabric v2.0 release.	この手順では、Fabric v2.0リリースで導入された新しいFabricチェーンコードライフサイクルを使用します。
If you would like to use the previous lifecycle model to use private data with chaincode, visit the v1.4 version of the `Using Private Data in Fabric tutorial <https://hyperledger-fabric.readthedocs.io/en/release-1.4/private_data_tutorial.html>`__.	以前のライフサイクルモデルを使用したチェーンコードでプライベートデータを使用する場合は、v1.4バージョンのチュートリアル `Using Private Data in Fabric tutorial <https://hyperledger-fabric.readthedocs.io/en/release-1.4/private_data_tutorial.html>`__ を参照してください。
The tutorial will take you through the following steps to practice defining, configuring and using private data with Fabric:	このチュートリアルでは、次の手順に従って、Fabricでプライベートデータを定義、構成、使用する方法について学習します:
This tutorial will deploy the `marbles private data sample <https://github.com/hyperledger/fabric-samples/tree/{BRANCH}/chaincode/marbles02_private>`__ to the Fabric test network to demonstrate how to create, deploy, and use a collection of private data.	このチュートリアルでは、 `marbles private data sample <https://github.com/hyperledger/fabric-samples/tree/{BRANCH}/chaincode/marbles02_private>`__ をFabricテストネットワークに展開し、プライベートデータのコレクションを作成、展開、および使用する方法を示します。
You should have completed the task :doc:`install`.	タスク :doc:`install` が完了している必要があります。
The first step in privatizing data on a channel is to build a collection definition which defines access to the private data.	チャネル上のデータをプライベート化する最初のステップは、プライベートデータへのアクセスを定義するコレクション定義を構築することです。
The collection definition describes who can persist data, how many peers the data is distributed to, how many peers are required to disseminate the private data, and how long the private data is persisted in the private database.	コレクション定義には、データを保持できるユーザー、データが配布されるピアの数、プライベートデータの広めるのに必要なピアの数、プライベートデータがプライベートデータベースに保持される期間が記述されます。
Later, we will demonstrate how chaincode APIs ``PutPrivateData`` and ``GetPrivateData`` are used to map the collection to the private data being secured.	後で、チェーンコードAPI ``PutPrivateData`` および ``GetPrivateData`` を使用して、保護されるプライベートデータにコレクションをマップする方法について説明します。
A collection definition is composed of the following properties:	コレクション定義は、次のプロパティで構成されます:
``name``: Name of the collection.	``name`` : コレクションの名前。
``policy``: Defines the organization peers allowed to persist the collection data.	``policy`` : コレクションデータの保持を許可する組織ピアを定義します。
``requiredPeerCount``: Number of peers required to disseminate the private data as a condition of the endorsement of the chaincode	``requiredPeerCount`` : チェーンコードのエンドースメントの条件としてプライベートデータを広めるために必要なピア数
``maxPeerCount``: For data redundancy purposes, the number of other peers that the current endorsing peer will attempt to distribute the data to.	``maxPeerCount`` : データの冗長性のために、現在のエンドースピアがデータの配布を試行する他のピアの数。
If an endorsing peer goes down, these other peers are available at commit time if there are requests to pull the private data.	エンドースピアが停止した場合、プライベートデータのプル要求があると、コミット時にこれらの他のピアが使用可能になります。
``blockToLive``: For very sensitive information such as pricing or personal information, this value represents how long the data should live on the private database in terms of blocks.	``blockToLive`` : 価格設定や個人情報などの機密性の高い情報の場合、この値は、データがプライベートデータベースでブロック単位で存続する期間を表します。
The data will live for this specified number of blocks on the private database and after that it will get purged, making this data obsolete from the network.	データは、プライベートデータベースで指定したブロック数の間存続し、その後パージされて、このデータはネットワーク上からなくなります。
To keep private data indefinitely, that is, to never purge private data, set the ``blockToLive`` property to ``0``.	プライベートデータを無期限に保持する、つまりプライベートデータをパージしないようにするには、 ``blockToLive`` プロパティを ``0`` に設定します。
``memberOnlyRead``: a value of ``true`` indicates that peers automatically enforce that only clients belonging to one of the collection member organizations are allowed read access to private data.	``memberOnlyRead`` : 値が ``true`` の場合、ピアは、コレクションメンバー組織の1つに属するクライアントだけがプライベートデータへの読み取りアクセスを許可されるように自動的に強制します。
To illustrate usage of private data, the marbles private data example contains two private data collection definitions: ``collectionMarbles`` and ``collectionMarblePrivateDetails``.	プライベートデータの使用方法を説明するために、marblesプライベートデータの例には、 ``collectionMarbles`` と ``collectionMarblePrivateDetails`` という2つのプライベートデータコレクション定義が含まれています。
The ``policy`` property in the ``collectionMarbles`` definition allows all members of  the channel (Org1 and Org2) to have the private data in a private database.	``collectionMarbles`` 定義の ``policy`` プロパティでは、チャネルのすべてのメンバー(Org1およびOrg2)がプライベートデータベース内にプライベートデータを保持できます。
The ``collectionMarblesPrivateDetails`` collection allows only members of Org1 to have the private data in their private database.	``collectionMarblesPrivateDetails`` のコレクションでは、Org1のメンバーのみがプライベートデータベース内にプライベートデータを保持できます。
For more information on building a policy definition refer to the :doc:`endorsement-policies` topic.	ポリシー定義の作成の詳細については、 :doc:`endorsement-policies` トピックを参照してください。
The data to be secured by these policies is mapped in chaincode and will be shown later in the tutorial.	これらのポリシーによって保護されるデータは、チェーンコードでマップされ、チュートリアルの後半で参照します。
This collection definition file is deployed when the chaincode definition is committed to the channel using the `peer lifecycle chaincode commit command <commands/peerlifecycle.html#peer-lifecycle-chaincode-commit>`__.	このコレクション定義ファイルは、チェーンコード定義が `peer lifecycle chaincode commit command <commands/peerlifecycle.html#peer-lifecycle-chaincode-commit>`__ を使用してチャネルにコミットされるときに展開されます。
More details on this process are provided in Section 3 below.	このプロセスの詳細については、以下のセクション3で説明します。
The next step in understanding how to privatize data on a channel is to build the data definition in the chaincode.	チャネル上のデータをプライベート化する方法を理解するための次のステップは、チェーンコード内にデータ定義を構築することです。
The marbles private data sample divides the private data into two separate data definitions according to how the data will be accessed.	marblesプライベートデータサンプルは、データへのアクセス方法に従って、プライベートデータを2つの個別のデータ定義に分割します。
Specifically access to the private data will be restricted as follows:	特に、プライベートデータへのアクセスは以下のように制限されます:
``name, color, size, and owner`` will be visible to all members of the channel (Org1 and Org2)	``名前、色、サイズ、および所有者`` は、チャネルのすべてのメンバー(Org1およびOrg2)に表示されます
``price`` only visible to members of Org1	``価格`` はOrg1のメンバーにのみ表示される
Thus two different sets of private data are defined in the marbles private data sample.	したがって、2つの異なるプライベートデータセットがmarbleプライベートデータサンプルに定義されます。
The mapping of this data to the collection policy which restricts its access is controlled by chaincode APIs.	このデータのアクセスを制限するコレクションポリシーへのマッピングは、チェーンコードAPIによって制御されます。
Specifically, reading and writing private data using a collection definition is performed by calling ``GetPrivateData()`` and ``PutPrivateData()``, which can be found `here <https://godoc.org/github.com/hyperledger/fabric-chaincode-go/shim#ChaincodeStub>`_.	特に、コレクション定義を使用したプライベートデータの読取りおよび書込みは、 ``GetPrivateData()`` および ``PutPrivateData()`` をコールすることによって実行されます。このメソッドは、`ここ <https://godoc.org/github.com/hyperledger/fabric-chaincode-go/shim#ChaincodeStub>`_ にあります。
The following diagram illustrates the private data model used by the marbles private data sample.	次の図は、marbleプライベートデータサンプルで使用されるプライベートデータモデルを示しています。
Use the chaincode API ``GetPrivateData()`` to query private data in the database.	データベース内のプライベートデータを問い合せるには、chaincode API ``GetPrivateData()`` を使用します。
``GetPrivateData()`` takes two arguments, the collection name and the data key.	``GetPrivateData()`` は、コレクション名とデータキーの2つの引数を取ります。
Recall the collection  ``collectionMarbles`` allows members of Org1 and Org2 to have the private data in a side database, and the collection ``collectionMarblePrivateDetails`` allows only members of Org1 to have the private data in a side database.	コレクション ``collectionMarble`` sでは、Org1とOrg2のメンバーがサイドデータベース内にプライベートデータを持つことができ、コレクション ``collectionMarblePrivateDetails`` では、Org1のメンバーのみがサイドデータベース内にプライベートデータを持つことができます。
For implementation details refer to the following two `marbles private data functions <https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/marbles02_private/go/marbles_chaincode_private.go>`__:	実装の詳細は、次の2つの `marbles private data functions <https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/marbles02_private/go/marbles_chaincode_private.go>`__ を参照してください:
readMarble for querying the values of the ``name, color, size and owner`` attributes	``名前、色、サイズ、所有者`` 属性の値を問い合わせるreadMarble
readMarblePrivateDetails for querying the values of the ``price`` attribute	``価格`` 属性の値を問い合わせるreadMarblePrivateDetails
When we issue the database queries using the peer commands later in this tutorial, we will call these two functions.	このチュートリアルの後半でpeerコマンドを使用してデータベースクエリーを発行する際、これらの2つの関数を呼び出します。
Use the chaincode API ``PutPrivateData()`` to store the private data into the private database.	プライベートデータをプライベートデータベースに格納するには、chaincode API ``PutPrivateData()`` を使用します。
The API also requires the name of the collection.	APIにはコレクションの名前も必要です。
Since the marbles private data sample includes two different collections, it is called twice in the chaincode:	marbleプライベートデータサンプルには2つの異なるコレクションが含まれているため、chaincodeでは2回呼び出されます:
1. Write the private data ``name, color, size and owner`` using the  collection named ``collectionMarbles``.	1. ``collectionMarbles`` というコレクションを使って、プライベートデータの ``名前、色、サイズ、所有者`` を書き込む。
2. Write the private data ``price`` using the collection named  ``collectionMarblePrivateDetails``.	2. ``collectionMarblePrivateDetails`` というコレクションを使って、プライベートデータの ``価格`` を書き込む。
For example, in the following snippet of the ``initMarble`` function, ``PutPrivateData()`` is called twice, once for each set of private data.	たとえば、次の ``initMarble`` 関数のスニペットでは、 ``PutPrivateData()`` がプライベートデータのセットごとに1回ずつ、2回呼び出されます。
To summarize, the policy definition above for our ``collection.json`` allows all peers in Org1 and Org2 to store and transact with the marbles private data ``name, color, size, owner`` in their private database.	以上をまとめると、 ``collection.json`` のポリシー定義では、Org1とOrg2のすべてのピアが、それぞれのプライベートデータベースにマーブルプライベートデータの ``名前、色、サイズ、所有者`` を格納して取引ができます。
But only peers in Org1 can store and transact with the ``price`` private data in its private database.	しかし、Org1のピアのみが、プライベートデータベースに ``価格`` プライベートデータを格納して取引できます。
As an additional data privacy benefit, since a collection is being used, only the private data hashes go through orderer, not the private data itself, keeping private data confidential from orderer.	追加のデータプライバシーの利点として、コレクションが使用されるので、プライベートデータハッシュのみがordererを通過し、プライベートデータ自体は通過せず、ordererからプライベートデータを秘密に保てます。
Now we are ready to step through some commands which demonstrate how to use private data.	これで、プライベートデータの使用方法を示すいくつかのコマンドについて説明する準備が整いました。
Before installing, defining, and using the marbles private data chaincode below, we need to start the Fabric test network.	以下のmarblesプライベートデータチェーンコードをインストール、定義、使用する前に、Fabricテストネットワークを起動する必要があります。
For the sake of this tutorial, we want to operate from a known initial state.	このチュートリアルでは、既知の初期状態から操作します。
The following command will kill any active or stale Docker containers and remove previously generated artifacts.	次のコマンドは、アクティブまたは古いDockerコンテナを削除し、以前に生成されたアーティファクトを削除します。
Therefore let's run the following command to clean up any previous environments:	したがって、次のコマンドを実行して、以前の環境をクリーンアップします:
If you have not run through the tutorial before, you will need to vendor the chaincode dependencies before we can deploy it to the network.	チュートリアルをまだ実行していない場合は、ネットワークに展開する前に、チェーンコードの依存関係をベンダーに提供する必要があります。
Run the following commands:	次のコマンドを実行します:
If you've already run through this tutorial, you'll also want to delete the underlying Docker containers for the marbles private data chaincode.	このチュートリアルをすでに実行している場合は、marblesのプライベートデータチェーンコードの基礎となるDockerコンテナも削除します。
Let's run the following commands to clean up previous environments:	次のコマンドを実行して、以前の環境をクリーンアップします:
From the ``test-network`` directory, you can use the following command to start up the Fabric test network with CouchDB:	``test-network`` ディレクトリから、次のコマンドを使用してcouchDBを使用するFabricテストネットワークを起動できます:
This command will deploy a Fabric network consisting of a single channel named ``mychannel`` with two organizations (each maintaining one peer node) and an ordering service while using CouchDB as the state database.	このコマンドは、CouchDBを状態データベースとして使用しながら、 ``mychannel`` という名前の単一チャネルと2つの組織(それぞれが1つのピアノードを持つ)と1つのorderingサービスで構成されるFabricネットワークをデプロイします。
Either LevelDB or CouchDB may be used with collections.	コレクションではLevelDBまたはCouchDBを使用できます。
CouchDB was chosen to demonstrate how to use indexes with private data.	CouchDBは、プライベートデータでインデックスを使用する方法を示すために選択しています。
For collections to work, it is important to have cross organizational  gossip configured correctly.	コレクションを機能させるためには、組織間のゴシップを正しく設定することが重要です。
Refer to our documentation on :doc:`gossip`,  paying particular attention to the section on "anchor peers".	:doc:`gossip` に関するドキュメントを参照し、特に「アンカーピア」のセクションに注意してください。
Our tutorial  does not focus on gossip given it is already configured in the test network,  but when configuring a channel, the gossip anchors peers are critical to  configure for collections to work properly...	このチュートリアルではゴシップについては説明せず、ゴシップはテストネットワークですでに設定されているものとしますが、チャネルを設定する場合、ゴシップアンカーピアはコレクションが正しく機能するように設定するために重要です。
Client applications interact with the blockchain ledger through chaincode.	クライアントアプリケーションは、チェーンコードを介してブロックチェーン元帳と対話します。
Therefore we need to install a chaincode on every peer that will execute and endorse our transactions.	したがって、トランザクションを実行して承認するすべてのピアにチェーンコードをインストールする必要があります。
However, before we can interact with our chaincode, the members of the channel need to agree on a chaincode definition that establishes chaincode governance, including the private data collection configuration.	ただし、チェーンコードと対話する前に、チャネルのメンバーは、プライベートデータコレクション構成を含むチェーンコードガバナンスを確立するチェーンコード定義に同意する必要があります。
We are going to package, install, and then define the chaincode on the channel using :doc:`commands/peerlifecycle`.	:doc:`commands/peerlifecycle` を使用して、チャネルのチェーンコードをパッケージ化してインストールし、定義しいきます。
The chaincode needs to be packaged before it can be installed on our peers.	チェーンコードは、ピアにインストールする前にパッケージ化する必要があります。
We can use the `peer lifecycle chaincode package <commands/peerlifecycle.html#peer-lifecycle-chaincode-package>`__ command to package the marbles chaincode.	`peer lifecycle chaincode package <commands/peerlifecycle.html#peer-lifecycle-chaincode-package>`__ コマンドを使用してmarblesチェーンコードをパッケージ化できます。
The test network includes two organizations, Org1 and Org2, with one peer each.	テストネットワークにはOrg1とOrg2の2つの組織が含まれ、それぞれに1つのピアがあります。
Therefore, the chaincode package has to be installed on two peers:	したがって、chaincodeパッケージは2つのピアにインストールする必要があります:
After the chaincode is packaged, we can use the `peer lifecycle chaincode install <commands/peerlifecycle.html#peer-lifecycle-chaincode-install>`__ command to install the Marbles chaincode on each peer.	チェーンコードがパッケージ化されたら、 `peer lifecycle chaincode install <commands/peerlifecycle.html#peer-lifecycle-chaincode-install>`__ コマンドを使用して、各ピアにMarblesチェーンコードをインストールできます。
Assuming you have started the test network, copy and paste the following environment variables in your CLI to interact with the network and operate as the Org1 admin.	テストネットワークを開始しているとして、次の環境変数をCLIにコピー&ペーストしてネットワークと対話し、Org1管理者として動作します。
Make sure that you are in the `test-network` directory.	この際、 `test-network` ディレクトリにいることを確認してください。
1. Use the following command to package the marbles private data chaincode.	1. marblesプライベートデータチェーンコードをパッケージ化するには、次のコマンドを使用します。
This command will create a chaincode package named marblesp.tar.gz.	このコマンドは、marblesp.tar.gzという名前のチェーンコードパッケージを作成します。
2. Use the following command to install the chaincode package onto the peer ``peer0.org1.example.com``.	2.次のコマンドを使用して、chaincodeパッケージをpeer ``peer0.org1.example.com`` にインストールします。
A successful install command will return the chaincode identifier, similar to the response below:	インストールに成功すると、次のようなチェーンコード識別子が返されます:
3. Now use the CLI as the Org2 admin.	3.ここで、CLIをOrg2管理者として使用します。
Copy and paste the following block of commands as a group and run them all at once:	次のコマンドブロックをグループとしてコピーして貼り付け、一度に実行します:
4. Run the following command to install the chaincode on the Org2 peer:	4. 次のコマンドを実行して、Org2ピアにchaincodeをインストールします:
Each channel member that wants to use the chaincode needs to approve a chaincode definition for their organization.	チェーンコードを使用する各チャネルメンバーは、組織のチェーンコード定義を承認する必要があります。
Since both organizations are going to use the chaincode in this tutorial, we need to approve the chaincode definition for both Org1 and Org2 using the `peer lifecycle chaincode approveformyorg <commands/peerlifecycle.html#peer-lifecycle-chaincode-approveformyorg>`__ command.	このチュートリアルでは両方の組織がチェーンコードを使用するため、 `peer lifecycle chaincode approveformyorg <commands/peerlifecycle.html#peer-lifecycle-chaincode-approveformyorg>`__ コマンドを使用して、Org1とOrg2のチェーンコード定義を承認する必要があります。
The chaincode definition also includes the private data collection definition that accompanies the ``marbles02_private`` sample.	チェーンコード定義には、 ``marbles02_private`` サンプルに付随するプライベートデータコレクション定義も含まれています。
We will provide the path to the collections JSON file using the ``--collections-config`` flag.	``--collections-config`` フラグを使用してコレクションJSONファイルへのパスを提供します。
Run the following commands from the ``test-network`` directory to approve a definition for Org1 and Org2.	``test-network`` ディレクトリから次のコマンドを実行して、Org1とOrg2の定義を承認します。
1. Use the following command to query your peer for the package ID of the installed chaincode.	1. 次のコマンドを使用して、インストールされているチェーンコードのパッケージIDをピアに照会します。
The command will return the same package identifier as the install command.	このコマンドは、installコマンドと同じパッケージ識別子を返します。
You should see output similar to the following:	次のような出力が表示されます:
2. Declare the package ID as an environment variable.	2. パッケージIDを環境変数として宣言します。
Paste the package ID of marblespv1 returned by the ``peer lifecycle chaincode queryinstalled`` into the command below.	``peer lifecycle chaincode queryinstalled`` によって返されたmarblespv1のパッケージIDを次のコマンドに貼り付けます。
The package ID may not be the same for all users, so you need to complete this step using the package ID returned from your console.	パッケージIDはすべてのユーザーで同じではない可能性があるため、コンソールから返されたパッケージIDを使用してこの手順を完了する必要があります。
3. Make sure we are running the CLI as Org1.	3. CLIがOrg1として実行されていることを確認します。
Copy and paste the following block of commands as a group into the peer container and run them all at once:	次のコマンドブロックをグループとしてピアコンテナにコピー&ペーストし、一度に実行します:
4. Use the following command to approve a definition of the marbles private data chaincode for Org1.	4. 次のコマンドを使用して、Org1のmarblesプライベートデータチェーンコードの定義を承認します。
This command includes a path to the collection definition file.	このコマンドには、コレクション定義ファイルへのパスが含まれています。
When the command completes successfully you should see something similar to:	コマンドが正常に完了すると、次のようなメッセージが表示されます:
5. Now use the CLI to switch to Org2.	5. ここで、CLIを使用してOrg2に切り替えます。
Copy and paste the following block of commands as a group into the peer container and run them all at once.	次のコマンドブロックをグループとしてピアコンテナにコピー&ペーストし、一度に実行します。
6. You can now approve the chaincode definition for Org2:	6. これで、Org2のチェーンコード定義を承認できます:
Once a sufficient number of organizations (in this case, a majority) have approved a chaincode definition, one organization can commit the definition to the channel.	十分な数の組織(この場合は過半数)がチェーンコード定義を承認すると、1つの組織が定義をチャネルにコミットできます。
Use the `peer lifecycle chaincode commit <commands/peerlifecycle.html#peer-lifecycle-chaincode-commit>`__ command to commit the chaincode definition.	チェーンコード定義をコミットするには、 `peer lifecycle chaincode commit <commands/peerlifecycle.html#peer-lifecycle-chaincode-commit>`__ コマンドを使用します。
This command will also deploy the collection definition to the channel.	このコマンドは、コレクション定義もチャネルに配布します。
We are ready to use the chaincode after the chaincode definition has been committed to the channel.	チェーンコード定義がチャネルにコミットされた後、チェーンコードを使用する準備ができました。
Because the marbles private data chaincode contains an initiation function, we need to use the `peer chaincode invoke <commands/peerchaincode.html?%20chaincode%20instantiate#peer-chaincode-instantiate>`__ command to invoke ``Init()`` before we can use other functions in the chaincode.	marblesプライベートデータチェーンコードには開始関数が含まれているため、チェーンコード内の他の関数を使用する前に、 `peer chaincode invoke <commands/peerchaincode.html?%20chaincode%20instantiate#peer-chaincode-instantiate>`__ コマンドを使用して ``Init()`` を呼び出す必要があります。
1. Run the following commands to commit the definition of the marbles private data chaincode to the channel ``mychannel``.	1. 次のコマンドを実行して、marblesプライベートデータチェーンコードの定義をチャネル ``mychannel`` にコミットします。
When the commit transaction completes successfully you should see something similar to:	コミットトランザクションが正常に完了すると、次のようなメッセージが表示されます:
Acting as a member of Org1, who is authorized to transact with all of the private data in the marbles private data sample, switch back to an Org1 peer and submit a request to add a marble:	marblesプライベートデータサンプル内のすべてのプライベートデータを処理する権限を持つOrg1のメンバーとして、Org1ピアに戻り、marbleの追加要求を発行します:
Copy and paste the following set of commands into your CLI in the `test-network` directory:	次のコマンドセットをコピーし、 `test-network` ディレクトリのCLIに貼り付けます:
Invoke the marbles ``initMarble`` function which creates a marble with private data ---  name ``marble1`` owned by ``tom`` with a color ``blue``, size ``35`` and price of ``99``.	marbles ``initMarble`` 関数を起動して、 ``marble1`` という ``tom`` によって所有され、色は ``blue`` 、サイズは ``35`` 、価格は ``99`` のmarbleをプライベートデータとして作成します。
Recall that private data price will be stored separately from the private data name, owner, color, size.	プライベートデータの価格はプライベートデータの名前、所有者、色、サイズとは別に格納されることに注意してください。
For this reason, the ``initMarble`` function calls the ``PutPrivateData()`` API twice to persist the private data, once for each collection.	このため、 ``initMarble`` 関数は ``PutPrivateData()`` APIをコレクションごとに1回ずつ2回呼び出してプライベートデータを保持します。
Also note that the private data is passed using the ``--transient`` flag.	また、プライベートデータは ``--transient`` フラグを使用して渡されます。
Inputs passed as transient data will not be persisted in the transaction in order to keep the data private.	一時データとして渡された入力は、データをプライベートに保つためにトランザクションで永続化されません。
Transient data is passed as binary data and therefore when using CLI it must be base64 encoded.	一時データはバイナリデータとして渡されるため、CLIを使用する場合はbase64でエンコードする必要があります。
We use an environment variable to capture the base64 encoded value, and use ``tr`` command to strip off the problematic newline characters that linux base64 command adds.	環境変数を使用してbase64でエンコードされた値をキャプチャし、 ``tr`` コマンドを使用して、linux base64コマンドで追加される問題のある改行文字を取り除きます。
You should see results similar to:	次のような結果が表示されます:
Our collection definition allows all members of Org1 and Org2 to have the ``name, color, size, owner`` private data in their side database, but only peers in Org1 can have the ``price`` private data in their side database.	このコレクション定義では、Org1とOrg2のすべてのメンバーがサイドデータベースに ``名前、色、サイズ、所有者`` のプライベートデータを持つことができますが、 ``価格`` プライベートデータをサイドデータベースに持つことができるのはOrg1のピアのみです。
As an authorized peer in Org1, we will query both sets of private data.	Org1の認可ピアとして、両方のプライベートデータセットを問い合せます。
The first ``query`` command calls the ``readMarble`` function which passes ``collectionMarbles`` as an argument.	最初の ``query`` コマンドは、引数として ``collectionMarbles`` を渡す ``readMarble`` 関数を呼び出します。
The second ``query`` command calls the ``readMarblePrivateDetails`` function which passes ``collectionMarblePrivateDetails`` as an argument.	2番目の ``query`` コマンドは、引数として ``collectionMarblePrivateDetails`` を渡す ``readMarblePrivateDetails`` 関数を呼び出します。
Query for the ``name, color, size and owner`` private data of ``marble1`` as a member of Org1.	Org1のメンバーとして ``marble1`` の ``名前、色、サイズおよび所有者`` のプライベートデータを問い合せます。
Note that since queries do not get recorded on the ledger, there is no need to pass the marble name as a transient input.	問合せは台帳に記録されないため、一時入力としてmarble名を渡す必要はありません。
You should see the following result:	次のような結果が表示されます:
Query for the ``price`` private data of ``marble1`` as a member of Org1.	Org1のメンバーとして ``marble1`` の ``価格`` プライベートデータを問い合せます。
You should see the following result:	次のような結果が表示されます:
Now we will switch to a member of Org2.	次に、Org2のメンバーに切り替えます。
Org2 has the marbles private data ``name, color, size, owner`` in its side database, but does not store the marbles ``price`` data.	Org2のサイドデータベースにmarblesプライベートデータの ``名前、色、サイズ、所有者`` がありますが、marbels ``価格`` データは格納されません。
We will query for both sets of private data.	両方のプライベートデータセットを問い合せます。
Run the following commands to operate as the Org2 admin and query the Org2 peer.	次のコマンドを実行して、Org2管理者として動作し、Org2ピアを照会します。
Peers in Org2 should have the first set of marbles private data (``name, color, size and owner``) in their side database and can access it using the ``readMarble()`` function which is called with the ``collectionMarbles`` argument.	Org2のピアは、自分のサイドデータベースにmarblesのプライベートデータ( ``名前、色、サイズ、所有者`` )の最初のセットを持っていて、それに ``collectionMarbles`` 引数で呼ばれる ``readMarble()`` 関数を使ってアクセスできるはずです。
You should see something similar to the following result:	次のような結果が表示されます:
Peers in Org2 do not have the marbles ``price`` private data in their side database.	Org2のピアは、サイドデータベースにmarbles ``価格`` のプライベートデータを持っていません。
When they try to query for this data, they get back a hash of the key matching the public state but will not have the private state.	このデータをクエリーしようとすると、パブリックステートに一致するキーのハッシュを返しますが、プライベートステートは含まれません。
You should see a result similar to:	次のような結果が表示されます:
Members of Org2 will only be able to see the public hash of the private data.	Org2のメンバーは、プライベートデータの公開ハッシュだけを見ることができます。
For use cases where private data only needs to be on the ledger until it can be replicated into an off-chain database, it is possible to "purge" the data after a certain set number of blocks, leaving behind only hash of the data that serves as immutable evidence of the transaction.	プライベートデータがオフチェーンデータベースにレプリケートされるまで台帳にのみ存在する必要があるユースケースでは、特定のセット数のブロックが生成された後にデータを"削除"し、トランザクションのイミュータブルな証拠として機能するプライベートデータのハッシュのみを残すことができます。
There may be private data including personal or confidential information, such as the pricing data in our example, that the transacting parties don't want disclosed to other organizations on the channel.	取引当事者がチャネル上の他の組織に開示することを望まない個人情報または秘密情報を含むプライベートデータが存在する可能性があります。
Thus, it has a limited lifespan, and can be purged after existing unchanged on the blockchain for a designated number of blocks using the ``blockToLive`` property in the collection definition.	したがって、プライベートデータは寿命が限られており、コレクション定義の ``blockToLive`` プロパティを使用された、指定ブロック数分ブロックチェーン上に変更されずに存在した後で削除できます。
Our ``collectionMarblePrivateDetails`` definition has a ``blockToLive`` property value of three meaning this data will live on the side database for three blocks and then after that it will get purged.	``collectionMarblePrivateDetails`` 定義には、 ``blockToLive`` プロパティ値として3があります。つまり、このデータは3ブロック追加されるまでサイドデータベースに保存され、その後消去されます。
Tying all of the pieces together, recall this collection definition  ``collectionMarblePrivateDetails`` is associated with the ``price`` private data in the  ``initMarble()`` function when it calls the ``PutPrivateData()`` API and passes the ``collectionMarblePrivateDetails`` as an argument.	すべての部分を結び付けて、このコレクション定義 ``collectionMarblePrivateDetails`` は、 ``PutPrivateData()`` APIを呼び出して ``collectionMarblePrivateDetails`` を引数として渡すことで、 ``initMarble()`` 関数において、 ``価格`` プライベートデータに関連付けられていることを思い出してください。
We will step through adding blocks to the chain, and then watch the price information get purged by issuing four new transactions (Create a new marble, followed by three marble transfers) which adds four new blocks to the chain.	チェーンにブロックを追加する手順を実行します。次に、チェーンに4つの新規ブロックを追加する4つの新規トランザクション(3つのmarble転送に続いて、新規のmarbleを作成)を発行して、価格情報が消去されるのを確認します。
After the fourth transaction (third marble transfer), we will verify that the price private data is purged.	4番目のトランザクション(3番目のmarble転送)の後、価格プライベートデータが消去されることを確認します。
Switch back to Org1 using the following commands.	次のコマンドを使用して、Org1に戻ります。
Copy and paste the following code block and run it inside your peer container:	次のコードブロックをコピーして貼り付け、ピアコンテナ内で実行します:
Open a new terminal window and view the private data logs for this peer by running the following command.	新しいターミナルウィンドウを開き、次のコマンドを実行して、このピアのプライベートデータログを表示します。
Note the highest block number.	最大のブロック番号に注目してください。
Back in the peer container, query for the marble1 price data by running the following command.	ピアコンテナに戻り、次のコマンドを実行してmarble1 価格データを問い合せます。
A Query does not create a new transaction on the ledger since no data is transacted.	データが取引されないため、問合せでは台帳に新規トランザクションは作成されません
You should see results similar to:	次のような結果が表示されます:
The ``price`` data is still in the private data ledger.	``価格`` データはまだプライベートデータ台帳にあります。
Create a new marble2 by issuing the following command.	次のコマンドを実行して、新しいmarble2を作成します。
This transaction creates a new block on the chain.	このトランザクションはチェーン上に新しいブロックを作成します。
Switch back to the Terminal window and view the private data logs for this peer again.	ターミナルウィンドウに戻り、このピアのプライベートデータログをもう一度表示します。
You should see the block height increase by 1.	ブロックの高さが1だけ増加します。
Back in the peer container, query for the marble1 price data again by running the following command:	ピアコンテナに戻り、次のコマンドを実行して、marble1の価格データを再度問い合わせます:
The private data has not been purged, therefore the results are unchanged from previous query:	プライベートデータは削除されていないため、結果は前の問い合せ結果と同じです:
Transfer marble2 to "joe" by running the following command.	次のコマンドを実行して、marble2を"joe"に転送します。
This transaction will add a second new block on the chain.	このトランザクションは、チェーンに2つ目の新しいブロックを追加します。
Switch back to the Terminal window and view the private data logs for this peer again.	ターミナルウィンドウに戻り、このピアのプライベートデータログをもう一度表示します。
You should see the block height increase by 1.	ブロックの高さが1だけ増加します。
Back in the peer container, query for the marble1 price data by running the following command:	ピアコンテナに戻り、次のコマンドを実行してmarble1の価格データを照会します:
You should still be able to see the price private data.	価格のプライベートデータはまだ表示されるはずです。
Transfer marble2 to "tom" by running the following command.	次のコマンドを実行して、marble2を「tom」に転送します。
This transaction will create a third new block on the chain.	このトランザクションにより、チェーン上に3つ目の新しいブロックが作成されます。
Switch back to the Terminal window and view the private data logs for this peer again.	ターミナルウィンドウに戻り、このピアのプライベートデータログをもう一度表示します。
You should see the block height increase by 1.	ブロックの高さが1だけ増加します。
Back in the peer container, query for the marble1 price data by running the following command:	ピアコンテナに戻り、次のコマンドを実行してmarble1の価格データを照会します:
You should still be able to see the price data.	価格データはまだ表示されます。
Finally, transfer marble2 to "jerry" by running the following command.	最後に、次のコマンドを実行してmarble2を"jerry"に転送します。
This transaction will create a fourth new block on the chain.	このトランザクションでは、チェーン上に4つ目の新規ブロックが作成されます。
The ``price`` private data should be purged after this transaction.	``価格`` プライベートデータは、このトランザクション後に消去する必要があります。
Switch back to the Terminal window and view the private data logs for this peer again.	ターミナルウィンドウに戻り、このピアのプライベートデータログをもう一度表示します。
You should see the block height increase by 1.	ブロックの高さが1だけ増加します。
Back in the peer container, query for the marble1 price data by running the following command:	ピアコンテナに戻り、次のコマンドを実行してmarble1の価格データを照会します:
Because the price data has been purged, you should no longer be able to see it.	価格データが削除されているため、表示できなくなります。
You should see something similar to:	次のような情報が表示されます:
Indexes can also be applied to private data collections, by packaging indexes in the ``META-INF/statedb/couchdb/collections/<collection_name>/indexes`` directory alongside the chaincode.	インデックスは、チェーンコードとともに ``META-INF/statedb/couchdb/collections/<collection_name>/indexes`` ディレクトリにインデックスをパッケージ化することで、プライベートデータコレクションにも適用できます。
An example index is available `here <https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/marbles02_private/go/META-INF/statedb/couchdb/collections/collectionMarbles/indexes/indexOwner.json>`__ .	インデックスの例は `ここ <https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/marbles02_private/go/META-INF/statedb/couchdb/collections/collectionMarbles/indexes/indexOwner.json>`__ にあります。
For deployment of chaincode to production environments, it is recommended to define any indexes alongside chaincode so that the chaincode and supporting indexes are deployed automatically as a unit, once the chaincode has been installed on a peer and instantiated on a channel.	実稼働環境へのチェーンコードの配置では、チェーンコードがピアにインストールされ、チャネル上でインスタンス化された後に、チェーンコードとサポートするインデックスが自動的に1つの単位として配置されるように、チェーンコードとともにインデックスを定義することをお勧めします。
The associated indexes are automatically deployed upon chaincode instantiation on the channel when the  ``--collections-config`` flag is specified pointing to the location of the collection JSON file.	関連付けられたインデックスは、コレクションJSONファイルの場所を示す ``--collections-config`` フラグが指定されることによって、チャネル上でのチェーンコードのインスタンス化タイミングで自動的に配置されます。
For additional private data education, a video tutorial has been created...	その他のプライベートデータに関する教育については、ビデオチュートリアルが作成されています。
The video uses the previous lifecycle model to install private data collections with chaincode.	このビデオでは、以前のライフサイクルモデルを使用して、チェーンコードを含むプライベートデータコレクションをインストールしています。
`Docker <https://docs.docker.com/get-docker/>`__ version 18.03 or later	`Docker <https://docs.docker.com/get-docker/>`__ version 18.03 以降
For macOS, we recommend using `Homebrew <https://brew.sh>`__ to manage the development prereqs.	macOSの場合、`Homebrew <https://brew.sh>`__ を使用して開発の前提条件を管理することをお勧めします。
The Xcode command line tools will be installed as part of the Homebrew installation.	Xcodeコマンドラインツールは、Homebrewインストールの一部としてインストールされます。
Once Homebrew is ready, installing the necessary prerequisites is very easy:	Homebrewの準備ができたら、必要な前提条件のインストールは非常に簡単です:
Docker Desktop must be launched to complete the installation so be sure to open the application after installing it:	インストールを完了するには Docker Desktop を起動する必要があるため、インストール後に必ずアプリケーションを開いてください:
On Windows 10 you should use the native Docker distribution and you may use the Windows PowerShell.	Windows 10では、Windows ネイティブの Docker ディストリビューションを使用する必要があり、Windows PowerShellを使用できます。
However, for the ``binaries`` command to succeed you will still need to have the ``uname`` command available.	ただし、``binaries`` コマンドを成功させるには、``uname`` コマンドを使用できるようにする必要があります。
You can get it as part of Git but beware that only the 64bit version is supported.	それはGitの一部として入手できますが、64ビットバージョンのみがサポートされていることに注意してください。
Before running any ``git clone`` commands, run the following commands:	``git clone`` コマンドを実行する前に、次のコマンドを実行します:
You can check the setting of these parameters with the following commands:	これらのパラメータの設定は、次のコマンドで確認できます:
These need to be ``false`` and ``true`` respectively.	これらはそれぞれ ``false`` と ``true`` が設定されている必要があります。
The ``curl`` command that comes with Git and Docker Toolbox is old and does not handle properly the redirect used in :doc:`../getting_started`.	Git と Docker Toolbox に付属の ``curl`` コマンドは古く、:doc:`../getting_started` で使用されているリダイレクトを適切に処理しません。
Make sure you have and use a newer version which can be downloaded from the `cURL downloads page <https://curl.haxx.se/download.html>`__	`cURL ダウンロードページ <https://curl.haxx.se/download.html>`__ からダウンロードできる新しいバージョンを使用していることを確認してください。
First navigate to https://github.com/hyperledger/fabric and fork the fabric repository using the fork button in the top-right corner.	まず、 https://github.com/hyperledger/fabric に移動し、右上隅にあるForkボタンを使用してファブリックリポジトリをフォークします。
After forking, clone the repository.	フォークした後、リポジトリをクローンします。
If you are running Windows, before cloning the repository, run the following command:	Windows を使っている場合は、リポジトリをクローンする前に、次のコマンドを実行します:
If ``core.autocrlf`` is set to ``true``, you must set it to ``false`` by running:	``core.autocrlf`` が ``true`` に設定されている場合は、以下を実行して ``false`` に設定する必要があります:
A PKCS #11 cryptographic token implementation is required to run the unit tests.	単体テストを実行するには、PKCS #11 暗号化トークンの実装が必要です。
The PKCS #11 API is used by the bccsp component of Fabric to interact with hardware security modules (HSMs) that store cryptographic information and perform cryptographic computations.	PKCS #11 API は、Fabric の bccsp コンポーネントによって使用され、暗号化情報を格納して暗号化計算を実行するハードウェアセキュリティモジュール (HSM) と対話します。
For test environments, SoftHSM can be used to satisfy this requirement.	テスト環境では、SoftHSM を使用してこの要件を満たすことができます。
SoftHSM generally requires additional configuration before it can be used.	SoftHSM は通常、使用する前に追加設定が必要です。
For example, the default configuration will attempt to store token data in a system directory that unprivileged users are unable to write to.	たとえば、デフォルト設定では、特権のないユーザーが書き込めないシステムディレクトリにトークンデータを保存しようとします。
SoftHSM configuration typically involves copying ``/etc/softhsm2.conf`` to ``$HOME/.config/softhsm2/softhsm2.conf`` and changing ``directories.tokendir`` to an appropriate location.	SoftHSMの設定は、通常、 ``/etc/softhsm2.conf`` を ``$HOME/.config/softhsm2/softhsm2.conf`` にコピーし、``directories.tokendir`` を適切な場所に変更します。
Please see the man page for ``softhsm2.conf`` for details.	詳細については、 ``softhsm2.conf`` の man ページを参照してください。
After SoftHSM has been configured, the following command can be used to initialize the token required by the unit tests:	SoftHSMを設定した後、次のコマンドを使用して、単体テストに必要なトークンを初期化できます:
If tests are unable to locate the libsofthsm2.so library in your environment, specify the library path, the PIN, and the label of your token in the appropriate environment variables.	テストであなたの環境内の libsofthsm2.so ライブラリを見つけることができない場合は、適切な環境変数でライブラリのパス、PIN、およびトークンのラベルを指定します。
For example, on macOS:	たとえば、macOSの場合は以下の通りです:
Once the repository is cloned, you can use ``make`` to install some of the tools used in the development environment.	リポジトリをクローンしたら、 ``make`` を使用して、開発環境で使用されるツールの一部をインストールできます。
By default, these tools will be installed into ``$HOME/go/bin``.	デフォルトでは、これらのツールは ``$HOME/go/bin`` にインストールされます。
Please be sure your ``PATH`` includes that directory.	``PATH`` にそのディレクトリが含まれていることを確認してください。
After installing the tools, the build environment can be verified by running a few commands.	これらのツールをインストールした後、いくつかのコマンドを実行してビルド環境を確認できます。
If those commands completely successfully, you're ready to Go!	これらのコマンドが完全に正常に実行されたら、準備は完了です！
If you plan to use the Hyperledger Fabric application SDKs then be sure to check out their prerequisites in the Node.js SDK `README <https://github.com/hyperledger/fabric-sdk-node#build-and-test>`__ and Java SDK `README <https://github.com/hyperledger/fabric-gateway-java/blob/master/README.md>`__.	もし Hyperledger Fabric のアプリケーション SDK を使用する場合には、Node.js SDK の `README <https://github.com/hyperledger/fabric-sdk-node#build-and-test>`__と Java SDK の `README <https://github.com/hyperledger/fabric-gateway-java/blob/master/README.md>`__ の前提条件を確認してください。
In order to execute chaincode on peers, submit transactions to orderers, and to be updated about the status of transactions, applications connect to an API exposed by an SDK.	ピアでチェーンコードを実行し、トランザクションをordererに送信し、トランザクションのステータスについて通知を受けるために、アプリケーションはSDKによって公開されるAPIに接続します。
However, the SDK needs a lot of information in order to allow applications to connect to the relevant network nodes.	ただし、アプリケーションが関連するネットワークノードに接続できるようにするためには、SDKに多くの情報が必要となります。
In addition to the CA and TLS certificates of the orderers and peers on the channel -- as well as their IP addresses and port numbers -- it must know the relevant endorsement policies as well as which peers have the chaincode installed (so the application knows which peers to send chaincode proposals to).	チャネル上のordererとピアのCAそしてTLS証明書、--- およびそれらのIPアドレスとポート番号 --- に加えて、SDKは関連するエンドースメントポリシーとともに、チェーンコードがどのピアにインストールされているか(それによってアプリケーションはどのピアにチェーンコードの提案を送信するかがわかります)を知っていなくてはなりません。
Prior to v1.2, this information was statically encoded.	v1.2より前のバージョンではこの情報は静的にエンコードされていました。
However, this implementation is not dynamically reactive to network changes (such as the addition of peers who have installed the relevant chaincode, or peers that are temporarily offline).	ただし、この実装はネットワークの変更(関連するチェーンコードをインストールしたピアの追加、または一時的なピアのオフライン)に対して動的に対応できるものではありません。
Static configurations also do not allow applications to react to changes of the endorsement policy itself (as might happen when a new organization joins a channel).	静的な設定では、(新しい組織がチャネルに参加したときに発生する可能性がある)エンドースメントポリシー自体の変更に対してアプリケーションが対応することもできません。
In addition, the client application has no way of knowing which peers have updated ledgers and which do not.	また、クライアントアプリケーションには更新された台帳があるピアとないピアを知る方法がありません。
As a result, the application might submit proposals to peers whose ledger data is not in sync with the rest of the network, resulting in transaction being invalidated upon commit and wasting resources as a consequence.	その結果、アプリケーションは台帳データがネットワークの他の部分と同期していないピアに提案を送信し、その結果、トランザクションがコミットしたときに無効になり、結果としてリソースを浪費する可能性があります。
The discovery service improves this process by having the peers compute the needed information dynamically and present it to the SDK in a consumable manner.	ディスカバリーサービス はピアが必要な情報を動的に算出し、それを解釈可能なようにSDKに提供することによって、このプロセスを改善します。
The application is bootstrapped knowing about a group of peers which are trusted by the application developer/administrator to provide authentic responses to discovery queries.	アプリケーションはアプリケーション開発者/管理者によって信頼され、ディスカバリークエリに対して真正の応答を提供するピアのグループを認識して起動します。
A good candidate peer to be used by the client application is one that is in the same organization.	クライアントアプリケーションで使用するピアの候補としては同じ組織内のピアが適しています。
Note that in order for peers to be known to the discovery service, they must have an ``EXTERNAL_ENDPOINT`` defined.	ピアがディスカバリーサービスに認識されるためには ``EXTERNAL_ENDPOINT`` が定義されていなければならないことに注意してください。
To see how to do this, check out our :doc:`discovery-cli` documentation.	この方法については :doc:`discovery-cli` ドキュメントを参照してください。
The application issues a configuration query to the discovery service and obtains all the static information it would have otherwise needed to communicate with the rest of the nodes of the network.	アプリケーションは構成クエリをディスカバリーサービスに発行し、ネットワークの他のノードと通信を行うのに、このサービスを使わなければ必要であった静的な情報すべてを取得します。
This information can be refreshed at any point by sending a subsequent query to the discovery service of a peer.	この情報は、後続のクエリをピアのディスカバリーサービスに送信することにより、いつでも更新できます。
The service runs on peers -- not on the application -- and uses the network metadata information maintained by the gossip communication layer to find out which peers are online.	このサービスはアプリケーション上ではなくピア上で実行され、ゴシップコミュニケーションレイヤーで管理されているネットワークメタデータ情報を使用して、どのピアがオンラインであるかを把握します。
It also fetches information, such as any relevant endorsement policies, from the peer's state database.	また、ピアのステートデータベースから関連するエンドースメントポリシーなどの情報を取得します。
With service discovery, applications no longer need to specify which peers they need endorsements from.	サービスディスカバリーを使用すると、アプリケーションはエンドースメントを取得するピアを指定する必要がなくなります。
The SDK can simply send a query to the discovery service asking which peers are needed given a channel and a chaincode ID.	SDKは、チャネルとチェーンコードIDを指定して、どのピアが必要かを尋ねるクエリをディスカバリーサービスに送信するだけです。
The discovery service will then compute a descriptor comprised of two objects:  	ディスカバリーサービスは次の2つのオブジェクトで構成される記述子を計算します：
1. Layouts: a list of groups of peers and a corresponding amount of peers from each group which should be selected.	1. Layouts: ピアのグループのリストと、各グループから選択する必要があるピアの数。
2. Group to peer mapping: from the groups in the layouts to the peers of the channel.	2. Group to peer mapping: レイアウト内のグループからチャネルのピアへのマッピング。
In practice, each group would most likely be peers that represent individual organizations, but because the service API is generic and ignorant of organizations this is just a "group".	実際には各グループは個々の組織を表すピアである可能性が最も高いですが、サービスAPIは汎用的であり、組織を意識しないため、これは単なる「グループ」です。
The following is an example of a descriptor from the evaluation of a policy of ``AND(Org1, Org2)`` where there are two peers in each of the organizations.	以下は、各組織に2つのピアがある ``AND(Org1, Org2)`` のポリシーの評価からの記述子の例です。
In other words, the endorsement policy requires a signature from one peer in Org1 and one peer in Org2.	言い換えると、エンドースメントポリシーは組織1の1つのピアと組織2の1つのピアからの署名が必要としています。
And it provides the names of available peers in those orgs who can endorse (``peer0`` and ``peer1`` in both Org1 and in Org2).	そして、エンドースできる組織の中で利用可能なピアの名前(Org1とOrg2の両方にある ``peer0`` と ``peer1`` )を提示します。
The SDK then selects a random layout from the list.	次に、SDKはリストからランダムにレイアウトを選択します。
In the example above, the endorsement policy is Org1 ``AND`` Org2.	上の例ではエンドースメントポリシーはOrg1 ``AND`` Org2です。
If instead it was an ``OR`` policy, the SDK would randomly select either Org1 or Org2, since a signature from a peer from either Org would satisfy the policy.	もしそれが ``OR`` ポリシーであれば、SDKはランダムにOrg1かOrg2のどちらかを選択します。どちらかのOrgからのピアからの署名がポリシーを満たすからです。
After the SDK has selected a layout, it selects from the peers in the layout based on a criteria specified on the client side (the SDK can do this because it has access to metadata like ledger height).	SDKはレイアウトを選択した後、クライアント側で指定された基準に基づいて、レイアウト内のピアから選択します(SDKは台帳の高さなどのメタデータにアクセスできるため、これを行うことができます)。
For example, it can prefer peers with higher ledger heights over others -- or to exclude peers that the application has discovered to be offline -- according to the number of peers from each group in the layout.	たとえば、レイアウト内の各グループのピアの数に応じて台帳の高さが他の高さが高いピアを優先したり、アプリケーションがオフラインであることを検出したピアを除外したりできます。
If no single peer is preferable based on the criteria, the SDK will randomly select from the peers that best meet the criteria.	基準に基づいて望ましいピアが1つもない場合、SDKは基準を最も満たすピアをランダムに選択します。
The discovery service can respond to the following queries:	ディスカバリーサービスは次のクエリに応答できます。
Configuration query:	コンフィギュレーションクエリ(Configuration query)：
Returns the ``MSPConfig`` of all organizations in the channel along with the orderer endpoints of the channel.	チャネル内のすべての組織の ``MSPConfig`` と、そのチャネルのordererエンドポイントを返します。
Peer membership query:	ピアメンバーシップクエリ(Peer membership query):
Returns the peers that have joined the channel.	チャネルに参加しているピアを返します。
Endorsement query:	エンドースメントクエリ(Endorsement query):
Returns an endorsement descriptor for given chaincode(s) in a channel.	チャネル内の特定のチェーンコードのエンドースメント記述子を返します。
Local peer membership query:	ローカルピアメンバーシップクエリ(Local peer membership query):
Returns the local membership information of the peer that responds to the query.	クエリに応答するピアのローカルメンバーシップ情報を戻します。
By default the client needs to be an administrator for the peer to respond to this query.	デフォルトでは、クライアントは、このクエリに応答するピアの管理者である必要があります。
When the peer is running with TLS enabled the client must provide a TLS certificate when connecting to the peer.	ピアがTLSを有効にして実行されている場合、クライアントはピアに接続するときにTLS証明書を提供する必要があります。
If the peer isn't configured to verify client certificates (clientAuthRequired is false), this TLS certificate can be self-signed.	ピアがクライアント証明書を確認するように設定されていない場合(clientAuthRequiredがfalse)、このTLS証明書は自己署名可能です。
**Audience** : Architects, ordering service admins, channel creators	**対象読者** : アーキテクト、オーダリングサービス管理者、チャネル作成者
This topic serves as a conceptual introduction to the concept of ordering, how orderers interact with peers, the role they play in a transaction flow, and an overview of the currently available implementations of the ordering service, with a particular focus on the recommended Raft ordering service implementation.	このトピックでは、オーダリングの概念、ordererとピアの相互作用、トランザクションフローでの役割、現在利用可能なオーダリングサービスの実装の概要について、特に推奨されるRaftオーダリングサービスの実装に重点を置いて説明します。
Many distributed blockchains, such as Ethereum and Bitcoin, are not permissioned, which means that any node can participate in the consensus process, wherein transactions are ordered and bundled into blocks.	EthereumやBitcoinのような多くの分散ブロックチェーンは許可型ではありません。これはどのノードも、トランザクションが順序付けられブロックに格納されるコンセンサスプロセスに参加出来るということを意味します。
Because of this fact, these systems rely on probabilistic consensus algorithms which eventually guarantee ledger consistency to a high degree of probability, but which are still vulnerable to divergent ledgers (also known as a ledger "fork"), where different participants in the network have a different view of the accepted order of transactions.	この事実のために、これらのシステムは、最終的には高い確率で台帳の一貫性を保証する確率的なコンセンサスアルゴリズムに依存しますが、ネットワーク内の異なる参加者が受け入れられたトランザクションの順序について別の見解を有する異なる台帳(台帳の「フォーク」としても知られる)に対しては依然として脆弱です。
Hyperledger Fabric works differently.	Hyperledger Fabricの動作は異なります。
It features a node called an orderer (it's also known as an "ordering node") that does this transaction ordering, which along with other orderer nodes forms an ordering service.	トランザクションの順序付けを行うorderer(「オーダリングノード」とも言います)と呼ばれるノードを実装し、他のordererノードとともにオーダリングサービスを形成します。
Because Fabric's design relies on deterministic consensus algorithms, any block validated by the peer is guaranteed to be final and correct.	Fabricの設計は決定的なコンセンサスアルゴリズムに依存しているため、ピアによって検証されたブロックは最終的で正確であることが保証されます。
Ledgers cannot fork the way they do in many other distributed and permissionless blockchain networks.	他の多くの分散型で非許可型のブロックチェーンネットワークとは異なり、台帳の分岐(フォーク)は起こりません。
In addition to promoting finality, separating the endorsement of chaincode execution (which happens at the peers) from ordering gives Fabric advantages in performance and scalability, eliminating bottlenecks which can occur when execution and ordering are performed by the same nodes.	ファイナリティを促進することに加えて、(ピアで行われる)チェーンコードのエンドースメントの実行を、順序付けから分離することは、パフォーマンスと拡張性の点でFabricの優位性を提供し、実行と順序付けが同じノードによって行われる場合に発生する可能性があるボトルネックを排除します。
In addition to their ordering role, orderers also maintain the list of organizations that are allowed to create channels.	ordererは、オーダリングの役割に加えて、チャネルを作成できる組織のリストも保持します。
This list of organizations is known as the "consortium", and the list itself is kept in the configuration of the "orderer system channel" (also known as the "ordering system channel").	この組織のリストは「コンソーシアム」と呼ばれ、リスト自体は「ordererシステムチャネル」(「オーダリングシステムチャネル」とも呼ばれる)の設定内に保持されます。
By default, this list, and the channel it lives on, can only be edited by the orderer admin.	デフォルトでは、このリストと、このリストが存在するチャネルは、ordererの管理者のみが編集できます。
Note that it is possible for an ordering service to hold several of these lists, which makes the consortium a vehicle for Fabric multi-tenancy.	オーダリングサービスがこれらのリストのいくつかを保持することが可能であり、これによりコンソーシアムがFabricのマルチテナントの手段となることに留意ください。
Orderers also enforce basic access control for channels, restricting who can read and write data to them, and who can configure them.	また、ordererはチャネルに対する基本的なアクセスコントロールを実施し、チャネルに対するデータの読み取りと書き込み、およびチャネルを設定できるユーザーを制限します。
Remember that who is authorized to modify a configuration element in a channel is subject to the policies that the relevant administrators set when they created the consortium or the channel.	チャネル内の設定要素を変更する権限を持つユーザーは、関連する管理者がコンソーシアムまたはチャネルを作成したときに設定したポリシーに従うことに注意してください。
Configuration transactions are processed by the orderer, as it needs to know the current set of policies to execute its basic form of access control.	コンフィギュレーショントランザクションは、基本的なアクセス制御を実行するために現在のポリシーセットを知る必要があるため、ordererによって処理されます。
In this case, the orderer processes the configuration update to make sure that the requestor has the proper administrative rights.	この場合、ordererは設定の更新を処理して、要求者が適切な管理権限を持っていることを確認します。
If so, the orderer validates the update request against the existing configuration, generates a new configuration transaction, and packages it into a block that is relayed to all peers on the channel.	もし管理権限を持っていれば、ordererは既存の設定に対して更新要求を検証し、新しいコンフィギュレーショントランザクションを生成し、それをブロックにパッケージ化して、チャネル上のすべてのピアに配布します。
The peers then process the configuration transactions in order to verify that the modifications approved by the orderer do indeed satisfy the policies defined in the channel.	その後、ピアはコンフィギュレーショントランザクションを処理して、ordererによってエンドースされた変更がチャネルで定義されたポリシーを実際に満たしていることを確認します。
Everything that interacts with a blockchain network, including peers, applications, admins, and orderers, acquires their organizational identity from their digital certificate and their Membership Service Provider (MSP) definition.	ピア、アプリケーション、管理者、ordererなど、ブロックチェーンネットワークとやり取りするすべてのものは、デジタル証明書とメンバーシップサービスプロバイダ(MSP)の定義から組織アイデンティティ(ID)を取得します。
For more information about identities and MSPs, check out our documentation on [Identity](../identity/identity.html) and [Membership](../membership/membership.html).	アイデンティとMSPの詳細については、[Identity](../identity/identity.html)と[Membership](../membership/membership.html)に関するドキュメントを参照してください。
Just like peers, ordering nodes belong to an organization.	ピアと同様に、オーダリングノードは組織に属します。
And similar to peers, a separate Certificate Authority (CA) should be used for each organization.	また、ピアと同様に、組織ごとに個別の認証局(CA)を使用する必要があります。
Whether this CA will function as the root CA, or whether you choose to deploy a root CA and then intermediate CAs associated with that root CA, is up to you.	このCAがルートCAとして機能するか、またはルートCAとそのルートCAに関連付けられた中間CAを展開するかはユーザ次第です。
We've seen from our topic on [Peers](../peers/peers.html) that they form the basis for a blockchain network, hosting ledgers, which can be queried and updated by applications through smart contracts.	私たちは[Peers](../peers/peers.html)のトピックから、ピアがブロックチェーンネットワークの基礎を形成し、台帳をホストし、スマートコントラクトを通じてアプリケーションが台帳の内容を照会および更新できることを理解しました。
Specifically, applications that want to update the ledger are involved in a process with three phases that ensures all of the peers in a blockchain network keep their ledgers consistent with each other.	具体的には、台帳を更新するアプリケーションは、ブロックチェーンネットワーク内のすべてのピアが台帳の一貫性を維持することを保証する3つのフェーズのプロセスに関与します。
In the first phase, a client application sends a transaction proposal to a subset of peers that will invoke a smart contract to produce a proposed ledger update and then endorse the results.	最初のフェーズでは、クライアントアプリケーションはトランザクション提案をピアのサブセットに送信します。これらのピアは、スマートコントラクトを起動して要求された台帳への更新を生成し、その結果をエンドースします。
The endorsing peers do not apply the proposed update to their copy of the ledger at this time.	その時点では、これらエンドースメントピアは、台帳のコピーに対して更新を行いません。
Instead, the endorsing peers return a proposal response to the client application.	代わりに、エンドースメントピアはトランザクション提案への応答をクライアントアプリケーションに返します。
The endorsed transaction proposals will ultimately be ordered into blocks in phase two, and then distributed to all peers for final validation and commit in phase three.	エンドースされたトランザクション提案は、最終的にはフェーズ2でブロックの中で順序付けられ、フェーズ3で最終的な検証とコミットのためにすべてのピアに配布されます。
For an in-depth look at the first phase, refer back to the [Peers](../peers/peers.html#phase-1-proposal) topic.	最初のフェーズの詳細については、[Peers](../peers/peers.html#phase-1-proposal)のトピックを参照してください。
After the completion of the first phase of a transaction, a client application has received an endorsed transaction proposal response from a set of peers.	トランザクションの最初のフェーズが完了した後、クライアントアプリケーションはピア群からエンドース済のトランザクション提案へのレスポンスを受信しています。
It's now time for the second phase of a transaction.	ここからトランザクションの2番目のフェーズです。
In this phase, application clients submit transactions containing endorsed transaction proposal responses to an ordering service node.	このフェーズでは、アプリケーションクライアントは、エンドース済のトランザクション提案のレスポンスを含むトランザクションをオーダーリングサービスノードに送信します。
The ordering service creates blocks of transactions which will ultimately be distributed to all peers on the channel for final validation and commit in phase three.	オーダリングサービスはトランザクションのブロックを作成し、最終的にはフェーズ3で最終的な検証とコミットを実施するためにチャネル上のすべてのピアに配布されます。
Ordering service nodes receive transactions from many different application clients concurrently.	オーダリングサービスノードは、多くの異なるアプリケーションクライアントから同時にトランザクションを受け取ります。
These ordering service nodes work together to collectively form the ordering service.	これらのオーダリングサービスノードは、一緒に動作して、集合的にオーダリングサービスを形成します。
Its job is to arrange batches of submitted transactions into a well-defined sequence and package them into blocks.	その役割は、サブミットされたトランザクションの集合を適切に定義された順序で配置し、それらをブロックにパッケージ化することです。
These blocks will become the blocks of the blockchain!	これらのブロックは、ブロックチェーンのブロックになります。
The number of transactions in a block depends on channel configuration parameters related to the desired size and maximum elapsed duration for a block (`BatchSize` and `BatchTimeout` parameters, to be exact).	ブロック内のトランザクション数は、目的のサイズおよびブロックの最大経過時間に関連するチャネル設定パラメータ(正確には`BatchSize`および`BatchTimeout`パラメータ)によって決まります。
The blocks are then saved to the orderer's ledger and distributed to all peers that have joined the channel.	その後、ブロックはordererの台帳に保存され、チャネルに参加している全てのピアに配布されます。
If a peer happens to be down at this time, or joins the channel later, it will receive the blocks after reconnecting to an ordering service node, or by gossiping with another peer.	この時点でピアがダウンしていたり、後からチャネルに参加した場合は、オーダリングサービスノードに再接続した後、または別のピアとゴシップ通信によりブロックを受信します。
We'll see how this block is processed by peers in the third phase.	3番目のフェーズでは、このブロックがピアによってどのように処理されるかを確認します。
The first role of an ordering node is to package proposed ledger updates.	オーダリングノードの第一の役割は、提案された台帳への更新をパッケージ化することです。
In this example, application A1 sends a transaction T1 endorsed by E1 and E2 to the orderer O1.	この例では、アプリケーションA1は、E1およびE2によってエンドースされたトランザクションT1をordererのO1に送信します。
In parallel, Application A2 sends transaction T2 endorsed by E1 to the orderer O1.	並行して、アプリケーションA2は、E1によってエンドースされたトランザクションT2をordererのO1に送信します。
O1 packages transaction T1 from application A1 and transaction T2 from application A2 together with other transactions from other applications in the network into block B2.	O1は、アプリケーションA1からのトランザクションT1とアプリケーションA2からのトランザクションT2を、ネットワーク内の他のアプリケーションからの他のトランザクションと共にブロックB2にパッケージ化します。
We can see that in B2, the transaction order is T1,T2,T3,T4,T6,T5 -- which may not be the order in which these transactions arrived at the orderer!	B2では、トランザクションの順序がT1、T2、T3、T4、T6、T5であることがわかります。これは、これらトランザクションがordererに到着した順序とは異なる場合があります
This example shows a very simplified ordering service configuration with only one ordering node.	この例では、オーダリングノードが1つだけの非常にシンプルなオーダリングサービス構成を示しています。
It's worth noting that the sequencing of transactions in a block is not necessarily the same as the order received by the ordering service, since there can be multiple ordering service nodes that receive transactions at approximately the same time.	ブロック内のトランザクションの順序は、必ずしもオーダリングサービスが受け取る順序と同じではないことに注意してください。というのも、複数のオーダリングサービスノードがほぼ同時にトランザクションを受信する可能性があるからです。
What's important is that the ordering service puts the transactions into a strict order, and peers will use this order when validating and committing transactions.	重要なのは、オーダリングサービスがトランザクションを厳密な順序に並べ、ピアがトランザクションを検証およびコミットするときにこの順序を使用することです。
This strict ordering of transactions within blocks makes Hyperledger Fabric a little different from other blockchains where the same transaction can be packaged into multiple different blocks that compete to form a chain.	ブロック内のトランザクションのこの厳密な順序付けにより、Hyperledger Fabricは、同じトランザクションを複数の異なるブロックにパッケージ化してチェーンを形成することができる他のブロックチェーンとは少し異なります。
In Hyperledger Fabric, the blocks generated by the ordering service are final.	Hyperledger Fabricでは、オーダリングサービスによって生成されるブロックが最終的なものです。
Once a transaction has been written to a block, its position in the ledger is immutably assured.	トランザクションがブロックに書き込まれると、そのトランザクションの台帳内での位置が不変的に保証されます。
As we said earlier, Hyperledger Fabric's finality means that there are no ledger forks	前述したように、Hyperledger Fabricのファイナリティは、台帳のフォークが存在しないことを意味します。
validated transactions will never be reverted or dropped.	検証されたトランザクションは、戻されたり削除されたりすることはありません。
We can also see that, whereas peers execute smart contracts and process transactions, orderers most definitely do not.	また、ピアがスマートコントラクトを実行してトランザクションを処理するのに対して、ordererはそれを実行しないこともわかります。
Every authorized transaction that arrives at an orderer is mechanically packaged in a block	ordererに到着するすべての許可されたトランザクションは、機械的にブロックにパッケージ化されます。
the orderer makes no judgement as to the content of a transaction (except for channel configuration transactions, as mentioned earlier).	ordererは、トランザクションの内容について判断しません(前述のチャネル設定トランザクションを除く)。
At the end of phase two, we see that orderers have been responsible for the simple but vital processes of collecting proposed transaction updates, ordering them, and packaging them into blocks, ready for distribution.	フェーズ2の終わりには、提案されたトランザクションを収集し、順序付けし、ブロックにパッケージ化して配布できるようにするという、シンプルだが重要なプロセスをordererが担当していることがわかります。
The third phase of the transaction workflow involves the distribution and subsequent validation of blocks from the orderer to the peers, where they can be committed to the ledger.	トランザクションワークフローの3番目のフェーズでは、ブロックをordererからピアに配布して検証し、台帳にコミットします。
Phase 3 begins with the orderer distributing blocks to all peers connected to it.	フェーズ3は、ordererが接続されているすべてのピアにブロックを配布することから始まります。
It's also worth noting that not every peer needs to be connected to an orderer	また、すべてのピアがordererに接続する必要があるわけではありません。
peers can cascade blocks to other peers using the [gossip](../gossip.html) protocol.	ピアは[gossip](../gossip.html)プロトコルにより、他のピアにブロックを転送することができます。
Each peer will validate distributed blocks independently, but in a deterministic fashion, ensuring that ledgers remain consistent.	各ピアは、分散されたブロックを個別に検証しますが、決定的な方法で検証し、台帳の一貫性を維持します。
Specifically, each peer in the channel will validate each transaction in the block to ensure it has been endorsed by the required organization's peers, that its endorsements match, and that it hasn't become invalidated by other recently committed transactions which may have been in-flight when the transaction was originally endorsed.	具体的には、チャネル内の各ピアは、ブロック内の各トランザクションを検証して、そのトランザクションが必要な組織のピアによってエンドースされていること、そのエンドースメントが一致していること、およびそのトランザクションが最初にエンドースされたときに実行中であった可能性がある他の直近のトランザクションによって無効にされていないことを確認します。
Invalidated transactions are still retained in the immutable block created by the orderer, but they are marked as invalid by the peer and do not update the ledger's state.	無効化されたトランザクションは、ordererによって作成された不変的なブロックに保持されますが、ピアによって無効としてマークされ、台帳の状態は更新されません。
The second role of an ordering node is to distribute blocks to peers.	オーダリングノードの2番目の役割は、ブロックをピアに配布することです。
In this example, orderer O1 distributes block B2 to peer P1 and peer P2.	この例では、ordererのO1はブロックB2をピアP1およびピアP2に配布します。
Peer P1 processes block B2, resulting in a new block being added to ledger L1 on P1.	ピアP1はブロックB2を処理し、P1の台帳L1に新しいブロックが追加されます。
In parallel, peer P2 processes block B2, resulting in a new block being added to ledger L1 on P2.	並行して、ピアP2はブロックB2を処理し、P2の台帳1に新しいブロックが追加されます。
Once this process is complete, the ledger L1 has been consistently updated on peers P1 and P2, and each may inform connected applications that the transaction has been processed.	このプロセスが完了すると、台帳L1はピアP1およびP2上で一貫して更新され、それぞれが、トランザクションが処理されたことを接続するアプリケーションに通知することができます。
In summary, phase three sees the blocks generated by the ordering service applied consistently to the ledger.	要約すると、フェーズ3では、オーダリングサービスによって生成されたブロックが一貫して台帳に適用されていることが確認されます。
The strict ordering of transactions into blocks allows each peer to validate that transaction updates are consistently applied across the blockchain network.	トランザクションをブロックに厳密に順序付けることにより、各ピアは、トランザクション更新がブロックチェーンネットワーク全体に一貫して適用されていることを検証できます。
For a deeper look at phase 3, refer back to the [Peers](../peers/peers.html#phase-3-validation-and-commit) topic.	フェーズ3の詳細については、[Peers](../peers/peers.html#phase-3-validation-and-commit)のトピックを参照してください。
While every ordering service currently available handles transactions and configuration updates the same way, there are nevertheless several different implementations for achieving consensus on the strict ordering of transactions between ordering service nodes.	現在利用可能なすべてのオーダリングサービスは、トランザクションと構成の更新を同じ方法で処理しますが、オーダリングサービスノード間のトランザクションの厳密な順序付けに関する合意を達成するための実装はいくつかあります。
For information about how to stand up an ordering node (regardless of the implementation the node will be used in), check out [our documentation on standing up an ordering node](../orderer_deploy.html).	(ノードが使用される実装に関係なく)オーダリングノードを立てる方法については、[オーダリングノードを立てるためのドキュメント](../orderer_deploy.html)を参照してください。
Raft (recommended)	Raft (推奨)
New as of v1.4.1, Raft is a crash fault tolerant (CFT) ordering service based on an implementation of [Raft protocol](https://raft.github.io/raft.pdf) in [`etcd`](https://coreos.com/etcd/).	v1.4.1で新しく提供されたRaftは、[`etcd`](https://coreos.com/etcd/)における[Raftプロトコル](https://raft.github.io/raft.pdf)の実装に基づくクラッシュ故障耐性(CFT)のオーダリングサービスです。
Raft follows a "leader and follower" model, where a leader node is elected (per channel) and its decisions are replicated by the followers.	Raftは「リーダーとフォロワー」モデルに従い、リーダーノードが(チャネルごとに)選出され、その決定がフォロワーによって複製されます。
Raft ordering services should be easier to set up and manage than Kafka-based ordering services, and their design allows different organizations to contribute nodes to a distributed ordering service.	Raftのオーダリングサービスは、Kafkaベースのオーダリングサービスよりもセットアップと管理が容易であり、その設計により、さまざまな組織が分散オーダリングサービスにノードを提供できるようになりました。
Kafka (deprecated in v2.x)	Kafka (v2.xでは非推奨)
Similar to Raft-based ordering, Apache Kafka is a CFT implementation that uses a "leader and follower" node configuration.	Raftベースのオーダリングと同様に、Apache Kafkaは「リーダーとフォロワー」のノード構成を使用するCFT実装です。
Kafka utilizes a ZooKeeper ensemble for management purposes.	KafkaはZooKeeperアンサンブルを管理目的で利用しています。
The Kafka based ordering service has been available since Fabric v1.0, but many users may find the additional administrative overhead of managing a Kafka cluster intimidating or undesirable.	KafkaベースのオーダーリングサービスはFabric v1.0から提供されていますが、多くのユーザーは、Kafkaクラスタを管理するための追加の管理オーバーヘッドを、大変で望ましくないと感じていたかもしれません。
Solo (deprecated in v2.x)	Solo (v2.xでは非推奨)
The Solo implementation of the ordering service is intended for test only and consists only of a single ordering node.	オーダリングサービスのSolo実装はテストのみを目的としており、単一のオーダリングノードのみで構成されています。
It has been deprecated and may be removed entirely in a future release.	推奨されておらず、将来のリリースで完全に削除される可能性があります。
Existing users of Solo should move to a single node Raft network for equivalent function.	Soloの既存のユーザーは、同等の機能を実装するために単一ノードのRaftネットワークに移行する必要があります。
For information on how to configure a Raft ordering service, check out our [documentation on configuring a Raft ordering service](../raft_configuration.html).	Raftオーダリングサービスの設定方法については、[Raftオーダリングサービスの設定に関するドキュメント](../raft_configuration.html)を参照してください。
The go-to ordering service choice for production networks, the Fabric implementation of the established Raft protocol uses a "leader and follower" model, in which a leader is dynamically elected among the ordering nodes in a channel (this collection of nodes is known as the "consenter set"), and that leader replicates messages to the follower nodes.	本番ネットワーク向けの望ましいオーダリングサービスの選択肢として、確立されたRaftプロトコルのFabric実装は、チャネル内のオーダリングノード(このノードの集合は"consent set"として知られている)の中でリーダーが動的に選出され、リーダーがメッセージをフォロワーノードに複製する"leader and follower"モデルを使用します。
Because the system can sustain the loss of nodes, including leader nodes, as long as there is a majority of ordering nodes (what's known as a "quorum") remaining, Raft is said to be "crash fault tolerant" (CFT).	オーダリングノードの大部分(「クォーラム」として知られる)が残っている限り、システムは、リーダーノードを含むノードの損失に耐えることができるので、Raftは「クラッシュ故障耐性」(CFT)があると言われます。
In other words, if there are three nodes in a channel, it can withstand the loss of one node (leaving two remaining).	つまり、1つのチャネルに3つのノードがある場合、1つのノードの損失に耐えることができます(2つのノードが残ります)。
If you have five nodes in a channel, you can lose two nodes (leaving three remaining nodes).	チャネルに5つのノードがある場合、2つのノードの損失に耐えることが出来ます(残りの3つのノードで稼働します)。
From the perspective of the service they provide to a network or a channel, Raft and the existing Kafka-based ordering service (which we'll talk about later) are similar.	ネットワークやチャネルに提供するサービスの観点からは、Raftと既存のKafkaベースのオーダリングサービス(後で説明します)は似ています。
They're both CFT ordering services using the leader and follower design.	どちらもリーダーとフォロワーの構成を利用するCFTオーダリングサービスです。
If you are an application developer, smart contract developer, or peer administrator, you will not notice a functional difference between an ordering service based on Raft versus Kafka.	アプリケーション開発者、スマートコントラクト開発者、またはピア管理者であれば、RaftベースのオーダリングサービスとKafkaベースのオーダリングサービスの機能的な違いに気付くことはないでしょう。
However, there are a few major differences worth considering, especially if you intend to manage an ordering service:	しかしながら、特にオーダリングサービスを管理する場合は、考慮すべき重要な違いがいくつかあります：
Raft is easier to set up.	Raftの方が構築が簡単です。
Although Kafka has many admirers, even those admirers will (usually) admit that deploying a Kafka cluster and its ZooKeeper ensemble can be tricky, requiring a high level of expertise in Kafka infrastructure and settings.	Kafkaには多くのファンがいるが、彼らでさえ、KafkaクラスターとそのZooKeeperアンサンブルをデプロイするのは難しいことがあり、Kafkaのインフラと設定に高度な専門知識が必要であることをしばしば認めています。
Additionally, there are many more components to manage with Kafka than with Raft, which means that there are more places where things can go wrong.	さらに、RaftよりもKafkaの方が管理すべきコンポーネントの数が多いため、問題が発生する可能性のある箇所が多くなります。
And Kafka has its own versions, which must be coordinated with your orderers.	Kafkaには独自のバージョンがあり、ordererのバージョンと調整する必要があります。
With Raft, everything is embedded into your ordering node.	Raftでは、すべてがオーダリングノードに組み込まれています。
Kafka and Zookeeper are not designed to be run across large networks.	KafkaとZookeeperは、大規模なネットワークを跨いで稼働するようには設計されていません。
While Kafka is CFT, it should be run in a tight group of hosts.	KafkaはCFTですが、緊密なホストグループで実行する必要があります。
This means that practically speaking you need to have one organization run the Kafka cluster.	つまり、実際には1つの組織でKafkaクラスタを実行する必要があります。
Given that, having ordering nodes run by different organizations when using Kafka (which Fabric supports) doesn't give you much in terms of decentralization because the nodes will all go to the same Kafka cluster which is under the control of a single organization.	そうなると、(Fabricがサポートする)Kafkaを使用する際に、異なる組織によって実行されるオーダリングノードを持つことについては、単一組織の制御下にある同じKafkaクラスタで稼働するため、分散化という点ではあまり意味がないということです。
With Raft, each organization can have its own ordering nodes, participating in the ordering service, which leads to a more decentralized system.	Raftを使用すると、各組織が独自のオーダリングノードを持つことができ、それぞれがオーダリングサービスに参加することで、より分散化されたシステムになります。
Raft is supported natively, which means that users are required to get the requisite images and learn how to use Kafka and ZooKeeper on their own.	Raftはネイティブにサポートされている一方で、KafkaとZookeeperについては、ユーザーは必要なイメージを自身で取得し、これらの使い方を自分で学ぶ必要があります。
Likewise, support for Kafka-related issues is handled through [Apache](https://kafka.apache.org/), the open-source developer of Kafka, not Hyperledger Fabric.	同様に、Kafka関連の問題へのサポートは、Hyperledger Fabricではなく、Kafkaのオープンソース開発者である[Apache](https://kafka.apache.org/)を通じて対応されます。
The Fabric Raft implementation, on the other hand, has been developed and will be supported within the Fabric developer community and its support apparatus.	一方、Fabric Raftの実装は、Fabric開発者コミュニティとそのサポート組織の中で、開発されてきており、またサポートされます。
Where Kafka uses a pool of servers (called "Kafka brokers") and the admin of the orderer organization specifies how many nodes they want to use on a particular channel, Raft allows the users to specify which ordering nodes will be deployed to which channel.	Kafkaがサーバー(「Kafkaブローカー」と呼ばれる)のプールを使用し、orderer組織の管理者が特定のチャネルで使用するノードの数を指定する場合、Raftではユーザーがどのオーダリングノードをどのチャネルにデプロイするかを指定できます。
In this way, peer organizations can make sure that, if they also own an orderer, this node will be made a part of a ordering service of that channel, rather than trusting and depending on a central admin to manage the Kafka nodes.	このようにして、ピア組織は、ordererも所有している場合、このノードがKafkaノードを管理する中央管理者を信頼して依存するのではなく、そのチャネルのオーダリングサービスの一部になることを確実にすることができます。
Raft is the first step toward Fabric's development of a byzantine fault tolerant (BFT) ordering service.	Raftは、BFT(ビザンチン故障耐性)オーダリングサービスに向けた第一歩です。
As we'll see, some decisions in the development of Raft were driven by this.	これから見ていくように、Raftの開発におけるいくつかの決定は、このような方向性により行われました。
If you are interested in BFT, learning how to use Raft should ease the transition.	BFTに興味をお持ちであれば、Raftの使い方を学ぶことで移行が容易になるはずです。
For all of these reasons, support for Kafka-based ordering service is being deprecated in Fabric v2.x.	これらのすべての理由により、Fabric v2.xでは、Kafkaベースのオーダリングサービスのサポートは非推奨となっています。
Note: Similar to Solo and Kafka, a Raft ordering service can lose transactions after acknowledgement of receipt has been sent to a client.	注:SoloやKafkaと同様に、Raftのオーダリングサービスは、受信確認がクライアントに送信された後にトランザクションを失うことがあります。
For example, if the leader crashes at approximately the same time as a follower provides acknowledgement of receipt.	たとえば、フォロワーが受信確認を提供したとほぼ同時にリーダーがクラッシュした場合です。
Therefore, application clients should listen on peers for transaction commit events regardless (to check for transaction validity), but extra care should be taken to ensure that the client also gracefully tolerates a timeout in which the transaction does not get committed in a configured timeframe.	そのため、アプリケーションクライアントは、(トランザクションの妥当性をチェックするために)とにかくピア上でトランザクションコミットイベントをリッスンする必要がありますが、設定された時間枠内でトランザクションがコミットされないタイムアウトをクライアントが許容できるように、特別な注意を払う必要があります。
Depending on the application, it may be desirable to resubmit the transaction or collect a new set of endorsements upon such a timeout.	アプリケーションによっては、このようなタイムアウト時にトランザクションを再送信するか、新しいエンドースメントのセットを収集することが望ましい場合があります。
While Raft offers many of the same features as Kafka --- albeit in a simpler and easier-to-use package --- it functions substantially different under the covers from Kafka and introduces a number of new concepts, or twists on existing concepts, to Fabric.	RaftはKafkaと同じ機能の多くを提供していますが --- よりシンプルで使いやすいパッケージではあります --- 振る舞いはKafkaとは根本的に異なっており、Fabricに対して多くの新しいコンセプトを導入したり、既存のコンセプトにひねりを加えたりしています。
Log entry.	ログエントリ。
The primary unit of work in a Raft ordering service is a "log entry", with the full sequence of such entries known as the "log".	Raftオーダリングサービスにおける作業の基本単位は「ログエントリ」であり、このようなエントリの完全なシーケンスは「ログ」として知られています。
We consider the log consistent if a majority (a quorum, in other words) of members agree on the entries and their order, making the logs on the various orderers replicated.	ここでは、メンバーの過半数(つまりクォーラム)がエントリとその順序を承認し、さまざまなordererにログが複製されている場合に、ログの整合性が保たれていると考えます。
Consenter set.	同意者セット。
The ordering nodes actively participating in the consensus mechanism for a given channel and receiving replicated logs for the channel.	オーダリングノードは、特定のチャネルの共通メカニズムに積極的に参加し、そのチャネルの複製ログを受信します。
This can be all of the nodes available (either in a single cluster or in multiple clusters contributing to the system channel), or a subset of those nodes.	これは、使用可能なすべてのノード(単一のクラスタまたはシステムチャネルに寄与する複数のクラスタ)、またはそれらのノードのサブセットです。
Finite-State Machine (FSM).	有限状態ステートマシン (FSM)。
Every ordering node in Raft has an FSM and collectively they're used to ensure that the sequence of logs in the various ordering nodes is deterministic (written in the same sequence).	RaftのすべてのオーダリングノードはFSMを持ち、それらは集合的に、様々なオーダリングノードのログのシーケンスが決定的であることを保証するために使われます(同じシーケンスで書かれます)。
Quorum.	クォーラム。
Describes the minimum number of consenters that need to affirm a proposal so that transactions can be ordered.	トランザクションを順序付けできるように、提案を確認する必要がある同意者の最小数を記述します。
For every consenter set, this is a majority of nodes.	それぞれの同意者セットについて、これは大多数のノード数となります。
In a cluster with five nodes, three must be available for there to be a quorum.	5つのノードを持つクラスタでは、クォーラムを確保するためには3つのノードが使用可能である必要があります。
If a quorum of nodes is unavailable for any reason, the ordering service cluster becomes unavailable for both read and write operations on the channel, and no new logs can be committed.	何らかの理由でノードのクォーラムが使用できない場合、オーダリングサービスクラスタはチャネル上の読み取りと書き込み操作の両方に使用できなくなり、新しいログはコミットされません。
Leader.	リーダー。
This is not a new concept --- Kafka also uses leaders, as we've said --- but it's critical to understand that at any given time, a channel's consenter set elects a single node to be the leader (we'll describe how this happens in Raft later).	これは新しい概念ではありません --- Kafkaはすでに述べたようにリーダーを使用しています --- が、チャネルの同意者セットが常に1つのノードをリーダーとして選択することを理解することは重要です(これが、Raftにおいて、これがどのように起こるかについては後で説明します)。
The leader is responsible for ingesting new log entries, replicating them to follower ordering nodes, and managing when an entry is considered committed.	リーダーは、新しいログエントリを取り込み、それをフォロワーノードに複製し、エントリーがコミットされたと見なされるタイミングを管理します。
This is not a special type of orderer.	これは特別な種類のordererではありません。
It is only a role that an orderer may have at certain times, and then not others, as circumstances determine.	これは、ordererが特定の時点で持つことができる役割だけであり、状況によって決まる他の役割ではありません。
Follower.	フォロワー。
Again, not a new concept, but what's critical to understand about followers is that the followers receive the logs from the leader and replicate them deterministically, ensuring that logs remain consistent.	繰り返しになりますが、これは新しい概念ではありませんが、フォロワーについて理解するために重要なことは、フォロワーがリーダーからログを受信し、ログの一貫性を維持しながら決定的に複製することです。
As we'll see in our section on leader election, the followers also receive "heartbeat" messages from the leader.	リーダー選出のセクションで説明するように、フォロワーはリーダーから「ハートビート」メッセージも受け取ります。
In the event that the leader stops sending those message for a configurable amount of time, the followers will initiate a leader election and one of them will be elected the new leader.	リーダーがこれらのメッセージの送信を設定可能な時間において停止した場合、フォロワーはリーダーの選択を開始し、そのうちの1人が新しいリーダーとして選択されます。
Every channel runs on a separate instance of the Raft protocol, which allows each instance to elect a different leader.	すべてのチャネルはRaftプロトコルの個別のインスタンス上で動作し、各インスタンスが異なるリーダーを選択できるようにします。
This configuration also allows further decentralization of the service in use cases where clusters are made up of ordering nodes controlled by different organizations.	また、この構成では、クラスタが異なる組織によって制御されるオーダリングノードで構成されている場合に、サービスをさらに分散化できます。
While all Raft nodes must be part of the system channel, they do not necessarily have to be part of all application channels.	すべてのRaftノードはシステムチャネルの一部である必要がありますが、必ずしもすべてのアプリケーションチャネルの一部である必要はありません。
Channel creators (and channel admins) have the ability to pick a subset of the available orderers and to add or remove ordering nodes as needed (as long as only a single node is added or removed at a time).	チャネル作成者(およびチャネル管理者)は、利用可能なordererのサブセットを選択し、必要に応じてオーダリングノードを追加または削除できます(一度に追加または削除されるノードが1つだけの場合)。
While this configuration creates more overhead in the form of redundant heartbeat messages and goroutines, it lays necessary groundwork for BFT.	この設定では、冗長なハートビートメッセージとgoroutineの形でより多くのオーバーヘッドが発生しますが、BFTに必要な基礎が築かれます。
In Raft, transactions (in the form of proposals or configuration updates) are automatically routed by the ordering node that receives the transaction to the current leader of that channel.	Raftでは、トランザクション(提案または設定更新の形式)は、トランザクションを受信するオーダリングノードによって、そのチャネルの現在のリーダーに自動的にルーティングされます。
This means that peers and applications do not need to know who the leader node is at any particular time.	つまり、ピアやアプリケーションは、どの時点でもリーダーノードが誰であるかを知る必要はありません。
Only the ordering nodes need to know.	オーダリングノードのみが知っていればよいということです。
When the orderer validation checks have been completed, the transactions are ordered, packaged into blocks, consented on, and distributed, as described in phase two of our transaction flow.	Ordererの妥当性検査が完了すると、トランザクションフローのフェーズ2で説明したように、トランザクションが順序付けされ、ブロックにパッケージ化され、承諾され、配布されます。
Although the process of electing a leader happens within the orderer's internal processes, it's worth noting how the process works.	リーダーを選出するプロセスはordererの内部プロセスの中で行われますが、このプロセスがどのように機能するかは注目に値します。
Raft nodes are always in one of three states: follower, candidate, or leader.	Raftノードは常に、フォロワー(follower)、候補(candidate)、リーダー(leader)の3つの状態のいずれかになります。
All nodes initially start out as a follower.	すべてのノードは、最初はフォロワーとして開始されます。
In this state, they can accept log entries from a leader (if one has been elected), or cast votes for leader.	この状態では、リーダー(選出されている場合)からログエントリを受け入れたり、リーダーに投票したりできます。
If no log entries or heartbeats are received for a set amount of time (for example, five seconds), nodes self-promote to the candidate state.	設定された時間(5秒など)、ログエントリまたはハートビートを受信しなかった場合、ノードは候補の状態に自己昇格します。
In the candidate state, nodes request votes from other nodes.	候補状態では、ノードは他のノードからの投票を要求します。
If a candidate receives a quorum of votes, then it is promoted to a leader.	候補者が定足数を獲得すると、リーダーに昇格します。
The leader must accept new log entries and replicate them to the followers.	リーダーは、新しいログエントリを受け入れて、それをフォロワーに複製する必要があります。
For a visual representation of how the leader election process works, check out [The Secret Lives of Data](http://thesecretlivesofdata.com/raft/).	リーダーの選出プロセスの視覚的なイメージについては、[The Secret Lives of Data](http://thesecretlivesofdata.com/raft/)を参照ください。
If an ordering node goes down, how does it get the logs it missed when it is restarted?	オーダリングノードがダウンした場合、再起動時に失われたログはどのようにして取得されるのでしょうか。
While it's possible to keep all logs indefinitely, in order to save disk space, Raft uses a process called "snapshotting", in which users can define how many bytes of data will be kept in the log.	すべてのログを無期限に保存することは可能ですが、ディスクスペースを節約するために、Raftは「スナップショット」と呼ばれるプロセスを使用しており、ログに保存するデータのバイト数をユーザーが定義できます。
This amount of data will conform to a certain number of blocks (which depends on the amount of data in the blocks.	このデータ量は特定の数のブロックを構成します(ブロック内のデータ量に依存します。
Note that only full blocks are stored in a snapshot).	なお、スナップショットには完全なブロックのみが保存されます)。
For example, let's say lagging replica `R1` was just reconnected to the network.	たとえば、遅延したレプリカ`R1`がネットワークに再接続されたとします。
Its latest block is `100`.	最新ブロックは`100`です。
Leader `L` is at block `196`, and is configured to snapshot at amount of data that in this case represents 20 blocks.	リーダー`L`はブロック`196`にあり、この場合は20ブロックを表すデータ量でスナップショットをとるように構成されます。
`R1` would therefore receive block `180` from `L` and then make a `Deliver` request for blocks `101` to `180`.	したがって、`R1`は、`L`からブロック`180`を受信し、ブロック`101`〜`180`に対して`Deliver`リクエストを行います。
Blocks `180` to `196` would then be replicated to `R1` through the normal Raft protocol.	次いで、ブロック`180`〜`196`は、通常のRaftプロトコルを介して`R1`に複製されます。
The other crash fault tolerant ordering service supported by Fabric is an adaptation of a Kafka distributed streaming platform for use as a cluster of ordering nodes.	Fabricがサポートするもう1つのクラッシュ故障耐性のあるオーダリングサービスは、オーダリングノードのクラスタとして使用するためのKafka分散ストリーミングプラットフォームの適用です。
You can read more about Kafka at the [Apache Kafka Web site](https://kafka.apache.org/intro), but at a high level, Kafka uses the same conceptual "leader and follower" configuration used by Raft, in which transactions (which Kafka calls "messages") are replicated from the leader node to the follower nodes.	[Apache Kafka Webサイト](https://kafka.apache.org/intro)でKafkaの詳細を読むことができますが、KafkaはRaftと同じ概念の「リーダーとフォロワー」構成を使用しており、トランザクション(Kafkaは「メッセージ」と呼びます)はリーダーノードからフォロワーノードに複製されます。
In the event the leader node goes down, one of the followers becomes the leader and ordering can continue, ensuring fault tolerance, just as with Raft.	リーダーノードがダウンした場合、フォロワーの1つがリーダーになり、Raftと同様にフォールトトレランスを確保しながら順序付けを続けることができます。
The management of the Kafka cluster, including the coordination of tasks, cluster membership, access control, and controller election, among others, is handled by a ZooKeeper ensemble and its related APIs.	Kafkaクラスタの管理(タスクの調整、クラスタメンバーシップ、アクセス制限、コントローラ選出など)は、ZooKeeperアンサンブルとその関連APIによって処理されます。
Kafka clusters and ZooKeeper ensembles are notoriously tricky to set up, so our documentation assumes a working knowledge of Kafka and ZooKeeper.	KafkaクラスタとZooKeeperのアンサンブルは設定が難しいことで知られているので、本書ではKafkaとZooKeeperの実用的な知識を前提としています。
If you decide to use Kafka without having this expertise, you should complete, at a minimum, the first six steps of the [Kafka Quickstart guide](https://kafka.apache.org/quickstart) before experimenting with the Kafka-based ordering service.	この専門知識を持たずにKafkaを使用することにした場合は、Kafkaベースのオーダリングサービスを試す前に、少なくとも[Kafka Quickstartガイド](https://kafka.apache.org/quickstart)の最初の6つのステップを完了する必要があります。
You can also consult [this sample configuration file](https://github.com/hyperledger/fabric/blob/release-1.1/bddtests/dc-orderer-kafka.yml) for a brief explanation of the sensible defaults for Kafka and ZooKeeper.	また、KafkaとZooKeeperの適切なデフォルトの簡単な説明については、[このサンプル設定ファイル](https://github.com/hyperledger/fabric/blob/release-1.1/bddtests/dc-orderer-kafka.yml)を参照してください。
To learn how to bring up a Kafka-based ordering service, check out [our documentation on Kafka](../kafka.html).	Kafkaベースのオーダリングサービスを開始する方法については、[Kafkaに関する資料](../kafka.html)を参照してください。
In cases where a group of organizations on a channel need to keep data private from other organizations on that channel, they have the option to create a new channel comprising just the organizations who need access to the data.	ある組織のグループが、同じチャネル上の他の組織からデータを秘匿する必要がある場合には、データへのアクセスが必要な組織だけから構成される新しいチャネルを作成することができます。
However, creating separate channels in each of these cases creates additional administrative overhead (maintaining chaincode versions, policies, MSPs, etc), and doesn't allow for use cases in which you want all channel participants to see a transaction while keeping a portion of the data private.	しかし、このようにケースに応じて別のチャネルを作成するのは、追加の管理オーバヘッド(チェーンコードのバージョン、ポリシー、MSPなど）となり、また、全ての参加者にトランザクションを見せつつ、データの一部の秘匿化する必要があるユースケースには対応ができなくなります。
That's why Fabric offers the ability to create private data collections, which allow a defined subset of organizations on a channel the ability to endorse, commit, or query private data without having to create a separate channel.	これが、Fabricがプライベートデータコレクションを提供する理由です。プライベートデータコレクションにより、新たにチャネルを作成する必要なく、チャネル内の組織のサブセットに、プライベートデータのエンドースメント、コミット、あるいはクエリーを行わせることができるのです。
A collection is the combination of two elements:	コレクションは、次の2つの要素の組み合わせです:
1. The actual private data, sent peer-to-peer [via gossip protocol](../gossip.html) to only the organization(s) authorized to see it.	1. 実際のプライベートデータ。そのデータを見る権限のある組織にのみ、[ゴシッププロトコル](../gossip.html)でのpeer-to-peer通信でデータが送信されます。
This data is stored in a private state database on the peers of authorized organizations, which can be accessed from chaincode on these authorized peers.	このデータは、許可された組織のピア内のプライベートステートデータベースに保管され、これら許可されたピア上のチェーンコードからアクセスすることができます。
The ordering service is not involved here and does not see the private data.	オーダリングサービスはここでは関与しないので、プライベートデータを見ることはありません。
Note that because gossip distributes the private data peer-to-peer across authorized organizations, it is required to set up anchor peers on the channel, and configure CORE_PEER_GOSSIP_EXTERNALENDPOINT on each peer, in order to bootstrap cross-organization communication.	ゴシッププロトコルにより、許可された組織間のpeer-to-peer通信でプライベートデータが配布されるので、組織間の通信を開始するため、チャネル内にアンカーピアを設定し、各ピアにCORE_PEER_GOSSIP_EXTERNALENDPOINTを設定する必要があることに注意してください。
2. A hash of that data, which is endorsed, ordered, and written to the ledgers of every peer on the channel.	2. 当該データのハッシュ。このハッシュ値は、エンドースされ、順序付けされ、チャネル上の各ピアの台帳に書き込まれます。
The hash serves as evidence of the transaction and is used for state validation and can be used for audit purposes.	ハッシュはトランザクションの証拠となり、ステートの検証に使われるとともに、監査目的で利用することもできます。
The following diagram illustrates the ledger contents of a peer authorized to have private data and one which is not.	次の図は、プライベートデータを持つ権限があるピアとそうでないピアの台帳の内容を示しています。
Collection members may decide to share the private data with other parties if they get into a dispute or if they want to transfer the asset to a third party.	係争に巻き込まれたり、資産を第3者に譲渡したいといった場合に、コレクションのメンバーはプライベートデータを他のメンバーに共有するようにすることもできます。
The third party can then compute the hash of the private data and see if it matches the state on the channel ledger, proving that the state existed between the collection members at a certain point in time.	その場合、第三者がプライベートデータのハッシュを計算し、それがチャネル台帳のステートと一致するかを確認して、コレクションのメンバー間で共有しているステートが特定の時点で存在していたことを証明することができます。
In some cases, you may decide to have a set of collections each comprised of a single organization.	ケースによっては、単一の組織のみからなるコレクションのセットを定義することもできます。
For example an organization may record private data in their own collection, which could later be shared with other channel members and referenced in chaincode transactions.	例えば、ある組織が自身のコレクションにプライベートデータを記録しておいて、後ほどチャネル内の他のメンバーに共有、チェーンコードトランザクションから参照してもらうということもできます。
We'll see examples of this in the sharing private data topic below.	この具体的な例については、下のSharing private dataのトピックをご参照ください。
Use channels when entire transactions (and ledgers) must be kept confidential within a set of organizations that are members of the channel.	取引(および台帳)全体の秘匿性を、チャネルのメンバーとなっている組織群の間で確保する必要がある場合には、チャネルを使用してください。
Use collections when transactions (and ledgers) must be shared among a set of organizations, but when only a subset of those organizations should have access to some (or all) of the data within a transaction.	取引(および台帳)自体は、特定の組織群の間で共有する必要があるが、トランザクション内のデータの一部(あるいは全部）をこれら組織群の一部メンバーのみで共有する必要がある場合には、コレクションを使用してください。
Additionally, since private data is disseminated peer-to-peer rather than via blocks, use private data collections when transaction data must be kept confidential from ordering service nodes.	さらに、プライベートデータはブロック経由ではなくpeer-to-peerで伝播されるため、オーダリングサービスノードからトランザクションデータを秘匿する(見せたくない)場合には、プライベートデータコレクションを使用してください。
Consider a group of five organizations on a channel who trade produce:	チャネル上で農産物を取引する5つの組織のグループを考えてみましょう：
A Farmer selling his goods abroad	海外で商品を売るFarmer(農家)
A Distributor moving goods abroad	商品を海外に搬送するDistributor(代理店)
A Shipper moving goods between parties	当事者間で実際の商品を移動するShipper(物流会社)
A Wholesaler purchasing goods from distributors	Distributorから商品を購入するWholesaler(卸売業者)
A Retailer purchasing goods from shippers and wholesalers	ShipperおよびWholesalerから商品を購入するRetailer(小売業者)
The Distributor might want to make private transactions with the Farmer and Shipper to keep the terms of the trades confidential from the Wholesaler and the Retailer (so as not to expose the markup they're charging).	Distributorは取引条件をWholesalerとRetailerから秘匿するために、FarmerとShipperとの間でプライベートトランザクションを利用しようとするかもしれません（彼らが値上げをしないようにするために）。
The Distributor may also want to have a separate private data relationship with the Wholesaler because it charges them a lower price than it does the Retailer.	Distributorは、Retailerよりも低価格を請求するために、Wholesalerとの別のプライベートデータの関係を持ちたい場合もあります。
The Wholesaler may also want to have a private data relationship with the Retailer and the Shipper.	Wholesalerは、RetailerおよびShipperとのプライベートデータの関係も必要とする場合があります。
Rather than defining many small channels for each of these relationships, multiple private data collections (PDC) can be defined to share private data between:	これらの関係ごとに多数の小さなチャネルを定義するのではなく、複数のプライベートデータコレクション (PDC) を定義して、以下の様にプライベートデータを共有できます:
1. PDC1: Distributor, Farmer and Shipper	1. PDC1: Distributor, Farmer および Shipper
2. PDC2: Distributor and Wholesaler	2. PDC2: Distributor および Wholesaler
3. PDC3: Wholesaler, Retailer and Shipper	3. PDC3: Wholesaler, Retailer および Shipper
Using this example, peers owned by the Distributor will have multiple private databases inside their ledger which includes the private data from the Distributor, Farmer and Shipper relationship and the Distributor and Wholesaler relationship.	この例を使用すると、Distributorが所有するピアは、台帳内に複数のプライベートデータベースを持ちます。このデータベースには、Distributor、Farmer、Shipperの関係およびDistributorとWholesalerとの関係のプライベートデータが含まれます。
When private data collections are referenced in chaincode, the transaction flow is slightly different in order to protect the confidentiality of the private data as transactions are proposed, endorsed, and committed to the ledger.	プライベートデータコレクションがチェーンコードから参照される時には、トランザクションの提案、エンドースメント、および台帳へのコミットという一連のトランザクションフローは、プライベートデータの機密性の保護のため通常とやや異なります。
For details on transaction flows that don't use private data refer to our documentation on [transaction flow](../txflow.html).	プライベートデータを使用しないトランザクションのフローの詳細については、当ドキュメントの[transaction flow](../txflow.html)をご参照ください。
1. The client application submits a proposal request to invoke a chaincode function (reading or writing private data) to endorsing peers which are part of authorized organizations of the collection.	1. クライアントアプリケーションは、コレクションのアクセス許可のある組織内のエンドーシングピアに、チェーンコードの関数(プライベートデータの読み書き)を呼び出すための提案要求を発行します。
The private data, or data used to generate private data in chaincode, is sent in a `transient` field of the proposal.	プライベートデータ、あるいはプライベートデータをチェーンコード内で生成するために使われるデータは提案の`transient`フィールドにて送信されます。
2. The endorsing peers simulate the transaction and store the private data in a `transient data store` (a temporary storage local to the peer).	2. エンドーシングピアはトランザクションをシミュレートし、プライベートデータを`transient data store`(ピアのローカルにある一時ストレージ)に保管します。
They distribute the private data, based on the collection policy, to authorized peers via [gossip](../gossip.html).	エンドーシングピアは、コレクションポリシーに従って[gossip](../gossip.html)により許可されたピアにプライベートデータを配布します。
3. The endorsing peer sends the proposal response back to the client.	3. エンドーシングピアは提案応答をクライアントに返します。
The proposal response includes the endorsed read/write set, which includes public data, as well as a hash of any private data keys and values.	提案応答には、パブリックデータを含むエンドースメント時のread/writeセット、およびプライベートデータのキーと値のハッシュ値を含みます。
No private data is sent back to the client.	プライベートデータはクライアントに返されません。
For more information on how endorsement works with private data, click [here](../private-data-arch.html#endorsement).	プライベートデータを伴うエンドースメントの振る舞いのより詳しい情報については[こちら](../private-data-arch.html#endorsement)をクリックください。
4. The client application submits the transaction (which includes the proposal response with the private data hashes) to the ordering service.	4. クライアントアプリケーションは、トランザクション（プライベートデータのハッシュ付きの提案応答を含む）をオーダリングサービスに送信します。
The transactions with the private data hashes get included in blocks as normal.	プライベートデータのハッシュ付きのトランザクションは、通常どおりブロックに含まれます。
The block with the private data hashes is distributed to all the peers.	プライベートデータハッシュを持つブロックは、すべてのピアに配布されます。
In this way, all peers on the channel can validate transactions with the hashes of the private data in a consistent way, without knowing the actual private data.	このようにして、チャネル上のすべてのピアは、実際のプライベートデータを知らなくても、一貫した方法でプライベートデータのハッシュを使用してトランザクションを検証できます。
5. At block commit time, authorized peers use the collection policy to determine if they are authorized to have access to the private data.	5. ブロックのコミット時には、許可されたピアはコレクションポリシーを使用してプライベートデータへのアクセス権限があるかどうかを判断します。
If they do, they will first check their local `transient data store` to determine if they have already received the private data at chaincode endorsement time.	もし受け取っていなければ、そのピアは最初に、チェーンコードの承認時にプライベートデータをすでに受け取っているかを判断するために、ローカルの`transient data store`を確認します。
If not, they will attempt to pull the private data from another authorized peer.	もし権限がなければ、ピアは他の許可されたピアからプライベートデータを取得しようとします。
Then they will validate the private data against the hashes in the public block and commit the transaction and the block.	その後、ピアはパブリックブロックの中のハッシュとの比較でプライベートデータを検証し、トランザクションとブロックをコミットします。
Upon validation/commit, the private data is moved to their copy of the private state database and private writeset storage.	検証/コミット時には、プライベードデータは、プライベートステートデータベースのコピーとプライベートライトセットストレージに移されます。
The private data is then deleted from the `transient data store`.	その後、プライベートデータは、`transient data store`から削除されます。
In many scenarios private data keys/values in one collection may need to be shared with other channel members or with other private data collections, for example when you need to transact on private data with a channel member or group of channel members who were not included in the original private data collection.	多くのシナリオにおいて、１つのコレクション内のプライベートデータのキー/バリューは、他のチャネルメンバー、あるいは他のプライベートコレクションと共有される必要があるかもしれません。例えば、元々のプライベートデータコレクションに含まれていない単一の、あるいは複数のチャネルメンバーとプライベートデータをやりとりする必要がある場合などです。
The receiving parties will typically want to verify the private data against the on-chain hashes as part of the transaction.	データを受領したメンバーは通常、トランザクションの一部であるオンチェーンハッシュを使ってプライベートデータの検証をしたいものです。
There are several aspects of private data collections that enable the sharing and verification of private data:	プライベートデータの共有と検証を可能にするために、プライベートデータコレクションにはいくつかの特徴があります:
First, you don't necessarily have to be a member of a collection to write to a key in a collection, as long as the endorsement policy is satisfied.	第一に、エンドースメントポリシーを満たしている限り、コレクションにキーを書き込むためにコレクションのメンバーである必要はありません。
Endorsement policy can be defined at the chaincode level, key level (using state-based endorsement), or collection level (starting in Fabric v2.0).	エンドースメントポリシーは、チェーンコードレベル、キーレベル（ステートベースのエンドースメントを利用)、あるいはコレクションレベル(Fabric v2.0から提供) で定義できます。
Second, starting in v1.4.2 there is a chaincode API GetPrivateDataHash() that allows chaincode on non-member peers to read the hash value of a private key.	第二に、v1.4.2からはチェーンコードAPIにてGetPrivateDataHash()が提供されており、これにより、メンバーではないピア上のチェーンコードがプライベートキーのハッシュ値を読み取ることが可能です。
This is an important feature as you will see later, because it allows chaincode to verify private data against the on-chain hashes that were created from private data in previous transactions.	これは後ほど説明もしますが、重要な機能です。というのも、これにより、前のトランザクションのプライベートデータから生成されたオンチェーンのハッシュを使ってプライベートデータを検証することをチェーンコードが出来るようになるからです。
This ability to share and verify private data should be considered when designing applications and the associated private data collections.	プライベートデータを共有し検証するこの機能は、アプリケーションと、関連するプライベートデータコレクションを設計する時に留意しておく必要があります。
While you can certainly create sets of multilateral private data collections to share data among various combinations of channel members, this approach may result in a large number of collections that need to be defined.	チャネルメンバーの様々な組み合わせの中でデータを共有する複数のプライベートデータコレクションのセットを作成することももちろん出来ますが、このアプローチは結果的に多数のコレクションを定義する必要が出てしまいます。
Alternatively, consider using a smaller number of private data collections (e.g. one collection per organization, or one collection per pair of organizations), and then sharing private data with other channel members, or with other collections as the need arises.	代わりに、少数のプライベートデータコレクションを使い(例：組織ごとに1コレクション、あるいは組織のペアごとに1コレクション)、そのプライベートデータを他のチャネルメンバー、あるいは他のコレクションと必要に応じて共有する、ということも検討してください。
Starting in Fabric v2.0, implicit organization-specific collections are available for any chaincode to utilize, so that you don't even have to define these per-organization collections when deploying chaincode.	Fabric v2.0からは、暗黙的な組織固有コレクションが全てのチェーンコードから利用可能となり、これによりチェーンコードのデプロイ時にこれら組織単位のコレクションを定義する必要さえなくなりました。
When modeling private data collections per organization, multiple patterns become available for sharing or transferring private data without the overhead of defining many multilateral collections.	プライベートデータコレクションの設計においては、多数の複数組織間のコレクションを定義するというオーバーヘッドなしに、プライベートデータを共有し転送する複数のパターンが利用可能です。
Here are some of the sharing patterns that could be leveraged in chaincode applications:	チェーンコードアプリケーションが利用可能ないくつかの共有パターンを挙げます:
Use a corresponding public key for tracking public state	公開されているステートの追跡に対応する公開鍵の使用
You can optionally have a matching public key for tracking public state (e.g. asset properties, current ownership.	公開されているステート(資産の属性や現在の所有者など)を追跡するために、オプションとして対応する公開鍵を使うことができます。
etc), and for every organization that should have access to the asset's corresponding private data, you can create a private key/value in each organization's private data collection.	また、資産に対応するプライベートデータへのアクセスする必要がある全ての組織について、各組織のプライベートデータコレクションの中にプライベートキー/バリューを作成することができます。
Chaincode access control	チェーンコードのアクセス制御
You can implement access control in your chaincode, to specify which clients can query private data in a collection.	チェーンコードにアクセス制御を実装して、コレクション内のプライベートデータをクエリできるクライアントを指定できます。
For example, store an access control list for a private data collection key or range of keys, then in the chaincode get the client submitter's credentials (using GetCreator() chaincode API or CID library API GetID() or GetMSPID() ), and verify they have access before returning the private data.	例えば、プライベートデータコレクションキーまたはキーの範囲のアクセスコントロールリストを保存してから、(GetCreator()チェーンコードAPIまたはCIDライブラリAPIのGetID()またはGetMSPID()を使用して)クライアント送信者の資格情報をチェーンコード内で取得し、プライベートデータをクライアントに返す前にアクセス権があるかどうかを確認します。
Similarly you could require a client to pass a passphrase into chaincode, which must match a passphrase stored at the key level, in order to access the private data.	同様に、パスフレーズをチェーンコードに渡すようにクライアントに要求することもできます。プライベートデータにアクセスするには、パスフレーズがキーレベルで保存されているパスフレーズと一致している必要があります。
Note, this pattern can also be used to restrict client access to public state data.	このパターンは、公開されているステートデータへのクライアントからのアクセスを制限するためにも使用できます。
Sharing private data out of band	Fabricネットワーク外でプライベートデータを共有
As an off-chain option, you could share private data out of band with other organizations, and they can hash the key/value to verify it matches the on-chain hash by using GetPrivateDataHash() chaincode API.	オフチェーンを利用するオプションとして、プライベートデータをFabricネットワーク外で他の組織と共有し、GetPrivateDataHash()チェーンコードAPIを使用してキー/値をハッシュし、それがオンチェーンハッシュと一致することを確認できます。
For example, an organization that wishes to purchase an asset from you may want to verify an asset's properties and that you are the legitimate owner by checking the on-chain hash, prior to agreeing to the purchase.	例えば、資産を購入したい組織は、購入に同意する前に、オンチェーンハッシュをチェックして、資産の属性と正当な所有者であることを確認できます。
Sharing private data with other collections	他のコレクションとプライベートデータを共有
You could 'share' the private data on-chain with chaincode that creates a matching key/value in the other organization's private data collection.	チェーン上のプライベートデータを、他の組織のプライベートデータコレクションと一致するキー/バリューを作成するチェーンコードと「共有」することができます。
You'd pass the private data key/value to chaincode via transient field, and the chaincode could confirm a hash of the passed private data matches the on-chain hash from your collection using GetPrivateDataHash(), and then write the private data to the other organization's private data collection.	一時フィールドを介してプライベートデータのキー/バリューをチェーンコードに渡すと、チェーンコードはGetPrivateDataHash()を使用して、渡されたプライベートデータのハッシュがコレクションのチェーン上のハッシュと一致することを確認し、そのプライベートデータを他の組織のプライベートデータコレクションに書き込むことができます。
Transferring private data to other collections	他のコレクションへのプライベートデータの転送
You could 'transfer' the private data with chaincode that deletes the private data key in your collection, and creates it in another organization's collection.	コレクション内のプライベートデータキーを削除し、別の組織のコレクションにキーを作成するチェーンコードを使用して、プライベートデータを「転送」することができます。
Again, use the transient field to pass the private data upon chaincode invoke, and in the chaincode use GetPrivateDataHash() to confirm that the data exists in your private data collection, before deleting the key from your collection and creating the key in another organization's collection.	ここでも、一時フィールドを使用して、チェーンコードを起動したときにプライベートデータを渡し、チェーンコードでGetPrivateDataHash()を使用してプライベートデータコレクションにデータが存在することを確認してから、コレクションからキーを削除し、別の組織のコレクションにてキーを作成します。
To ensure that a transaction always deletes from one collection and adds to another collection, you may want to require endorsements from additional parties, such as a regulator or auditor.	トランザクションが常に1つのコレクションから削除され、別のコレクションに追加されるようにするには、規制機関や監査人など、他の関係者からの承認を必要とする場合があります。
Using private data for transaction approval	トランザクション承認のためのプライベートデータの利用
If you want to get a counterparty's approval for a transaction before it is completed (e.g. an on-chain record that they agree to purchase an asset for a certain price), the chaincode can require them to 'pre-approve' the transaction, by either writing a private key to their private data collection or your collection, which the chaincode will then check using GetPrivateDataHash().	トランザクションが完了する前にトランザクションの相手の承認を得たい場合(例えば、彼らがある価格で資産を購入することに同意するというオンチェーンレコード)、チェーンコードは、彼らのプライベートデータコレクションかあなたのコレクションのいずれかにプライベートキーを書き込み、チェーンコードがGetPrivateDataHash()を使用してチェックすることで、彼らにトランザクションの「事前承認」を要求することができます。
In fact, this is exactly the same mechanism that the built-in lifecycle system chaincode uses to ensure organizations agree to a chaincode definition before it is committed to a channel.	実際、これは、チェーンコードの定義がチャネルにコミットされる前に、組織がその定義に同意することを保証するために、ビルトインされているライフサイクルシステムチェーンコードが使用しているのと全く同じメカニズムです。
Starting with Fabric v2.0, this pattern becomes more powerful with collection-level endorsement policies, to ensure that the chaincode is executed and endorsed on the collection owner's own trusted peer.	Fabric v2.0以降、このパターンは、コレクションレベルのエンドースメントポリシーによってさらに強力になり、コレクションオーナー自身のトラステッドピアにてチェーンコードが実行され、承認されることが保証されるようになりました。
Alternatively, a mutually agreed key with a key-level endorsement policy could be used, that is then updated with the pre-approval terms and endorsed on peers from the required organizations.	あるいは、キーレベルのエンドースメントポリシーによる相互に合意したキーを使用することができます。これは後で、事前承認条件に基づいて更新され、必要とされる組織のピア上で承認されます。
Keeping transactors private	取引者の秘匿
Variations of the prior pattern can also eliminate leaking the transactors for a given transaction.	前出のパターンの変形により、特定のトランザクションに対する取引者の漏洩を排除することもできます。
For example a buyer indicates agreement to buy on their own collection, then in a subsequent transaction seller references the buyer's private data in their own private data collection.	例えば、買い手は自分のコレクションで購入することに同意することを示し、後続のトランザクションにおいて、売り手は、買い手自身のプライベートデータコレクションで買い手のプライベートデータを参照します。
The proof of transaction with hashed references is recorded on-chain, only the buyer and seller know that they are the transactors	ハッシュ化した参照付きのトランザクションの証明は、オンチェーンに記録され、買い手と売り手だけが自分達が取引主体であることを知っていることになります。
but they can reveal the pre-images if a need-to-know arises, such as in a subsequent transaction with another party who could verify the hashes.	しかし、ハッシュを検証できる別の当事者との後続のトランザクションなどで、知る必要が生じた場合には、事前イメージを明らかにすることができます。
Coupled with the patterns above, it is worth noting that transactions with private data can be bound to the same conditions as regular channel state data, specifically:	上記のパターンに加えて、プライベートデータを使用したトランザクションは、通常のチャネルのステートデータと同様に、具体的には次のような条件に紐付けることできます：
Key level transaction access control	キーレベルのトランザクション・アクセス制御
You can include ownership credentials in a private data value, so that subsequent transactions can verify that the submitter has ownership privilege to share or transfer the data.	プライベートデータ値に所有権資格情報を含めると、後続のトランザクションで、送信者がデータを共有または転送する所有者権限を持っていることを確認できます。
In this case the chaincode would get the submitter's credentials (e.g. using GetCreator() chaincode API or CID library API GetID() or GetMSPID() ), combine it with other private data that gets passed to the chaincode, hash it, and use GetPrivateDataHash() to verify that it matches the on-chain hash before proceeding with the transaction.	この場合、チェーンコードは送信者の資格情報を取得し(例えば、GetCreator()チェーンコードAPIまたはCIDライブラリーAPIであるGetID()またはGetMSPID()を使用して)、それをチェーンコードに渡される他のプライベートデータと組み合わせてハッシュ化し、トランザクションを進める前にGetPrivateDataHash()を使用してオンチェーンのハッシュと一致することを確認します。
Key level endorsement policies	キーレベルのエンドースメントポリシー
And also as with normal channel state data, you can use state-based endorsement to specify which organizations must endorse transactions that share or transfer private data, using SetPrivateDataValidationParameter() chaincode API, for example to specify that only an owner's organization peer, custodian's organization peer, or other third party must endorse such transactions.	また、通常のチャネルのステートデータと同様に、ステートベースのエンドースメントを使用すると、SetPrivateDataValidationParameter()チェーンコードAPIを使用して、プライベートデータを共有または転送するトランザクションをどの組織がエンドースする必要があるかを指定できます。たとえば、所有者の組織ピア、保管者の組織ピア、または他の第3者のみがこのようなトランザクションをエンドースする必要があることを指定できます。
The private data sharing patterns mentioned above can be combined to enable powerful chaincode-based applications.	上記のプライベートデータ共有パターンを組み合わせることで、強力なチェーンコードベースのアプリケーションを実現できます。
For example, consider how an asset transfer scenario could be implemented using per-organization private data collections:	例えば、組織別のプライベートデータコレクションを使用して資産移転シナリオを実装する方法を考えてみましょう:
An asset may be tracked by a UUID key in public chaincode state.	資産は、パブリックチェーンコードステートのUUIDキーで追跡できます。
Only the asset's ownership is recorded, nothing else is known about the asset.	資産の所有権のみが記録され、それ以外の資産に関する情報は記録されません。
The chaincode will require that any transfer request must originate from the owning client, and the key is bound by state-based endorsement requiring that a peer from the owner's organization and a regulator's organization must endorse any transfer requests.	チェーンコードは、いかなる移転要求も資産を所有するクライアントから発行されなければならず、キーは、所有者の組織と規制機関の組織のピアが、いかなる移転要求も承認しなければならないことを要求するステートベースのエンドースメントに関連付けられます。
The asset owner's private data collection contains the private details about the asset, keyed by a hash of the UUID.	資産所有者のプライベートデータコレクションには、UUIDのハッシュがキーとして設定された、資産に関するプライベートデータの詳細が含まれます。
Other organizations and the ordering service will only see a hash of the asset details.	他の組織とオーダリングサービスでは、資産の詳細のハッシュのみを照会できます。
Let's assume the regulator is a member of each collection as well, and therefore persists the private data, although this need not be the case.	必ずしもそうである必要はありませんが、規制機関も各コレクションのメンバーであり、したがってプライベートデータを保管すると仮定しましょう
A transaction to trade the asset would unfold as follows:	資産を取引するトランザクションは、次のように動作します:
1. Off-chain, the owner and a potential buyer strike a deal to trade the asset for a certain price.	1. オフチェーンにて、所有者と潜在的な買い手が、資産を特定の価格で取引する契約を結びます。
2. The seller provides proof of their ownership, by either passing the private details out of band, or by providing the buyer with credentials to query the private data on their node or the regulator's node.	2. 売り手は、プライベートデータの詳細をFabricネットワーク外で渡すか、買い手のノードまたは規制機関のノード上のプライベートデータを照会するための資格情報を買い手に提供することによって、所有権の証明を提供します。
3. Buyer verifies a hash of the private details matches the on-chain public hash.	3. 買い手は、プライベートデータの詳細のハッシュがオンチェーンの公開ハッシュと一致することを確認します。
4. The buyer invokes chaincode to record their bid details in their own private data collection.	4. 買い手はチェーンコードを呼び出して、入札の詳細を自身のプライベートデータコレクションに記録します。
The chaincode is invoked on buyer's peer, and potentially on regulator's peer if required by the collection endorsement policy.	買い手のピアでチェーンコードが呼び出され、コレクションエンドースメントポリシーによって要求されている場合には、規制機関のピアでチェーンコードが呼び出される可能性があります。
5. The current owner (seller) invokes chaincode to sell and transfer the asset, passing in the private details and bid information.	5. 現在の所有者(売り手)は、チェーンコードを呼び出して資産を販売および譲渡し、プライベートデータの詳細および入札情報を渡します。
The chaincode is invoked on peers of the seller, buyer, and regulator, in order to meet the endorsement policy of the public key, as well as the endorsement policies of the buyer and seller private data collections.	チェーンコードは、パブリックなキーのエンドースメントポリシー、ならびに買い手と売り手のプライベートデータコレクションのエンドースメントポリシーを満たすよう、売り手、買い手、および規制機関のピアにて起動します。
6. The chaincode verifies that the submitting client is the owner, verifies the private details against the hash in the seller's collection, and verifies the bid details against the hash in the buyer's collection.	6. チェーンコードは、送信クライアントが所有者であることを確認し、売り手のコレクションのハッシュに対してプライベートデータの詳細を確認し、買い手のコレクションのハッシュに対して入札詳細を確認します。
The chaincode then writes the proposed updates for the public key (setting ownership to the buyer, and setting endorsement policy to be the buying organization and regulator), writes the private details to the buyer's private data collection, and potentially deletes the private details from seller's collection.	次に、チェーンコードは、パブリックなキーに対する提案された更新を書き込み(買い手に所有権を設定し、買い手の組織および規制機関としてエンドースメントポリシーを設定)、買い手のプライベートデータコレクションにプライベートデータの詳細を書き込み、場合によっては、売り手のコレクションからプライベートデータの詳細を削除します。
Prior to final endorsement, the endorsing peers ensure private data is disseminated to any other authorized peers of the seller and regulator.	最終的なエンドースメントの前に、エンドーシングピアは、権限を持つ売り手と規制機関のすべてのピアにプライベートデータが確実に配布されるようにします。
7. The seller submits the transaction with the public data and private data hashes for ordering, and it is distributed to all channel peers in a block.	7. 売り手は、オーダリングサービスにパブリックデータおよびプライベートデータのハッシュを付加してトランザクションを送信し、そのトランザクションはブロックに含まれる形で、チャネル内の全てのピアに配布されます。
8. Each peer's block validation logic will consistently verify the endorsement policy was met (buyer, seller, regulator all endorsed), and verify that public and private state that was read in the chaincode has not been modified by any other transaction since chaincode execution.	8. 各ピアのブロック検証ロジックは、エンドースメントポリシーが満たされたこと(買い手、売り手、規制機関のすべてがエンドースしたこと)を一貫して検証し、チェーンコードで読み取られたパブリックおよびプライベートのステートが、チェーンコードの実行後に他のトランザクションによって変更されていないことを検証します。
9. All peers commit the transaction as valid since it passed validation checks.	9. すべてのピアは、検証チェックを通過したため、トランザクションを有効なものとしてコミットします。
Buyer peers and regulator peers retrieve the private data from other authorized peers if they did not receive it at endorsement time, and persist the private data in their private data state database (assuming the private data matched the hashes from the transaction).	売り手のピアおよび規制機関のピアは、エンドースメント時にプライベートデータを受信していなかった場合、他の承認されたピアからプライベートデータを取得し、そのプライベートデータを自身のプライベートデータのステートデータベースに保持します(プライベートデータがトランザクションのハッシュと一致すると仮定します)。
10. With the transaction completed, the asset has been transferred, and other channel members interested in the asset may query the history of the public key to understand its provenance, but will not have access to any private details unless an owner shares it on a need-to-know basis.	10. トランザクションが完了すると、資産は譲渡され、資産に関心を持つ他のチャネルメンバーは、公開鍵の履歴を照会してその出所を把握することができます。しかし、所有者が必要に応じてそれを共有しない限り、プライベートデータの詳細にアクセスすることはできません。
The basic asset transfer scenario could be extended for other considerations, for example the transfer chaincode could verify that a payment record is available to satisfy payment versus delivery requirements, or verify that a bank has submitted a letter of credit, prior to the execution of the transfer chaincode.	基本的な資産移転シナリオは、他の考慮事項にも拡張することができます。例えば、移転のチェーンコードは、実行前に、支払対引渡の要件を満たすために支払記録が利用可能であることを検証することができたり、銀行が信用状を提出したことを検証することができます。
And instead of transactors directly hosting peers, they could transact through custodian organizations who are running peers.	また、取引者が直接ピアを所有する代わりに、ピアを所有している保管組織を通じてトランザクションを実行することもできます。
For very sensitive data, even the parties sharing the private data might want --- or might be required by government regulations --- to periodically "purge" the data on their peers, leaving behind a hash of the data on the blockchain to serve as immutable evidence of the private data.	非常に機密性の高いデータの場合、個人データを共有している当事者でさえ、ブロックチェーン上にデータのハッシュを残し、個人データの不変の証拠として機能させながら、定期的にピア上のデータを「パージ」(消去)することを望むかもしれないし、行政の規制によってパージを要求されるかもしれません。
In some of these cases, the private data only needs to exist on the peer's private database until it can be replicated into a database external to the peer's blockchain.	このような場合、いくつかのケースでは、プライベートデータは、ピアのブロックチェーンの外部のデータベースに複製されるようになるまでの間のみ、ピアのプライベートデータベースに存在する必要があります。
The data might also only need to exist on the peers until a chaincode business process is done with it (trade settled, contract fulfilled, etc).	データは、チェーンコードビジネスプロセス(取引の決済、契約の履行など)が完了するまで、ピア上に存在していればよい場合もあります。
To support these use cases, private data can be purged if it has not been modified for a configurable number of blocks.	これらの使用例をサポートするために、設定したブロック数にわたってプライベートデータが変更されていない場合は、プライベートデータをパージできます。
Purged private data cannot be queried from chaincode, and is not available to other requesting peers.	パージされたプライベートデータは、チェーンコードから照会できません。また、他の要求元ピアからは使用できません。
For more details on collection definitions, and other low level information about private data and collections, refer to the [private data reference topic](../private-data-arch.html).	コレクション定義の詳細、およびプライベートデータとコレクションに関するその他のローレベルの情報については、[private data reference topic](../private-data-arch.html)を参照してください。
**Audience**: Channel administrators, node administrators	**対象読者**: チャネル管理者、ノード管理者
Note: this is an advanced Fabric concept that is not necessary for new users or application developers to understand.	注意: これは、新しいユーザーやアプリケーション開発者が理解する必要のない高度なFabricの概念です。
However, as channels and networks mature, understanding and managing capabilities becomes vital.	ただし、チャネルやネットワークが成熟するにつれて、ケーパビリティの理解と管理が不可欠になります。
Furthermore, it is important to recognize that updating capabilities is a different, though often related, process to upgrading nodes.	さらに、アップデートケーパビリティは、ノードのアップグレードとは別のプロセスですが、関連することが多いプロセスであることを認識することも重要です。
We'll describe this in detail in this topic.	この点については、このトピックで詳しく説明します。
Because Fabric is a distributed system that will usually involve multiple organizations, it is possible (and typical) that different versions of Fabric code will exist on different nodes within the network as well as on the channels in that network.	Fabricは通常、複数の組織が関与する分散システムであるため、異なるバージョンのFabricコードが、ネットワーク内の異なるノードおよびそのネットワーク内のチャネルに存在する可能性があります。
Fabric allows this --- it is not necessary for every peer and ordering node to be at the same version level.	Fabricでは、すべてのピアとオーダリングサービスが同じバージョンレベルである必要はありません。
In fact, supporting different version levels is what enables rolling upgrades of Fabric nodes.	実際、異なるバージョンレベルをサポートすることで、Fabricノードのローリングアップグレードが可能になります。
What is important is that networks and channels process things in the same way, creating deterministic results for things like channel configuration updates and chaincode invocations.	重要なのは、ネットワークとチャネルが同じ方法で処理し、チャネル設定の更新やチェーンコード呼び出しなどの決定的な結果を生成することです。
Without deterministic results, one peer on a channel might invalidate a transaction while another peer may validate it.	結果が決定的でなければ、チャネル上のあるピアがトランザクションを正当としない(無効)一方で、別のピアはトランザクションを正当とするかもしれません。
To that end, Fabric defines levels of what are called "capabilities".	そのために、Fabricは「ケーパビリティ(capabilities)」と呼ばれるレベルを定義します。
These capabilities, which are defined in the configuration of each channel, ensure determinism by defining a level at which behaviors produce consistent results.	これらのケーパビリティは、各チャネルの設定で定義され、動作が一貫した結果を生成するレベルを定義することによって決定性を保証します。
As you'll see, these capabilities have versions which are closely related to node binary versions.	これらのケーパビリティには、ノードのバイナリバージョンと密接に関連したバージョンがあります。
Capabilities enable nodes running at different version levels to behave in a compatible and consistent way given the channel configuration at a specific block height.	ケーパビリティにより、異なるバージョンレベルで実行されているノードは、特定のブロックの高さでのチャネル設定を前提として、互換性のある一貫した方法で動作することができます。
You will also see that capabilities exist in many parts of the configuration tree, defined along the lines of administration for particular tasks.	また、特定のタスクを行うための管理領域ごとに定義されたケーパビリティが、設定ツリーの多くの部分に存在することもわかります。
As you'll see, sometimes it is necessary to update your channel to a new capability level to enable a new feature.	これから説明するように、新しい機能を有効にするためには、チャネルを新しいケーパビリティレベルに更新する必要がある場合があります。
If you're familiar with Hyperledger Fabric, you're aware that it follows a typical versioning pattern: v1.1, v1.2.1, v2.0, etc.	Hyperledger Fabricに精通している場合は、Fabricはv1.1、v1.2.1、v2.0などの一般的なバージョン管理パターンに従うことを知っていると思います。
These versions refer to releases and their related binary versions.	これらのバージョンは、リリースおよび関連するバイナリバージョンを指します。
Capabilities follow the same versioning convention.	ケーパビリティは、同じバージョン付け規則に従います。
There are v1.1 capabilities and v1.2 capabilities and 2.0 capabilities and so on.	v1.1のケーパビリティ、v1.2のケーパビリティ、v2.0のケーパビリティなどがあります。
But it's important to note a few distinctions.	しかし、いくつかの違いに注意することが重要です。
There is not necessarily a new capability level with each release.	リリースごとに新しいケーパビリティレベルがあるとは限りません。
The need to establish a new capability is determined on a case by case basis and relies chiefly on the backwards compatibility of new features and older binary versions.	新しいケーパビリティを確立する必要性は、ケースバイケースで判断され、主に新しい機能と古いバイナリバージョンの後方互換性に依存します。
Adding Raft ordering services in v1.4.1, for example, did not change the way either transactions or ordering service functions were handled and thus did not require the establishment of any new capabilities.	例えば、v1.4.1でRaftオーダリングサービスを追加した時も、トランザクションやオーダリングサービス機能の処理方法は変わらないので、新しいケーパビリティを確立する必要はありませんでした。
[Private Data](./private-data/private-data.html), on the other hand, could not be handled by peers before v1.2, requiring the establishment of a v1.2 capability level.	一方で [Private Data](./private-data/private-data.html)はv1.2より前のピアでは処理できず、v1.2のケーパビリティレベルを確立する必要がありました。
Because not every release contains a new feature (or a bug fix) that changes the way transactions are processed, certain releases will not require any new capabilities (for example, v1.4) while others will only have new capabilities at particular levels (such as v1.2 and v1.3).	すべてのリリースにトランザクションの処理方法を変更する新機能(またはバグ修正)が含まれているわけではないため、特定のリリース(v1.4など)では新しいケーパビリティは必要ありませんが、特定のレベル(v1.2やv1.3など)でのみ新しいケーパビリティが必要なリリースもあります。
We'll discuss the "levels" of capabilities and where they reside in the configuration tree later.	ケーパビリティの「レベル」と、それらのケーパビリティが設定ツリーのどこにあるかについては後ほど説明します。
Nodes must be at least at the level of certain capabilities in a channel.	ノードは、少なくともチャネル内の特定のケーパビリティレベルでなければなりません。
When a peer joins a channel, it reads all of the blocks in the ledger sequentially, starting with the genesis block of the channel and continuing through the transaction blocks and any subsequent configuration blocks.	ピアがチャネルに参加すると、台帳内のすべてのブロックが順番に読み取られます。これは、チャネルのジェネシスブロックから始まり、トランザクションブロックおよびそれ以降のすべてのコンフィグレーションブロックにわたって続きます。
If a node, for example a peer, attempts to read a block containing an update to a capability it doesn't understand (for example, a v1.4.x peer trying to read a block containing a v2.0 application capability), the peer will crash.	ピアなどのノードが、認識できないケーパビリティの更新を含むブロックを読み取ろうとした場合(たとえば、v1.4.xピアがv2.0アプリケーションケーパビリティを含むブロックを読み取ろうとした場合)、 ピアはクラッシュします。
This crashing behavior is intentional, as a v1.4.x peer should not attempt validate or commit any transactions past this point.	v1.4.xピアはこの時点を過ぎてもトランザクションの検証やコミットを試行しないため、このクラッシュ動作は意図的なものです。
Before joining a channel, make sure the node is at least the Fabric version (binary) level of the capabilities specified in the channel config relevant to the node.	チャネルに参加する前に、ノードが、そのノードに関連するチャネル設定で指定されたケーパビリティのFabricバージョン(バイナリ)レベル以上であることを確認してください。
We'll discuss which capabilities are relevant to which nodes later.	どのケーパビリティがどのノードに関連するかについては、後で説明します。
However, because no user wants their nodes to crash, it is strongly recommended to update all nodes to the required level (preferably, to the latest release) before attempting to update capabilities.	といっても、ユーザーはノードがクラッシュすることを望んでいないため、ケーパビリティを更新する前に、すべてのノードを必要なレベル(できれば最新リリース)に更新することを強くお勧めします。
This is in line with the default Fabric recommendation to always be at the latest binary and capability levels.	これは、常に最新のバイナリおよびケーパビリティレベルにするというデフォルトのFabricの推奨事項に沿っています。
If users are unable to upgrade their binaries, then capabilities must be left at their lower levels.	ユーザーがバイナリをアップグレードできない場合は、ケーパビリティを下位レベルに残しておく必要があります。
Lower level binaries and capabilities will still work together as they're meant to.	下位レベルのバイナリとケーパビリティは、本来の目的どおりに動作します。
However, keep in mind that it is a best practice to always update to new binaries even if a user chooses not to update their capabilities.	ただし、ユーザーがケーパビリティを更新しないことを選択した場合でも、常に新しいバイナリに更新することをお勧めします。
Because capabilities themselves also include bug-fixes, it is always recommended to update capabilities once the network binaries support them.	ケーパビリティ自体にもバグ修正が含まれているため、ネットワークバイナリがケーパビリティをサポートするようになったら更新することをお勧めします。
As we discussed earlier, there is not a single capability level encompassing an entire channel.	すでに説明したように、チャネル全体を網羅する単一のケーパビリティレベルはありません。
Rather, there are three capabilities, each representing an area of administration.	むしろ、3つのケーパビリティがあり、それぞれ管理領域を表しています。
Orderer:	Orderer:
These capabilities govern tasks and processing exclusive to the ordering service.	これらのケーパビリティは、オーダリングサービス専用のタスクと処理を制御します。
Because these capabilities do not involve processes that affect transactions or the peers, updating them falls solely to the ordering service admins (peers do not need to understand orderer capabilities and will therefore not crash no matter what the orderer capability is updated to).	これらのケーパビリティには、トランザクションやピアに影響を与えるプロセスが含まれていないため、これらのケーパビリティの更新は、オーダリングサービスの管理者に委ねられています(ピアはOrdererケーパビリティを理解する必要がないため、Ordererケーパビリティが何に更新されてもクラッシュしません)。
However, as we'll see in the channel section, this does not mean that v1.1 ordering nodes will work on all channels with capability levels below v1.4.2.	ただし、チャネルのセクションで説明するように、これは、v1.1のオーダリングノードがv1.4.2より低いケーパビリティレベルのすべてのチャネルで機能することを意味するわけではありません。
Application:	アプリケーション(Application):
These capabilities govern tasks and processing exclusive to the peers.	これらのケーパビリティは、ピア専用のタスクと処理を制御します。
Because ordering service admins have no role in deciding the nature of transactions between peer organizations, changing this capability level falls exclusively to peer organizations.	オーダリングサービスの管理者は、ピア組織間のトランザクションの性質を決定する役割を持たないため、このケーパビリティレベルの変更は、ピア組織間に限定されます。
For example, Private Data can only be enabled on a channel with the v1.2 (or higher) application group capability enabled.	たとえば、プライベートデータは、v1.2(またはそれ以降)のアプリケーション・グループ・ケーパビリティが有効になっているチャネルでのみ有効にできます。
In the case of Private Data, this is the only capability that must be enabled, as nothing about the way Private Data works requires a change to channel administration or the way the ordering service processes transactions.	プライベートデータの場合、チャネル管理やオーダリングサービスによるトランザクションの処理方法を変更する必要がないため、これが唯一有効にしなければいけないケーパビリティとなります。
Channel:	チャネル（Channel）:
This grouping encompasses tasks that are jointly administered by the peer organizations and the ordering service.	このグループには、ピア組織とオーダリングサービスが共同で管理するタスクが含まれます。
For example, this is the capability that defines the level at which channel configuration updates, which are initiated by peer organizations and orchestrated by the ordering service, are processed.	たとえば、ピア組織によって開始されオーダリングサービスによってオーケストレーションされるチャネル設定の更新が処理されるレベルを定義するケーパビリティです。
On a practical level, this grouping defines the minimum level for all of the binaries in a channel, as both ordering nodes and peers must be at least at the binary level corresponding to this capability in order to process the capability.	実用的なレベルでは、このグループは、チャネル内のすべてのバイナリの最小レベルを定義します。これは、オーダリングサービスとピアの両方が、ケーパビリティを処理するために、少なくともこのケーパビリティに対応するバイナリ・レベルでなければならないためです。
The orderer and channel capabilities of a channel are inherited by default from the ordering system channel, where modifying them are the exclusive purview of ordering service admins.	チャネルのOrdererケーパビリティとチャネルケーパビリティは、デフォルトではオーダリングシステムチャネルから継承されます。このチャネルの変更は、オーダリングサービス管理者だけの権限です。
As a result, peer organizations should inspect the genesis block of a channel prior to joining their peers to that channel.	そのため、ピア組織は、ピアをチャネルに参加させる前に、チャネルのジェネシスブロックを検査する必要があります。
Although the channel capability is administered by the orderers in the orderer system channel (just as the consortium membership is), it is typical and expected that the ordering admins will coordinate with the consortium admins to ensure that the channel capability is only upgraded when the consortium is ready for it.	チャネルケーパビリティは、(コンソーシアムのメンバーシップと同様に)オーダリングシステムチャネルのOrdererによって管理されますが、一般的に、オーダリングサービス管理者は、コンソーシアムの準備ができたときにのみチャネルケーパビリティがアップグレードされるように、コンソーシアムの管理者と調整します。
Because the ordering system channel does not define an application capability, this capability must be specified in the channel profile when creating the genesis block for the channel.	オーダリングシステムチャネルはアプリケーションケーパビリティを定義しないため、チャネルのジェネシスブロックを作成するときに、このケーパビリティをチャネルプロファイルで指定する必要があります。
Take caution when specifying or modifying an application capability.	アプリケーションケーパビリティを指定または変更する場合は注意が必要です。
Because the ordering service does not validate that the capability level exists, it will allow a channel to be created (or modified) to contain, for example, a v1.8 application capability even if no such capability exists.	オーダリングサービスは、ケーパビリティレベルが存在することを検証しないため、そのようなケーパビリティが存在しない場合でも、たとえばv1.8アプリケーションケーパビリティを含むチャネルを作成(または変更)できます。
Any peer attempting to read a configuration block with this capability would, as we have shown, crash, and even if it was possible to modify the channel once again to a valid capability level, it would not matter, as no peer would be able to get past the block with the invalid v1.8 capability.	このケーパビリティを使用してコンフィグレーションブロックを読み取ろうとすると、ピアがクラッシュし、チャネルを再び有効なケーパビリティレベルに変更できたとしても、無効なv1.8のケーパビリティを使用してブロックを通過できるピアがないため、問題にはなりません。
For a full look at the current valid orderer, application, and channel capabilities check out a [sample `configtx.yaml` file](http://github.com/hyperledger/fabric/blob/{BRANCH}/sampleconfig/configtx.yaml), which lists them in the "Capabilities" section.	現在有効なOrderer、アプリケーション、およびチャネルケーパビリティの詳細については、「Capabilities」セクションにリストされている[sample `configtx.yaml` file](http://github.com/hyperledger/fabric/blob/{BRANCH}/sampleconfig/configtx.yaml)を参照してください。
For more specific information about capabilities and where they reside in the channel configuration, check out [defining capability requirements](capability_requirements.html).	ケーパビリティおよびチャネル設定内でのケーパビリティの設定箇所に関する詳細については、[defining capability requirements](capability_requirements.html)を参照してください。
The first Hyperledger Fabric major release since v1.0, Fabric v2.0 delivers important new features and changes for users and operators alike, including support for new application and privacy patterns, enhanced governance around smart contracts, and new options for operating nodes.	v1.0以来のメジャーリリースである、Hyperledger Fabric v2.0は、ユーザーおよび運用者に重要な新機能と変更を提供します。これは、新しいアプリケーションとプライバシーに関するパターンのサポート、スマートコントラクトの管理の強化、ノード運用の新しいオプションなどを含んでいます。
Each v2.x minor release builds on the v2.0 release with minor features, improvements, and bug fixes.	v2.xのマイナーリリースは、v2.0に対して、小規模の機能追加・改善・バグフィックスを行ったものになります。
v2.2 is the first long-term support (LTS) release of Fabric v2.x.	v2.2は、Fabric v2.xの最初の長期サポート(LTS)リリースです。
Fixes will be provided on the v2.2.x release stream until after the next LTS release is announced.	次のLTSのリリースがアナウンスされるまで、v2.2.xのストリームで修正が提供される予定です。
Let's take a look at some of the highlights of the Fabric v2.0 release...	それでは、Fabric v2.0リリースのハイライトをいくつか見ていきましょう。
Fabric v2.0 introduces decentralized governance for smart contracts, with a new process for installing a chaincode on your peers and starting it on a channel.	Fabric v2.0では、スマートコントラクトの非中央集権的な管理が導入されます。これに伴い、チェーンコードのピアへのインストール、チャネルでの利用開始するときの手順が新しくなります。
The new Fabric chaincode lifecycle allows multiple organizations to come to agreement on the parameters of a chaincode, such as the chaincode endorsement policy, before it can be used to interact with the ledger.	新しいFabricのチェーンコード・ライフサイクルでは、エンドースメントポリシーといったチェーンコードのパラメータについて、複数の組織が合意することができます。こののち、台帳とのやり取りのためにそのチェーンコードが使用できるようになります。
The new model offers several improvements over the previous lifecycle:	この新しいモデルは、以前のライフサイクルに比べると、以下のような改善点があります。
Multiple organizations must agree to the parameters of a chaincode	複数の組織がチェーンコードのパラメータについて合意していなければならないこと:
In the release 1.x versions of Fabric, one organization had the ability to set parameters of a chaincode (for instance the endorsement policy) for all other channel members, who only had the power to refuse to install the chaincode and therefore not take part in transactions invoking it.	Fabricのバージョン 1.x では、一つの組織が、他の全てのチャネルのメンバーにも適用されるチェーンコードのパラメータ(例えば、エンドースメントポリシー)を設定することができました。他の組織は、チェーンコードをインストールすることを拒否して、それによって、そのチェーンコードを呼び出すトランザクションに関与しないようにすることしかできませんでした。
The new Fabric chaincode lifecycle is more flexible since it supports both centralized trust models (such as that of the previous lifecycle model) as well as decentralized models requiring a sufficient number of organizations to agree on an endorsement policy and other details before the chaincode becomes active on a channel.	新しいFabricのチェーンコード・ライフサイクルはもっと柔軟であり、中央集権的な信頼モデル(例えば、以前のライフサイクルの場合のもの)も、チェーンコードがあるチャネルで有効になる前に、エンドースメントポリシーやそのほかの詳細について、十分な数の組織の合意を必要とする非中央集権的なモデルもサポートしています。
More deliberate chaincode upgrade process	より慎重なチェーンコードのアップグレード手順:
In the previous chaincode lifecycle, the upgrade transaction could be issued by a single organization, creating a risk for a channel member that had not yet installed the new chaincode.	以前のチェーンコードライフサイクルでは、アップグレードのトランザクションは、一つの組織から発行することができたため、新しいチェーンコードをまだインストールしていないチャネルのメンバーに対するリスクがありました。
The new model allows for a chaincode to be upgraded only after a sufficient number of organizations have approved the upgrade.	新しいモデルでは、チェーンコードのアップグレードは十分な数の組織が承認した場合にのみ行う、ということができます。
Simpler endorsement policy and private data collection updates	よりシンプルなエンドースメントポリシー・プライべートデータコレクションのアップデート:
Fabric lifecycle allows you to change an endorsement policy or private data collection configuration without having to repackage or reinstall the chaincode.	Fabricのライフサイクルでは、エンドースメントポリシーやプライベートデータコレクションの設定の変更を、チェーンコードのパッケージ再作成や再インストールなしに行うことができます。
Users can also take advantage of a new default endorsement policy that requires endorsement from a majority of organizations on the channel.	ユーザーは、過半数の組織からのエンドースメントを必要とする、という新しいデフォルトのエンドースメントポリシーを活用することもできます。
This policy is updated automatically when organizations are added or removed from the channel.	このポリシーは、組織が追加・削除されたときに、自動的に更新されます。
Inspectable chaincode packages	検査可能なチェーンコードパッケージ:
The Fabric lifecycle packages chaincode in easily readable tar files.	Fabricのライフサイクルでは、チェーンコードを、簡単に読むことのできるtarファイルにパッケージします。
This makes it easier to inspect the chaincode package and coordinate installation across multiple organizations.	これによってチェーンコード・パッケージの中身を検査し、複数組織間でのインストールを調整することが容易になります。
Start multiple chaincodes on a channel using one package	一つのチャネルで、同じパッケージを使って複数のチェーンコードを起動すること:
The previous lifecycle defined each chaincode on the channel using a name and version that was specified when the chaincode package was installed.	以前のライフサイクルでは、チェーンコードのインストール時に指定する名前とバージョンによって、各チャネルでチェーンコードが定義されていました。
You can now use a single chaincode package and deploy it multiple times with different names on the same channel or on different channels.	新しいライフサイクルでは、同じ一つのチェーンコードパッケージで、同じチャネルあるいは異なるチャネルで異なる名前で複数回デプロイすることが可能になります。
For example, if you’d like to track different types of assets in their own ‘copy’ of the chaincode.	例えば、異なる種類の資産のトラックを、同じチェーンコードをそれぞれの種類ごとに「コピー」して行いたいときです。
Chaincode packages do not need to be identical across channel members	チェーンコードのパッケージはチャネルメンバーの中で同一である必要がないこと:
Organizations can extend a chaincode for their own use case, for example to perform different validations in the interest of their organization.	各組織は、例えば、組織の関心に応じて異なる検証を行うなど、チェーンコードを組織のユースケースに応じて拡張することができます。
As long as the required number of organizations endorse chaincode transactions with matching results, the transaction will be validated and committed to the ledger.	必須とされている数の組織が、チェーンコードのトランザクションと同一の結果がエンドースしていれば、そのトランザクションは検証ののち台帳にコミットされます。
This also allows organizations to individually roll out minor fixes on their own schedules without requiring the entire network to proceed in lock-step.	また、各組織が、自分のスケジュールで、小規模の修正を個別にロールアウトすることも可能になります。ネットワーク全体で足並みをそろえて行う必要はありません。
For existing Fabric deployments, you can continue to use the prior chaincode lifecycle with Fabric v2.x.	すでにデプロイされているFabricでは、Fabric v2.xでも以前のチェーンコード・ライフサイクルを使い続けることができます。
The new chaincode lifecycle will become effective only when the channel application capability is updated to v2.0.	新しいチェーンコード・ライフサイクルは、チャネルのアプリケーション・ケーパビリティがv2.0にアップデートされたときにのみ有効になります。
See the :doc:`chaincode_lifecycle` concept topic for an overview of the new chaincode lifecycle.	新しいチェーンコード・ライフサイクルの概要については、:doc:`chaincode_lifecycle` のトピックを参照してください。
The same decentralized methods of coming to agreement that underpin the new chaincode lifecycle management can also be used in your own chaincode applications to ensure organizations consent to data transactions before they are committed to the ledger.	新しいチェーンコードライフサイクルを支えている合意に至るための非中央集権的な方法と同じ方法を、チェーンコードアプリケーションでも、組織の同意を得てからデータ・トランザクションが台帳にコミットされるよう保証するために使うこともできます。
Automated checks	自動的なチェック:
As mentioned above, organizations can add automated checks to chaincode functions to validate additional information before endorsing a transaction proposal.	上記でも述べたように、各組織はチェーンコードの関数に、トランザクション提案をエンドースする前に追加の情報の検証を行う自動的なチェックを加えることができます。
Decentralized agreement	非中央集権的な合意:
Human decisions can be modeled into a chaincode process that spans multiple transactions.	人間による決定プロセスを、複数のトランザクションにまたがるチェーンコードのプロセスにモデル化することができます。
The chaincode may require actors from various organizations to indicate their terms and conditions of agreement in a ledger transaction.	そのようなチェーンコードは、様々な組織のアクターに対して、合意の契約条件を台帳へのトランザクションで示すことを要求するかもしれません。
Then, a final chaincode proposal can verify that the conditions from all the individual transactors are met, and "settle" the business transaction with finality across all channel members.	そして、最後のチェーンコード提案で、各トランザクション発行者の条件を満たしていることを確かめ、チャネルのメンバー間での商取引の最終的な「解決」とすることができるでしょう。
For a concrete example of indicating terms and conditions in private, see the asset transfer scenario in the :doc:`private-data/private-data` documentation.	非公開で契約条件を示す例については、:doc:`private-data/private-data` のドキュメントの資産移動のシナリオを参照してください。
Fabric v2.0 also enables new patterns for working with and sharing private data, without the requirement of creating private data collections for all combinations of channel members that may want to transact.	Fabric v2.0は、トランザクションが関与する全てのチャネルメンバーの組み合わせのプライベートデータ・コレクションを作る必要なく、プライベートデータを扱い共有する新しいパターンを可能にします。
Specifically, instead of sharing private data within a collection of multiple members, you may want to share private data across collections, where each collection may include a single organization, or perhaps a single organization along with a regulator or auditor.	具体的には、プライベートデータを、複数のメンバーからなる一つのコレクションの中で共有するのではなく、一つの組織や、あるいは一つの組織と規制機関や監査機関からなるような複数のコレクションにわたって共有することができます。
Several enhancements in Fabric v2.x make these new private data patterns possible:	この新しいプライベートデータのパターンは、Fabric v2.xでの以下の機能強化によって可能になっています。
Sharing and verifying private data	プライベートデータの共有と確認:
When private data is shared with a channel member who is not a member of a collection, or shared with another private data collection that contains one or more channel members (by writing a key to that collection), the receiving parties can utilize the GetPrivateDataHash() chaincode API to verify that the private data matches the on-chain hashes that were created from private data in previous transactions.	プライベートデータが、コレクションのメンバーではないチャネルメンバーと共有されるとき、もしくは、一つまたは複数のチャネルメンバーを含むプライベートデータコレクションとで（そのコレクションのキーに書き込むことで）共有されるとき、受け取った側は、チェーンコードAPIである GetPrivateDataHash() を使うことで、プライベートデータが、チェーン上に存在している、過去のトランザクションでプライベートデータから作られたハッシュ値と一致することを確認することができます。
Collection-level endorsement policies	コレクションレベルのエンドースメントポリシー:
Private data collections can now optionally be defined with an endorsement policy that overrides the chaincode-level endorsement policy for keys within the collection.	プライベートデータ・コレクションは、コレクション内のキーに対して、チェーンコードレベルのエンドースメントポリシーをオーバーライドするエンドースメントポリシーを新たに定義することができます。
This feature can be used to restrict which organizations can write data to a collection, and is what enables the new chaincode lifecycle and chaincode application patterns mentioned earlier.	この機能は、コレクションに対して書き込む組織を制限するのに使うことができ、上記で述べたチェーンコードライフサイクルやチェーンコードアプリケーションのパターンを可能にするものでもあります。
For example, you may have a chaincode endorsement policy that requires a majority of organizations to endorse, but for any given transaction, you may need two transacting organizations to individually endorse their agreement in their own private data collections.	例えば、チェーンコードレベルのエンドースメントポリシーでは、過半数の組織によるエンドースを必要としつつ、あるトランザクションについては、プライベートデータコレクションでの合意についてそれぞれがエンドースするように、二つの関係する組織を必要とすることもできます。
Implicit per-organization collections	暗黙的な組織ごとのコレクション:
If you’d like to utilize per-organization private data patterns, you don’t even need to define the collections when deploying chaincode in Fabric v2.x.	もし組織ごとのプライベートデータのパターンを使いたいのであれば、チェーンコードのデプロイ時にコレクションを定義する必要すらありません。
Implicit organization-specific collections can be used without any upfront definition.	暗黙的な組織独自のコレクションは、特に前もって定義する必要なく使うことができます。
To learn more about the new private data patterns, see the :doc:`private-data/private-data` (conceptual documentation).	プライベートデータのパターンについて知りたいときは、:doc:`private-data/private-data` (概念の解説ドキュメント)を参照してください。
For details about private data collection configuration and implicit collections, see the :doc:`private-data-arch` (reference documentation).	プライベートデータ・コレクションの設定や暗黙的なコレクションについては、:doc:`private-data-arch` (リファレンス)を参照してください。
The external chaincode launcher feature empowers operators to build and launch chaincode with the technology of their choice.	外部チェーンコード・ランチャーの機能は、運用者が、好きな技術を使ってチェーンコードをビルド・起動できるようにするものです。
Use of external builders and launchers is not required as the default behavior builds and runs chaincode in the same manner as prior releases using the Docker API.	デフォルトの挙動は、以前のリリースと同様に、Docker APIを用いてチェーンコードをビルド・起動するもので、外部ビルダーとランチャーは必須ではありません。
Eliminate Docker daemon dependency	Dockerデーモンへの依存の削除:
Prior releases of Fabric required peers to have access to a Docker daemon in order to build and launch chaincode - something that may not be desirable in production environments due to the privileges required by the peer process.	以前のFabricリリースは、チェーンコードのビルドと起動のために、ピアがDockerデーモンに対してアクセス可能である必要がありました。これは、ピアプロセスに対して特権を与えることが必要になり、本番環境では好ましくないかもしれません。
Alternatives to containers	コンテナに対する代替:
Chaincode is no longer required to be run in Docker containers, and may be executed in the operator’s choice of environment (including containers).	チェーンコードは、Dockerコンテナとして起動する必要がなくなり、運用者の都合のよい環境 (コンテナを含む)で動かすことができるようになりました。
External builder executables	外部ビルダー実行可能ファイル:
An operator can provide a set of external builder executables to override how the peer builds and launches chaincode.	運用者は、外部ビルダー実行可能ファイル群を与えることで、ピアがチェーンコードをビルドし起動する方法をオーバーライドすることができます。
Chaincode as an external service	外部チェーンコードサービス:
Traditionally, chaincodes are launched by the peer, and then connect back to the peer.	従来は、チェーンコードはピアによって起動され、チェーンコードがピアに接続を行うするというものでした。
It is now possible to run chaincode as an external service, for example in a Kubernetes pod, which a peer can connect to and utilize for chaincode execution.	このリリースで、チェーンコードを外部サービスとして起動することが可能となりました。例えば、ピアから接続しチェーンコードの実行に利用できるKubernetesのpodなどです。
See :doc:`cc_service` for more information.	より詳細は、:doc:`cc_service` を参照してください。
See :doc:`cc_launcher` to learn more about the external chaincode launcher feature.	外部チェーンコードランチャーの機能の詳細については、:doc:`cc_launcher` を参照してください。
When using external CouchDB state database, read delays during endorsement and validation phases have historically been a performance bottleneck.	CouchDB を外部ステートデータベースとして利用するとき、エンドースメントや検証のフェーズでの読み込みの際の遅延(delay)は以前から性能のボトルネックとなっていました。
With Fabric v2.0, a new peer cache replaces many of these expensive lookups with fast local cache reads.	Fabric v2.0では、新しいピアのキャッシュによって、処理の重い参照の多くを、高速なローカルキャッシュからの読み込みに置き換えます。
The cache size can be configured by using the core.yaml property ``cacheSize``.	キャッシュのサイズは、core.yamlのプロパティである``cacheSize``で設定することができます。
Starting with v2.0, Hyperledger Fabric Docker images will use Alpine Linux, a security-oriented, lightweight Linux distribution.	v2.0から、Hyperledger FabricのDockerイメージは、セキュリティを重視した軽量なLinuxディストリビューションであるAlpine Linuxを使用します。
This means that Docker images are now much smaller, providing faster download and startup times, as well as taking up less disk space on host systems.	これにより、Dockerイメージがよりはるかに小さくなるため、ダウンロードと起動速度が向上し、ホストのディスク使用量も削減されます。
Alpine Linux is designed from the ground up with security in mind, and the minimalist nature of the Alpine distribution greatly reduces the risk of security vulnerabilities.	Alpine Linuxは、最初からセキュリティを考慮してデザインされており、Alpineディストリビューションのミニマリストな性質は、セキュリティ脆弱性のリスクを大幅に減らします。
The fabric-samples repository now includes a new Fabric test network.	新しいFabricのテストネットワークが、fabric-samplesのレポジトリに含まれるようになります。
The test network is built to be a modular and user friendly sample Fabric network that makes it easy to test your applications and smart contracts.	このネットワークは、アプリケーションやスマートコントラクトを簡単にテストすることができるモジュール化され、かつ、ユーザーフレンドリーなFabricのサンプルネットワークとなるように作られています。
The network also supports the ability to deploy your network using Certificate Authorities, in addition to cryptogen.	また、このネットワークは、cryptogenに加えて、認証局(CA)を用いたデプロイもサポートしています。
For more information about this network, check out :doc:`test_network`.	このテストネットワークについての詳細は、 :doc:`test_network` を参照してください。
A major new release brings some additional upgrade considerations.	新しいメジャーリリースでは、新たにいくつかアップグレード時に注意すべき点があります。
Rest assured though, that rolling upgrades from v1.4.x to v2.0 are supported, so that network components can be upgraded one at a time with no downtime.	でも大丈夫です。v1.4.xからv2.0へのローリングアップグレードはサポートされていますので、ネットワーク内のコンポーネントはダウンタイムなしに順次アップグレードすることができます。
The upgrade docs have been significantly expanded and reworked, and now have a standalone home in the documentation: :doc:`upgrade`.	アップグレードに関するドキュメントは、大幅に書き直され拡充されており、:doc:`upgrade` に一か所にまとめられています。
Here you'll find documentation on :doc:`upgrading_your_components` and :doc:`updating_capabilities`, as well as a specific look  at the considerations for upgrading to v2.x, :doc:`upgrade_to_newest_version`.	ここでは、:doc:`upgrading_your_components` や :doc:`updating_capabilities` 、また、特に各v2.xへのアップグレード時の注意すべき点 :doc:`upgrade_to_newest_version`といったドキュメントを見ることができます。
The release notes provide more details for users moving to the new release.	リリースノートには、ユーザーが新しいリリースに移行する際の詳細な情報があります。
Specifically, take a look at the changes and deprecations announced in each of the v2.x releases.	特に、各v2.xのリリースにおける変更点や非推奨となった項目のアナウンスには目を通しておきましょう。
